

===== https://www.motia.dev/docs =====

Welcome to Motia
Motia is a multi-language, event-driven runtime manager built on a core primitive: the Step. It feels like a backend framework, but powers distributed backends for APIs, background jobs, queues, workflows, agents, streaming, state, and observability, all unified in one system.
Welcome to Motia
Why Motia?
Backend development today is fragmented.
APIs live in one framework, background jobs in another, queues and schedulers elsewhere, and now AI agents and streaming systems have their own runtimes. Add observability and state management on top, and you’re stitching together half a dozen tools before writing your first feature.
Motia unifies all of these concerns around one core primitive: the Step.
Just as React made frontend development simple by introducing components, Motia redefines backend development with Steps.
Every backend pattern, API endpoints, background jobs, queues, workflows, AI agents, streaming, observability, and state, is expressed with the same primitive.
To read more about this, check out ourmanifesto.
The Core Primitive: the Step
At the heart of Motia is a single primitive: theStep.
A Step is just a file with aconfigand ahandler. Motia auto-discovers these files from/stepsdirectory and connects them automatically.
config
handler
/steps
Here’s a simple example of two Steps working together: an API Step that emits an event, and an Event Step that processes it.
exportconstconfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
exportconstconfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
exportconstconfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler=async(input, {logger})=>{logger.info('Processing message', input);};
exportconstconfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you’ve built anAPI endpoint, aqueue, and aworker. No extra frameworks required.
Learn more about Steps here:What is a Step?.
Working with multiple Languages
The rapid advancement of AI has reshaped the software industry—many cutting-edge AI tools are available only in specific programming languages, this forces companies to decide if they either change their team's skillset to a different language or not leveraging these technologies at all.
Motia removes this limitation by allowing each Step to be written in any language, while still sharing a common state.
Each rectangle in the diagram above represents a Step, some of them are in TypeScript and others in Python.
Scalability
One of the biggest dilemmas in backend development is choosing between scalability and development velocity. In startup environments, speed often takes priority, resulting in systems that don't scale well and become problematic under increased load.
Motia addresses scalability by leveraging the core primitive ofSteps: Each step can scale independently avoiding the bottlenecks common in monolithic architectures.
Observability
Observability in traditional backends often demands significant engineering effort to implement logging, alerting, and tracing. Typically, these tools are only configured for cloud environments, local development is generally neglected—leading to low productivity and poor dev experience.
Motia offers a complete observability toolkit available in both cloud and local environments, including:
Logs visualization
Tracing tool to quickly visualize the flow of requests through the system
State visualization
Diagram representation of dependencies between steps and how they are connected
The image below shows the Workbench interface available when you runmotia dev. On the top panel you can see a workflow diagram with multiple steps connected.
On the bottom panel you can see the trace view of a single request and what happened in each step.
motia dev
Fault tolerance
With the rise of AI, many backend tasks have become less deterministic and more error-prone. These scenarios require robust error handling and retry mechanisms. In traditional systems, developers often need to set up and maintain queue infrastructures to ensure resilience, especially when dealing with unreliable responses from LLMs.
Motia provides fault tolerance out of the box, eliminating the need to manually spin up queue infrastructure.
Using Event Steps, you get retry mechanisms out of the box
Configuration of queue infrastructure is abstracted away
Building and Shipping
Building and deploying backends is inherently complex—especially in polyglot environments. Shipping production systems requires tight collaboration between developers and operations, and automation often takes weeks to get right.
Beyond that, cloud provider lock-in, complicated deployment strategies (e.g., rollbacks, blue/green deployments), and a lack of deployment tooling increase the risk of failure.
Motia abstracts these concerns by providing:
True cloud-provider agnosticism
Atomic blue/green deployments and one-click rollbacks via Motia Cloud (canary support coming soon)
First-class polyglot backend support (currently Node.js and Python, with more on the way)
The image above shows several Steps being build to a single Motia deployable that are ultimately deployed to a cloud provider of your choice.
Currently we're supporting AWS and Kubernetes, more Cloud providers coming soon. Check ourroadmapfor more details.
Rollbacks and deployment strategies
Deploying cloud-native, fault-tolerant applications often involves modifying queue systems and other infrastructure components.
These changes can introduce incompatibilities and lead to runtime failures.
Motia Cloud solves this withAtomic Deployments, which:
Each deployment spins up a new isolated service that shares the same data layer
Ensures safe, rollback-capable deployments without risking service downtime
Instant rollbacks with one click since each deployment is isolated
Real-time data streaming
Handling real-time data is one of the most common—and complex—challenges in backend development. It's necessary when building event-driven applications,
and it typically requires setting up and maintaining a significant amount of infrastructure.
Motia provides what we callStreams: Developers define the structure of the data—any changes to these objects are streamed to all subscribed clients in real-time.
The image above shows a Stream definition, a Node.js Step mutating the data and a client subscribing to the stream receiving real-time updates.
Quick Start
Get up and running with a new Motia project in just a few seconds.
On this page



===== https://www.motia.dev/docs/getting-started/quick-start =====

Quick Start
Get up and running with a new Motia project in just a few seconds.
1. Create Your Project
Usenpxto create a new Motia project. This single command will scaffold a new application and install all necessary dependencies.
npx
npxmotia@latestcreate
npxmotia@latestcreate
The installer will guide you through a few questions to set up your project. Once it's done, you will have a new project directory ready to go.
2. Start the Development Server
Navigate into your new project directory and start the Motia development server.
cd<your-project-name># If you've created a new folder for the project, navigate into itnpxmotiadev
cd<your-project-name># If you've created a new folder for the project, navigate into itnpxmotiadev
Thecreatecommand usesnpmby default. If you chose a different package manager during setup, usepnpm dev,yarn dev, orbun dev.
create
npm
pnpm dev
yarn dev
bun dev
This command starts the Motia runtime and the Workbench, a powerful UI for developing and debugging your workflows. By default, it's available athttp://localhost:3000.
http://localhost:3000
3. Run Your First Flow
The starter project comes with a pre-builtbasic-tutorialflow. Let's run it.
basic-tutorial
Open the Workbenchin your browser athttp://localhost:3000.
http://localhost:3000
Click theTutorialbutton on the top right of the workbench.
Tutorial
Complete theTutorialto get an understanding of the basics of Motia and using the Workbench.
Tutorial
Next Steps
Congratulations! You've successfully ran, and observed your first Motia workflow.
Build your first application from scratch, follow ourBuild Your First Motia Appguide.
To learn about Motia, dive into ourCore Concepts.
Welcome to Motia
Motia is a multi-language, event-driven runtime manager built on a core primitive: the Step. It feels like a backend framework, but powers distributed backends for APIs, background jobs, queues, workflows, agents, streaming, state, and observability, all unified in one system.
Build Your First Motia App
Learn Motia step-by-step by building a real pet store backend
On this page



===== https://www.motia.dev/docs/getting-started/build-your-first-motia-app =====

Build Your First Motia App
Learn Motia step-by-step by building a real pet store backend
What You'll Build
A complete pet store backend system that grows with you:
API Endpoints→ Handle requests, return responses
Background Jobs→ Process tasks without blocking APIs
Workflows→ Coordinate complex business logic automatically
AI Agents→ Make intelligent decisions that drive your workflows
Real-Time Streaming→ Push live updates to clients as workflows execute
By the end, you'll have a production-ready backend that handles everything from simple CRUD to intelligent, real-time systems.
Before You Start
You'll need:
Node.js installed (v18 or higher)
Basic understanding of TypeScript/JavaScript/Python
10-20 minutes per tutorial
That's it. No database setup, no complex config, no separate services to run.
Your Journey
1. API Endpoints
What:Create HTTP endpoints that handle pet operations.
You'll learn:
How to define API Steps
Request validation with schemas
Returning proper HTTP responses
Testing endpoints in Workbench
Time:10 minutes
Start with APIs →
Build your first HTTP endpoints
2. Background Jobs
What:Add async tasks that run without blocking your APIs.
You'll learn:
Event Steps that trigger from your APIs
Cron Steps that run on a schedule
How events connect your system
Monitoring jobs in Workbench
Time:15 minutes
Add Background Jobs →
Handle async tasks efficiently
3. Workflows
What:Coordinate complex processes with automatic transitions and validation.
You'll learn:
Building workflow orchestrators
Automatic vs manual transitions
State validation and progression
Chaining multiple actions together
Time:20 minutes
Build Workflows →
Orchestrate complex business logic
4. AI Agents
What:Add intelligent decision-making to your workflows.
You'll learn:
Content generation with AI
Decision-making agents
Integrating AI with workflows
Building agentic routing
Time:20 minutes
Add AI Agents →
Make your backend intelligent
5. Real-Time Streaming
What:Push live updates to clients while your workflows run in the background.
You'll learn:
Defining stream configurations
Streaming from APIs that return immediately
Background jobs that push progress updates
AI agents that stream enrichment progress
Connecting multiple steps to the same stream
Time:20 minutes
Add Streaming →
Build real-time experiences
The Example Project
All tutorials use the same project - a pet store backend that handles:
Pet management→ Create, update, list pets
Adoption workflow→ Guide pets through quarantine, health checks, and availability
Feeding reminders→ Set up schedules when pets arrive
Health decisions→ AI evaluates symptoms and recommends treatment
Cleanup jobs→ Remove soft-deleted pets on a schedule
Real-time updates→ Stream progress to clients as workflows execute
It's a real system with the kind of complexity you'll face building production backends.
Interactive Tutorials
Each guide includes aninteractive tutorialyou can run directly in Workbench. It walks you through the code, explains what's happening, and lets you test everything live.
Prefer reading? The written guides cover everything too. They're detailed, with code examples and explanations for every concept.
Ready?
Pick your starting point. If you're new to Motia, start with API Endpoints. If you've already covered the basics, jump to wherever you want to learn more.
API Endpoints
Start here if you're new
Background Jobs
Add async processing
Workflows
Coordinate complex logic
AI Agents
Build intelligent systems
Real-Time Streaming
Push live updates
Quick Start
Get up and running with a new Motia project in just a few seconds.
API Endpoints
Learn how to create HTTP API endpoints with Motia
On this page



===== https://www.motia.dev/docs/getting-started/build-your-first-motia-app/api-endpoints =====

API Endpoints
Learn how to create HTTP API endpoints with Motia
What You'll Build
A pet management API with these endpoints:
POST/pets- Create a new pet
/pets
GET/pets- List all pets
/pets
GET/pets/:id- Get a specific pet
/pets/:id
PUT/pets/:id- Update a pet
/pets/:id
DELETE/pets/:id- Delete a pet
/pets/:id
Getting Started
Clone the example repository:
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutapi-endpoints
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutapi-endpoints
Install dependencies:
npminstall
npminstall
Start the Workbench:
npmrundev
npmrundev
Your Workbench will be available athttp://localhost:3000.
http://localhost:3000
Project Structure
Files likefeatures.jsonandtutorial.tsxare only for the interactive tutorial and are not part of Motia's project structure.
features.json
tutorial.tsx
All code examples in this guide are available in thebuild-your-first-apprepository.
You can follow this guide to learn how to build a REST API with Motia step by step, or you can clone the repository and dive into our Interactive Tutorial to learn by doing directly in the Workbench.
Creating Your First Endpoint
This tutorial focuses on Motia's capabilities to create complete backend system from APIs to Streaming AI agents step-by-step. Here, we're showcasing writing APIs with Motia Steps - For data persistence, we use a simple JSON file store in the examples. In a real application, you would use a database like PostgreSQL, MongoDB, or any other data store of your choice. The complete store implementation is available in theGitHub repository.
Configuration
Every API endpoint has two parts:
Config- Defines when and how the step runs:
name
type
'api'
path
method
Handler- The function that executes your business logic.
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constcreatePetSchema=z.object({name: z.string().min(1,'Name is required'),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0),})exportconstconfig:ApiRouteConfig={name:'CreatePet',type:'api',path:'/pets',method:'POST',bodySchema: createPetSchema,flows: ['PetManagement'],}exportconsthandler:Handlers['CreatePet']=async(req, {logger})=>{constdata=createPetSchema.parse(req.body)// In a real application, this would be a database call// e.g., await db.pets.create(data)constpet=TSStore.create(data)logger.info('Pet created', { petId: pet.id })return{ status:201, body: pet }}
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constcreatePetSchema=z.object({name: z.string().min(1,'Name is required'),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0),})exportconstconfig:ApiRouteConfig={name:'CreatePet',type:'api',path:'/pets',method:'POST',bodySchema: createPetSchema,flows: ['PetManagement'],}exportconsthandler:Handlers['CreatePet']=async(req, {logger})=>{constdata=createPetSchema.parse(req.body)// In a real application, this would be a database call// e.g., await db.pets.create(data)constpet=TSStore.create(data)logger.info('Pet created', { petId: pet.id })return{ status:201, body: pet }}
Testing Your API
You can test your endpoints using curl or the Workbench interface.
Using curl
# Create a petcurl-XPOSThttp://localhost:3000/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
# Create a petcurl-XPOSThttp://localhost:3000/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
Using Workbench
You can also test your endpoint directly in the Workbench, which provides an interactive interface to test your API endpoints with real requests and see the responses in real-time:
Adding GET Endpoints
List All Pets
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:ApiRouteConfig={name:'GetPets',type:'api',path:'/pets',method:'GET',flows: ['PetManagement'],}exportconsthandler:Handlers['GetPets']=async(req, {logger})=>{// In a real application, this would be a database call// e.g., const pets = await db.pets.findMany()constpets=TSStore.list()logger.info('Retrieved all pets', { count: pets.length})return{ status:200, body: pets }}
import{ ApiRouteConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:ApiRouteConfig={name:'GetPets',type:'api',path:'/pets',method:'GET',flows: ['PetManagement'],}exportconsthandler:Handlers['GetPets']=async(req, {logger})=>{// In a real application, this would be a database call// e.g., const pets = await db.pets.findMany()constpets=TSStore.list()logger.info('Retrieved all pets', { count: pets.length})return{ status:200, body: pets }}
Testing List All Pets
Test with curl:
# List all petscurlhttp://localhost:3000/pets
# List all petscurlhttp://localhost:3000/pets
Or use the Workbench interface:
Get Single Pet
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:ApiRouteConfig={name:'GetPet',type:'api',path:'/pets/:id',method:'GET',flows: ['PetManagement'],}exportconsthandler:Handlers['GetPet']=async(req, {logger})=>{// In a real application, this would be a database call// e.g., const pet = await db.pets.findById(req.pathParams.id)constpet=TSStore.get(req.pathParams.id)if(!pet) {logger.warn('Pet not found', { id: req.pathParams.id })return{ status:404, body: { message:'Pet not found'} }}return{ status:200, body: pet }}
import{ ApiRouteConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:ApiRouteConfig={name:'GetPet',type:'api',path:'/pets/:id',method:'GET',flows: ['PetManagement'],}exportconsthandler:Handlers['GetPet']=async(req, {logger})=>{// In a real application, this would be a database call// e.g., const pet = await db.pets.findById(req.pathParams.id)constpet=TSStore.get(req.pathParams.id)if(!pet) {logger.warn('Pet not found', { id: req.pathParams.id })return{ status:404, body: { message:'Pet not found'} }}return{ status:200, body: pet }}
Testing tip:When testing GET endpoints with path parameters like/pets/:id, switch to theParamstab (not Body) to enter the ID value.
/pets/:id
The:idin the path creates a path parameter accessible viareq.pathParams.id.
:id
req.pathParams.id
Testing Get Single Pet
Test with curl:
# Get specific pet (replace 1 with an actual pet ID)curlhttp://localhost:3000/pets/1
# Get specific pet (replace 1 with an actual pet ID)curlhttp://localhost:3000/pets/1
Or use the Workbench interface:
Adding UPDATE Endpoint
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constupdatePetSchema=z.object({name: z.string().min(1).optional(),status: z.enum(['available','pending','adopted']).optional(),ageMonths: z.number().int().min(0).optional(),})exportconstconfig:ApiRouteConfig={name:'UpdatePet',type:'api',path:'/pets/:id',method:'PUT',bodySchema: updatePetSchema,flows: ['PetManagement'],}exportconsthandler:Handlers['UpdatePet']=async(req, {logger})=>{constupdates=updatePetSchema.parse(req.body)// In a real application, this would be a database call// e.g., const pet = await db.pets.update(req.pathParams.id, updates)constpet=TSStore.update(req.pathParams.id, updates)if(!pet) {return{ status:404, body: { message:'Pet not found'} }}logger.info('Pet updated', { petId: pet.id })return{ status:200, body: pet }}
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constupdatePetSchema=z.object({name: z.string().min(1).optional(),status: z.enum(['available','pending','adopted']).optional(),ageMonths: z.number().int().min(0).optional(),})exportconstconfig:ApiRouteConfig={name:'UpdatePet',type:'api',path:'/pets/:id',method:'PUT',bodySchema: updatePetSchema,flows: ['PetManagement'],}exportconsthandler:Handlers['UpdatePet']=async(req, {logger})=>{constupdates=updatePetSchema.parse(req.body)// In a real application, this would be a database call// e.g., const pet = await db.pets.update(req.pathParams.id, updates)constpet=TSStore.update(req.pathParams.id, updates)if(!pet) {return{ status:404, body: { message:'Pet not found'} }}logger.info('Pet updated', { petId: pet.id })return{ status:200, body: pet }}
Testing Update Pet
Test with curl:
# Update a pet (replace 1 with an actual pet ID)curl-XPUThttp://localhost:3000/pets/1\-H"Content-Type: application/json"\-d'{"status": "adopted"}'
# Update a pet (replace 1 with an actual pet ID)curl-XPUThttp://localhost:3000/pets/1\-H"Content-Type: application/json"\-d'{"status": "adopted"}'
Or use the Workbench interface:
Adding DELETE Endpoint
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:ApiRouteConfig={name:'DeletePet',type:'api',path:'/pets/:id',method:'DELETE',flows: ['PetManagement'],}exportconsthandler:Handlers['DeletePet']=async(req, {logger})=>{// In a real application, this would be a database call// e.g., const deleted = await db.pets.delete(req.pathParams.id)constdeleted=TSStore.remove(req.pathParams.id)if(!deleted) {return{ status:404, body: { message:'Pet not found'} }}logger.info('Pet deleted', { petId: req.pathParams.id })return{ status:204}}
import{ ApiRouteConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:ApiRouteConfig={name:'DeletePet',type:'api',path:'/pets/:id',method:'DELETE',flows: ['PetManagement'],}exportconsthandler:Handlers['DeletePet']=async(req, {logger})=>{// In a real application, this would be a database call// e.g., const deleted = await db.pets.delete(req.pathParams.id)constdeleted=TSStore.remove(req.pathParams.id)if(!deleted) {return{ status:404, body: { message:'Pet not found'} }}logger.info('Pet deleted', { petId: req.pathParams.id })return{ status:204}}
DELETE endpoints return204 No Contenton success.
204 No Content
Testing Delete Pet
Test with curl:
# Delete a pet (replace 1 with an actual pet ID)curl-XDELETEhttp://localhost:3000/pets/1
# Delete a pet (replace 1 with an actual pet ID)curl-XDELETEhttp://localhost:3000/pets/1
Or use the Workbench interface:
As you can see in this example, Motia handles routing, validation, and error handling automatically. With just a few lines of code, you've built a complete REST API with:
Automatic routingbased on your step configuration
Path parameter extraction(/pets/:id→req.pathParams.id)
/pets/:id
req.pathParams.id
HTTP method handling(GET, POST, PUT, DELETE)
Response formattingwith proper status codes
Built-in error handlingand validation
🎉Congratulations!You've successfully created your first API endpoints with Motia. Your pet store API is now ready to handle all CRUD operations.
What's Next?
You now have a working REST API for your pet store! But a complete backend system needs more than just API endpoints. In the next guide, we'll add background jobs using Event Steps and scheduled tasks with Cron Steps to handle tasks like:
SetNextFeedingReminder- Queue jobs that automatically schedule feeding reminders when pets are added or updated
Deletion Reaper- Cron jobs that run daily to clean up soft-deleted records and expired data
Let's continue building your complete backend system by adding these background jobs with Event Steps and scheduled tasks with Cron Steps.
Build Your First Motia App
Learn Motia step-by-step by building a real pet store backend
Background Jobs
Learn how to create async background jobs and scheduled tasks with Motia
On this page



===== https://www.motia.dev/docs/getting-started/build-your-first-motia-app/background-jobs =====

Background Jobs
Learn how to create async background jobs and scheduled tasks with Motia
What You'll Build
A pet management system with background jobs that handle:
Event Step- Async job that sets feeding reminders when pets are created
Cron Step- Scheduled job that runs daily to clean up deleted pets
Getting Started
Clone the example repository:
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutbackground-jobs
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutbackground-jobs
Install dependencies:
npminstall
npminstall
Start the Workbench:
npmrundev
npmrundev
Your Workbench will be available athttp://localhost:3000.
http://localhost:3000
Project Structure
Files likefeatures.jsonandtutorial.tsxare only for the interactive tutorial and are not part of Motia's project structure.
features.json
tutorial.tsx
All code examples in this guide are available in thebuild-your-first-apprepository.
You can follow this guide to learn how to build background jobs with Motia step by step, or you can clone the repository and dive into our Interactive Tutorial to learn by doing directly in the Workbench.
Understanding Background Jobs
Background jobs let you handle time-consuming tasks without blocking your API responses. When a user creates a pet, they get an immediate response while tasks like sending emails or processing data happen in the background.
Motia provides two types of background jobs:
Event Steps- Triggered by events from your API endpoints
Cron Steps- Run on a schedule (like daily cleanup tasks)
Creating Your First Event Step
Let's create a background job that sets feeding reminders when a pet is created. First, we need to emit an event from our API endpoint.
Step 1: Emit Events from API
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constcreatePetSchema=z.object({name: z.string().min(1,'Name is required').trim(),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0,'Age must be a positive number')})exportconstconfig:ApiRouteConfig={type:'api',name:'TsCreatePet',path:'/ts/pets',method:'POST',// Declare what events this endpoint can emitemits: ['ts.feeding.reminder.enqueued'],flows: ['TsPetManagement'],bodySchema: createPetSchema}exportconsthandler:Handlers['TsCreatePet']=async(req, {emit,logger})=>{try{constvalidatedData=createPetSchema.parse(req.body)constpet=TSStore.create({name: validatedData.name,species: validatedData.species,ageMonths: validatedData.ageMonths})if(logger) {logger.info('🐾 Pet created', {petId: pet.id,name: pet.name,species: pet.species,status: pet.status})}// Emit event to trigger background jobif(emit) {awaitemit({topic:'ts.feeding.reminder.enqueued',data: {petId: pet.id,enqueuedAt: Date.now()}})}return{ status:201, body: pet }}catch(error) {if(errorinstanceofz.ZodError) {return{status:400,body: {message:'Validation error',errors: error.errors}}}if(logger) {logger.error('❌ Pet creation failed', {error: errorinstanceofError?error.message:'Unknown error'})}return{status:500,body: { message:'Internal server error'}}}}
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constcreatePetSchema=z.object({name: z.string().min(1,'Name is required').trim(),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0,'Age must be a positive number')})exportconstconfig:ApiRouteConfig={type:'api',name:'TsCreatePet',path:'/ts/pets',method:'POST',// Declare what events this endpoint can emitemits: ['ts.feeding.reminder.enqueued'],flows: ['TsPetManagement'],bodySchema: createPetSchema}exportconsthandler:Handlers['TsCreatePet']=async(req, {emit,logger})=>{try{constvalidatedData=createPetSchema.parse(req.body)constpet=TSStore.create({name: validatedData.name,species: validatedData.species,ageMonths: validatedData.ageMonths})if(logger) {logger.info('🐾 Pet created', {petId: pet.id,name: pet.name,species: pet.species,status: pet.status})}// Emit event to trigger background jobif(emit) {awaitemit({topic:'ts.feeding.reminder.enqueued',data: {petId: pet.id,enqueuedAt: Date.now()}})}return{ status:201, body: pet }}catch(error) {if(errorinstanceofz.ZodError) {return{status:400,body: {message:'Validation error',errors: error.errors}}}if(logger) {logger.error('❌ Pet creation failed', {error: errorinstanceofError?error.message:'Unknown error'})}return{status:500,body: { message:'Internal server error'}}}}
The API endpoint now emits an event after creating a pet. The response returns immediately while the background job processes asynchronously.
Step 2: Create the Event Step
Now let's create the background job that listens for this event and sets feeding reminders.
View on GitHub:
TypeScript
Python
JavaScript
import{ EventConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig={type:'event',name:'TsSetNextFeedingReminder',description:'Background job that sets next feeding reminder and adds welcome notes',// Subscribe to the event emitted by CreatePetsubscribes: ['ts.feeding.reminder.enqueued'],emits: [],flows: ['TsPetManagement']}exportconsthandler:Handlers['TsSetNextFeedingReminder']=async(input, {emit,logger})=>{const{petId,enqueuedAt}=inputif(logger) {logger.info('🔄 Setting next feeding reminder', { petId, enqueuedAt })}try{// Calculate next feeding time (24 hours from now)constnextFeedingAt=Date.now()+(24*60*60*1000)// Fill in non-critical detailsconstupdates={notes:'Welcome to our pet store! We\'ll take great care of this pet.',nextFeedingAt: nextFeedingAt}constupdatedPet=TSStore.update(petId, updates)if(!updatedPet) {if(logger) {logger.error('❌ Failed to set feeding reminder - pet not found', { petId })}return}if(logger) {logger.info('✅ Next feeding reminder set', {petId,notes: updatedPet.notes?.substring(0,50)+'...',nextFeedingAt:newDate(nextFeedingAt).toISOString()})}// Feeding reminder scheduled successfully}catch(error:any) {if(logger) {logger.error('❌ Feeding reminder job error', { petId, error: error.message })}}}
import{ EventConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig={type:'event',name:'TsSetNextFeedingReminder',description:'Background job that sets next feeding reminder and adds welcome notes',// Subscribe to the event emitted by CreatePetsubscribes: ['ts.feeding.reminder.enqueued'],emits: [],flows: ['TsPetManagement']}exportconsthandler:Handlers['TsSetNextFeedingReminder']=async(input, {emit,logger})=>{const{petId,enqueuedAt}=inputif(logger) {logger.info('🔄 Setting next feeding reminder', { petId, enqueuedAt })}try{// Calculate next feeding time (24 hours from now)constnextFeedingAt=Date.now()+(24*60*60*1000)// Fill in non-critical detailsconstupdates={notes:'Welcome to our pet store! We\'ll take great care of this pet.',nextFeedingAt: nextFeedingAt}constupdatedPet=TSStore.update(petId, updates)if(!updatedPet) {if(logger) {logger.error('❌ Failed to set feeding reminder - pet not found', { petId })}return}if(logger) {logger.info('✅ Next feeding reminder set', {petId,notes: updatedPet.notes?.substring(0,50)+'...',nextFeedingAt:newDate(nextFeedingAt).toISOString()})}// Feeding reminder scheduled successfully}catch(error:any) {if(logger) {logger.error('❌ Feeding reminder job error', { petId, error: error.message })}}}
How Event Steps Work
Event Steps have a few key differences from API Steps:
typeis set to'event'instead of'api'
'event'
'api'
subscribeslists the events this job listens for
handlerreceives the event data as the first argument
When you create a pet, the API returns immediately. The background job picks up the event and processes it asynchronously.
Testing Your Background Job
Create a pet and watch the background job execute:
# Create a petcurl-XPOSThttp://localhost:3000/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
# Create a petcurl-XPOSThttp://localhost:3000/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
Check the logs in Workbench to see both the API call and the background job execution:
You'll see:
"Pet created" log from the API endpoint
"Setting next feeding reminder" log from the background job
"Next feeding reminder set" log when the job completes
Creating a Scheduled Cron Job
Now let's create a cron job that runs daily to clean up soft-deleted pets. This demonstrates how to handle scheduled maintenance tasks.
View on GitHub:
TypeScript
Python
JavaScript
import{ CronConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:CronConfig={type:'cron',name:'TsDeletionReaper',description:'Daily job that permanently removes pets scheduled for deletion',cron:'0 2 * * *',// Daily at 2:00 AMemits: [],flows: ['TsPetManagement']}exportconsthandler:Handlers['TsDeletionReaper']=async({emit,logger})=>{if(logger) {logger.info('🔄 Deletion Reaper started - scanning for pets to purge')}try{constpetsToReap=TSStore.findDeletedPetsReadyToPurge()if(petsToReap.length===0) {if(logger) {logger.info('✅ Deletion Reaper completed - no pets to purge')}// No emit - no subscribers for ts.reaper.completedreturn}letpurgedCount=0for(constpetofpetsToReap) {constsuccess=TSStore.remove(pet.id)if(success) {purgedCount++if(logger) {logger.info('💀 Pet permanently purged', {petId: pet.id,name: pet.name,deletedAt:newDate(pet.deletedAt!).toISOString(),purgeAt:newDate(pet.purgeAt!).toISOString()})}// No emit - no subscribers for ts.pet.purged}else{if(logger) {logger.warn('⚠️ Failed to purge pet', { petId: pet.id, name: pet.name })}}}if(logger) {logger.info('✅ Deletion Reaper completed', {totalScanned: petsToReap.length,purgedCount,failedCount: petsToReap.length-purgedCount})}// No emit - no subscribers for ts.reaper.completed}catch(error:any) {if(logger) {logger.error('❌ Deletion Reaper error', { error: error.message })}}}
import{ CronConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:CronConfig={type:'cron',name:'TsDeletionReaper',description:'Daily job that permanently removes pets scheduled for deletion',cron:'0 2 * * *',// Daily at 2:00 AMemits: [],flows: ['TsPetManagement']}exportconsthandler:Handlers['TsDeletionReaper']=async({emit,logger})=>{if(logger) {logger.info('🔄 Deletion Reaper started - scanning for pets to purge')}try{constpetsToReap=TSStore.findDeletedPetsReadyToPurge()if(petsToReap.length===0) {if(logger) {logger.info('✅ Deletion Reaper completed - no pets to purge')}// No emit - no subscribers for ts.reaper.completedreturn}letpurgedCount=0for(constpetofpetsToReap) {constsuccess=TSStore.remove(pet.id)if(success) {purgedCount++if(logger) {logger.info('💀 Pet permanently purged', {petId: pet.id,name: pet.name,deletedAt:newDate(pet.deletedAt!).toISOString(),purgeAt:newDate(pet.purgeAt!).toISOString()})}// No emit - no subscribers for ts.pet.purged}else{if(logger) {logger.warn('⚠️ Failed to purge pet', { petId: pet.id, name: pet.name })}}}if(logger) {logger.info('✅ Deletion Reaper completed', {totalScanned: petsToReap.length,purgedCount,failedCount: petsToReap.length-purgedCount})}// No emit - no subscribers for ts.reaper.completed}catch(error:any) {if(logger) {logger.error('❌ Deletion Reaper error', { error: error.message })}}}
Understanding Cron Steps
Cron Steps run on a schedule defined by a cron expression:
typeis set to'cron'
'cron'
crondefines when the job runs (e.g.,'0 2 * * *'= daily at 2 AM)
'0 2 * * *'
handlerreceives only the context (no input data like Event Steps)
Common cron patterns:
'*/5 * * * *'- Every 5 minutes
'*/5 * * * *'
'0 * * * *'- Every hour
'0 * * * *'
'0 0 * * *'- Daily at midnight
'0 0 * * *'
'0 9 * * 1'- Every Monday at 9 AM
'0 9 * * 1'
Monitoring Background Jobs
Workbench provides tools to monitor your background jobs:
Tracing
See the complete execution flow from API call to background job:
Each trace shows:
When the API endpoint was called
When events were emitted
When background jobs started and completed
Total processing time
🎉Congratulations!You've successfully created background jobs with Motia. Your pet store now handles async tasks efficiently without blocking API responses.
What's Next?
You now have a complete backend system with API endpoints and background jobs! But there's more power in Motia when you combine everything into workflows.
In the next guide, we'll build completeworkflow orchestrationsthat connect multiple Steps together:
Queue-Based Job Processing- SetNextFeedingReminder triggered by pet creation, processing asynchronously without blocking API responses
Scheduled Maintenance Tasks- Deletion Reaper running daily at 2 AM to permanently remove soft-deleted pets past their purge date
Pet Lifecycle Orchestration- Staff-driven workflow managing pet status transitions from creation through quarantine, health checks, and adoption
Event-Driven State Management- Centralized orchestrator ensuring consistent pet status changes with automatic progressions and staff decision points
Let's continue building by creating workflows that orchestrate your APIs and background jobs into powerful, event-driven systems.
API Endpoints
Learn how to create HTTP API endpoints with Motia
Workflows
Learn how to build automated workflows that manage complex business logic with Motia
On this page



===== https://www.motia.dev/docs/getting-started/build-your-first-motia-app/workflows =====

Workflows
Learn how to build automated workflows that manage complex business logic with Motia
What You'll Build
A pet lifecycle management system that automatically guides pets through their journey at your shelter:
Automated Status Transitions- Pets move through stages automatically when conditions are met
Staff Decision Points- Critical checkpoints where staff make the calls
Smart Progressions- Some transitions trigger follow-up actions automatically
Validation Rules- Prevents invalid status changes to keep data consistent
Getting Started
Clone the example repository:
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutworkflow-orchestration
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutworkflow-orchestration
Install dependencies:
npminstall
npminstall
Start the Workbench:
npmrundev
npmrundev
Your Workbench will be available athttp://localhost:3000.
http://localhost:3000
Project Structure
Files likefeatures.jsonandtutorial.tsxare only for the interactive tutorial and are not part of Motia's project structure.
features.json
tutorial.tsx
All code examples in this guide are available in thebuild-your-first-apprepository.
You can follow this guide to learn how to build workflow orchestration with Motia step by step, or you can clone the repository and dive into our Interactive Tutorial to learn by doing directly in the Workbench.
Understanding Workflows
So far, you've built API endpoints that respond to requests and background jobs that handle async tasks. But what about coordinating complex business processes that involve multiple steps and decision points?
That's where workflows come in. It's the conductor of your system - making sure things happen in the right order, at the right time, and only when it makes sense.
In our pet shelter example, a pet goes through many stages:
New arrivals need health checks
Healthy pets become available for adoption
Sick pets need treatment before they're ready
Adoption applications require staff approval
A workflow manages all these transitions, enforcing the rules and keeping everything consistent.
The Pet Lifecycle Journey
When you create a pet, it starts asnew. Once the feeding reminder job completes, it automatically moves toin_quarantine. Staff then checks on it and marks ithealthy, which automatically progresses toavailable. When someone wants to adopt, it goespending, then finallyadopted.
new
in_quarantine
healthy
available
pending
adopted
The key here is some transitions happen automatically (likehealthy→available), while others need staff approval (likein_quarantine→healthy).
healthy
available
in_quarantine
healthy
What about sick pets?
If staff finds a pet isill, it automatically moves tounder_treatment. When staff marks itrecovered, it chains through automatic transitions:recovered→healthy→available.
ill
under_treatment
recovered
recovered
healthy
available
This mix of automatic progressions and human decision points is what makes workflows powerful - the system handles the routine stuff while keeping people in control of important calls.
Creating the Workflow
The workflow orchestrator is a single Event Step that manages all pet lifecycle transitions. Here's the complete implementation:
View on GitHub:
TypeScript
Python
JavaScript
// steps/typescript/pet-lifecycle-orchestrator.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore, Pet }from'./ts-store';typeLifecycleEvent=|'pet.created'|'feeding.reminder.completed'|'status.update.requested';typeTransitionRule={from:Pet["status"][];to:Pet["status"];event:LifecycleEvent;description:string;};constTRANSITION_RULES:TransitionRule[]=[{from: ["new"],to:"in_quarantine",event:"feeding.reminder.completed",description:"Pet moved to quarantine after feeding setup"},{from: ["in_quarantine"],to:"healthy",event:"status.update.requested",description:"Staff health check - pet cleared from quarantine"},{from: ["healthy","in_quarantine","available"],to:"ill",event:"status.update.requested",description:"Staff assessment - pet identified as ill"},{from: ["healthy"],to:"available",event:"status.update.requested",description:"Staff decision - pet ready for adoption"},{from: ["ill"],to:"under_treatment",event:"status.update.requested",description:"Staff decision - treatment started"},{from: ["under_treatment"],to:"recovered",event:"status.update.requested",description:"Staff assessment - treatment completed"},{from: ["recovered"],to:"healthy",event:"status.update.requested",description:"Staff clearance - pet fully recovered"},{from: ["available"],to:"pending",event:"status.update.requested",description:"Adoption application received"},{from: ["pending"],to:"adopted",event:"status.update.requested",description:"Adoption completed"},{from: ["pending"],to:"available",event:"status.update.requested",description:"Adoption application rejected/cancelled"}];exportconstconfig={type:'event',name:'TsPetLifecycleOrchestrator',description:'Pet lifecycle state management with staff interaction points',subscribes: ['ts.pet.created','ts.feeding.reminder.completed','ts.pet.status.update.requested'],emits: [],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsPetLifecycleOrchestrator']=async(input, {emit,logger})=>{const{petId,event:eventType,requestedStatus,automatic}=input;if(logger) {constlogMessage=automatic?'🤖 Automatic progression':'🔄 Lifecycle orchestrator processing';logger.info(logMessage, { petId, eventType, requestedStatus, automatic });}try{constpet=TSStore.get(petId);if(!pet) {if(logger) {logger.error('❌ Pet not found for lifecycle transition', { petId, eventType });}return;}// For status update requests, find the rule based on requested statusletrule;if(eventType==='status.update.requested'&&requestedStatus) {rule=TRANSITION_RULES.find(r=>r.event===eventType&&r.from.includes(pet.status)&&r.to===requestedStatus);}else{// For other events (like feeding.reminder.completed)rule=TRANSITION_RULES.find(r=>r.event===eventType&&r.from.includes(pet.status));}if(!rule) {constreason=eventType==='status.update.requested'?`Invalid transition: cannot change from ${pet.status} to ${requestedStatus}`:`No transition rule found for ${eventType} from ${pet.status}`;if(logger) {logger.warn('⚠️ Transition rejected', {petId,currentStatus: pet.status,requestedStatus,eventType,reason});}// Transition rejected - no event emission neededreturn;}// Check for idempotencyif(pet.status===rule.to) {if(logger) {logger.info('✅ Already in target status', {petId,status: pet.status,eventType});}return;}// Apply the transitionconstoldStatus=pet.status;constupdatedPet=TSStore.updateStatus(petId, rule.to);if(!updatedPet) {if(logger) {logger.error('❌ Failed to update pet status', { petId, oldStatus, newStatus: rule.to });}return;}if(logger) {logger.info('✅ Lifecycle transition completed', {petId,oldStatus,newStatus: rule.to,eventType,description: rule.description,timestamp: Date.now()});}// Transition completed successfullyif(logger) {logger.info('✅ Pet status transition completed', {petId,oldStatus,newStatus: rule.to,eventType,description: rule.description});}// Check for automatic progressions after successful transitionawaitprocessAutomaticProgression(petId, rule.to, emit, logger);}catch(error:any) {if(logger) {logger.error('❌ Lifecycle orchestrator error', { petId, eventType, error: error.message });}}};asyncfunctionprocessAutomaticProgression(petId:string,currentStatus:Pet["status"],emit:any,logger:any) {// Define automatic progressionsconstautomaticProgressions:Partial<Record<Pet["status"], {to:Pet["status"],description:string}>>={'healthy': { to:'available', description:'Automatic progression - pet ready for adoption'},'ill': { to:'under_treatment', description:'Automatic progression - treatment started'},'recovered': { to:'healthy', description:'Automatic progression - recovery complete'}};constprogression=automaticProgressions[currentStatus];if(progression) {if(logger) {logger.info('🤖 Processing automatic progression', {petId,currentStatus,nextStatus: progression.to});}// Find the transition rule for automatic progressionconstrule=TRANSITION_RULES.find(r=>r.event==='status.update.requested'&&r.from.includes(currentStatus)&&r.to===progression.to);if(rule) {// Apply the automatic transition immediatelyconstoldStatus=currentStatus;constupdatedPet=TSStore.updateStatus(petId, rule.to);if(updatedPet) {if(logger) {logger.info('✅ Automatic progression completed', {petId,oldStatus,newStatus: rule.to,description: progression.description,timestamp: Date.now()});}// Automatic progression completed successfullyif(logger) {logger.info('✅ Automatic progression completed', {petId,oldStatus,newStatus: rule.to,description: progression.description});}// Check for further automatic progressions (for chaining like recovered → healthy → available)awaitprocessAutomaticProgression(petId, rule.to, emit, logger);}elseif(logger) {logger.error('❌ Failed to apply automatic progression', { petId, oldStatus, newStatus: rule.to });}}elseif(logger) {logger.warn('⚠️ No transition rule found for automatic progression', {petId,currentStatus,targetStatus: progression.to});}}}
// steps/typescript/pet-lifecycle-orchestrator.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore, Pet }from'./ts-store';typeLifecycleEvent=|'pet.created'|'feeding.reminder.completed'|'status.update.requested';typeTransitionRule={from:Pet["status"][];to:Pet["status"];event:LifecycleEvent;description:string;};constTRANSITION_RULES:TransitionRule[]=[{from: ["new"],to:"in_quarantine",event:"feeding.reminder.completed",description:"Pet moved to quarantine after feeding setup"},{from: ["in_quarantine"],to:"healthy",event:"status.update.requested",description:"Staff health check - pet cleared from quarantine"},{from: ["healthy","in_quarantine","available"],to:"ill",event:"status.update.requested",description:"Staff assessment - pet identified as ill"},{from: ["healthy"],to:"available",event:"status.update.requested",description:"Staff decision - pet ready for adoption"},{from: ["ill"],to:"under_treatment",event:"status.update.requested",description:"Staff decision - treatment started"},{from: ["under_treatment"],to:"recovered",event:"status.update.requested",description:"Staff assessment - treatment completed"},{from: ["recovered"],to:"healthy",event:"status.update.requested",description:"Staff clearance - pet fully recovered"},{from: ["available"],to:"pending",event:"status.update.requested",description:"Adoption application received"},{from: ["pending"],to:"adopted",event:"status.update.requested",description:"Adoption completed"},{from: ["pending"],to:"available",event:"status.update.requested",description:"Adoption application rejected/cancelled"}];exportconstconfig={type:'event',name:'TsPetLifecycleOrchestrator',description:'Pet lifecycle state management with staff interaction points',subscribes: ['ts.pet.created','ts.feeding.reminder.completed','ts.pet.status.update.requested'],emits: [],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsPetLifecycleOrchestrator']=async(input, {emit,logger})=>{const{petId,event:eventType,requestedStatus,automatic}=input;if(logger) {constlogMessage=automatic?'🤖 Automatic progression':'🔄 Lifecycle orchestrator processing';logger.info(logMessage, { petId, eventType, requestedStatus, automatic });}try{constpet=TSStore.get(petId);if(!pet) {if(logger) {logger.error('❌ Pet not found for lifecycle transition', { petId, eventType });}return;}// For status update requests, find the rule based on requested statusletrule;if(eventType==='status.update.requested'&&requestedStatus) {rule=TRANSITION_RULES.find(r=>r.event===eventType&&r.from.includes(pet.status)&&r.to===requestedStatus);}else{// For other events (like feeding.reminder.completed)rule=TRANSITION_RULES.find(r=>r.event===eventType&&r.from.includes(pet.status));}if(!rule) {constreason=eventType==='status.update.requested'?`Invalid transition: cannot change from ${pet.status} to ${requestedStatus}`:`No transition rule found for ${eventType} from ${pet.status}`;if(logger) {logger.warn('⚠️ Transition rejected', {petId,currentStatus: pet.status,requestedStatus,eventType,reason});}// Transition rejected - no event emission neededreturn;}// Check for idempotencyif(pet.status===rule.to) {if(logger) {logger.info('✅ Already in target status', {petId,status: pet.status,eventType});}return;}// Apply the transitionconstoldStatus=pet.status;constupdatedPet=TSStore.updateStatus(petId, rule.to);if(!updatedPet) {if(logger) {logger.error('❌ Failed to update pet status', { petId, oldStatus, newStatus: rule.to });}return;}if(logger) {logger.info('✅ Lifecycle transition completed', {petId,oldStatus,newStatus: rule.to,eventType,description: rule.description,timestamp: Date.now()});}// Transition completed successfullyif(logger) {logger.info('✅ Pet status transition completed', {petId,oldStatus,newStatus: rule.to,eventType,description: rule.description});}// Check for automatic progressions after successful transitionawaitprocessAutomaticProgression(petId, rule.to, emit, logger);}catch(error:any) {if(logger) {logger.error('❌ Lifecycle orchestrator error', { petId, eventType, error: error.message });}}};asyncfunctionprocessAutomaticProgression(petId:string,currentStatus:Pet["status"],emit:any,logger:any) {// Define automatic progressionsconstautomaticProgressions:Partial<Record<Pet["status"], {to:Pet["status"],description:string}>>={'healthy': { to:'available', description:'Automatic progression - pet ready for adoption'},'ill': { to:'under_treatment', description:'Automatic progression - treatment started'},'recovered': { to:'healthy', description:'Automatic progression - recovery complete'}};constprogression=automaticProgressions[currentStatus];if(progression) {if(logger) {logger.info('🤖 Processing automatic progression', {petId,currentStatus,nextStatus: progression.to});}// Find the transition rule for automatic progressionconstrule=TRANSITION_RULES.find(r=>r.event==='status.update.requested'&&r.from.includes(currentStatus)&&r.to===progression.to);if(rule) {// Apply the automatic transition immediatelyconstoldStatus=currentStatus;constupdatedPet=TSStore.updateStatus(petId, rule.to);if(updatedPet) {if(logger) {logger.info('✅ Automatic progression completed', {petId,oldStatus,newStatus: rule.to,description: progression.description,timestamp: Date.now()});}// Automatic progression completed successfullyif(logger) {logger.info('✅ Automatic progression completed', {petId,oldStatus,newStatus: rule.to,description: progression.description});}// Check for further automatic progressions (for chaining like recovered → healthy → available)awaitprocessAutomaticProgression(petId, rule.to, emit, logger);}elseif(logger) {logger.error('❌ Failed to apply automatic progression', { petId, oldStatus, newStatus: rule.to });}}elseif(logger) {logger.warn('⚠️ No transition rule found for automatic progression', {petId,currentStatus,targetStatus: progression.to});}}}
How the Orchestrator Works
The orchestrator has three main responsibilities:
Validate Transitions- Ensures pets can only move to valid next statuses
Apply Transitions- Updates the pet's status in the store
Trigger Automatic Progressions- Some statuses automatically progress to the next stage
Key Points:
emits: []- The orchestrator doesn't declare emits because it only manages state internally
emits: []
JavaScript/Python emit events for workflow tracking (optional pattern)
TypeScript focuses purely on state management
All languages validate transitions using the sameTRANSITION_RULES
TRANSITION_RULES
Testing Your Orchestrator
The best way to test your orchestrator is throughWorkbench. It lets you send requests, watch the workflow execute in real-time, and see all the logs in one place.
Create a Pet
Open Workbench and test the CreatePet endpoint:
You'll see in the logs:
🐾 Pet created { petId: '1', name: 'Max', species: 'dog', status: 'new' }🔄 Setting next feeding reminder { petId: '1' }✅ Next feeding reminder set { petId: '1' }🔄 Lifecycle orchestrator processing { petId: '1', eventType: 'feeding.reminder.completed' }✅ Lifecycle transition completed { oldStatus: 'new', newStatus: 'in_quarantine' }
🐾 Pet created { petId: '1', name: 'Max', species: 'dog', status: 'new' }🔄 Setting next feeding reminder { petId: '1' }✅ Next feeding reminder set { petId: '1' }🔄 Lifecycle orchestrator processing { petId: '1', eventType: 'feeding.reminder.completed' }✅ Lifecycle transition completed { oldStatus: 'new', newStatus: 'in_quarantine' }
Prefer using curl?You can also test with command line:
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
Staff Health Check
Test the UpdatePet endpoint in Workbench to mark the pet as healthy:
Watch the automatic progression:
👤 Staff requesting status change { petId: '1', requestedStatus: 'healthy' }🔄 Lifecycle orchestrator processing { petId: '1', eventType: 'status.update.requested' }✅ Lifecycle transition completed { oldStatus: 'in_quarantine', newStatus: 'healthy' }🤖 Processing automatic progression { petId: '1', currentStatus: 'healthy', nextStatus: 'available' }✅ Automatic progression completed { oldStatus: 'healthy', newStatus: 'available' }
👤 Staff requesting status change { petId: '1', requestedStatus: 'healthy' }🔄 Lifecycle orchestrator processing { petId: '1', eventType: 'status.update.requested' }✅ Lifecycle transition completed { oldStatus: 'in_quarantine', newStatus: 'healthy' }🤖 Processing automatic progression { petId: '1', currentStatus: 'healthy', nextStatus: 'available' }✅ Automatic progression completed { oldStatus: 'healthy', newStatus: 'available' }
Using curl?
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "healthy"}'
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "healthy"}'
Test Invalid Transitions
Try to skip a step in Workbench:
The orchestrator rejects it:
⚠️ Transition rejected {currentStatus: 'in_quarantine',requestedStatus: 'available',reason: 'Invalid transition: cannot change from in_quarantine to available'}
⚠️ Transition rejected {currentStatus: 'in_quarantine',requestedStatus: 'available',reason: 'Invalid transition: cannot change from in_quarantine to available'}
Using curl?
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "available"}'
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "available"}'
Test the Illness Workflow
Mark a pet as ill in Workbench:
Watch the automatic treatment start:
✅ Lifecycle transition completed { oldStatus: 'healthy', newStatus: 'ill' }🤖 Processing automatic progression { currentStatus: 'ill', nextStatus: 'under_treatment' }✅ Automatic progression completed { oldStatus: 'ill', newStatus: 'under_treatment' }
✅ Lifecycle transition completed { oldStatus: 'healthy', newStatus: 'ill' }🤖 Processing automatic progression { currentStatus: 'ill', nextStatus: 'under_treatment' }✅ Automatic progression completed { oldStatus: 'ill', newStatus: 'under_treatment' }
Using curl?
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "ill"}'
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "ill"}'
Then mark the pet as recovered in Workbench:
Watch the chained automatic progressions:
✅ Lifecycle transition completed { oldStatus: 'under_treatment', newStatus: 'recovered' }🤖 Processing automatic progression { currentStatus: 'recovered', nextStatus: 'healthy' }✅ Automatic progression completed { oldStatus: 'recovered', newStatus: 'healthy' }🤖 Processing automatic progression { currentStatus: 'healthy', nextStatus: 'available' }✅ Automatic progression completed { oldStatus: 'healthy', newStatus: 'available' }
✅ Lifecycle transition completed { oldStatus: 'under_treatment', newStatus: 'recovered' }🤖 Processing automatic progression { currentStatus: 'recovered', nextStatus: 'healthy' }✅ Automatic progression completed { oldStatus: 'recovered', newStatus: 'healthy' }🤖 Processing automatic progression { currentStatus: 'healthy', nextStatus: 'available' }✅ Automatic progression completed { oldStatus: 'healthy', newStatus: 'available' }
Using curl?
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "recovered"}'
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "recovered"}'
Monitoring Your Orchestrator
Use the Workbench to visualize the entire flow:
Tracing
See how events flow through your system:
Each trace shows:
The initial API call
Background job processing
Orchestrator transitions
Automatic progressions
Total time for each step
Logs
Filter by pet ID to see the complete lifecycle:
The logs tell the story of each pet's journey through your shelter.
🎉Congratulations!You've built a complete workflow orchestrator that manages complex business logic while keeping your code clean and maintainable.
What's Next?
Your pet shelter now has a complete backend system with workflow orchestration! But what about decisions that aren't black and white? Should this pet's symptoms require treatment?
In the next guide, we'll addAgentic Workflowsthat make intelligent decisions within your workflows:
Health Review Agentic Step- Analyzes symptoms and decides if treatment is needed
Adoption Review Agentic Step- Assesses if pets are ready for adoption
AI Profile Enrichment- Automatically generates engaging pet profiles
Agentic Decision Making- AI that chooses which workflow path to take
Let's continue building by adding intelligent decision-making to your workflows.
Background Jobs
Learn how to create async background jobs and scheduled tasks with Motia
Agentic Workflows
Learn how to build intelligent agentic workflows that make decisions and automate workflows with Motia
On this page



===== https://www.motia.dev/docs/getting-started/build-your-first-motia-app/ai-agents =====

Agentic Workflows
Learn how to build intelligent agentic workflows that make decisions and automate workflows with Motia
What You'll Build
An intelligent pet management system with agentic workflows that automate decisions and enrich data:
AI Profile Enrichment- Automatically generates detailed pet profiles using AI
Health Review Agentic Step- Makes intelligent health decisions based on symptoms
Adoption Review Agentic Step- Assesses adoption readiness and data completeness
Orchestrator Integration- AI decisions that drive real workflow changes
Getting Started
Clone the example repository:
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutai-agents
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutai-agents
Install dependencies:
npminstall
npminstall
Set up your OpenAI API key in.env:
.env
OPENAI_API_KEY=your_api_key_here
OPENAI_API_KEY=your_api_key_here
Important!This tutorial requires an OpenAI API key. Get yours atplatform.openai.com/api-keys. Without it, the agentic workflows won't work.
Start the Workbench:
npmrundev
npmrundev
Your Workbench will be available athttp://localhost:3000.
http://localhost:3000
Project Structure
Files likefeatures.jsonandtutorial.tsxare only for the interactive tutorial and are not part of Motia's project structure.
features.json
tutorial.tsx
All code examples in this guide are available in thebuild-your-first-apprepository.
You can follow this guide to learn how to build agentic workflows with Motia step by step, or you can clone the repository and dive into our Interactive Tutorial to learn by doing directly in the Workbench.
Understanding Agentic Workflows
You've built APIs, background jobs, and workflows that orchestrate your pet shelter. But what about decisions that aren't black and white? Should this pet's symptoms require treatment? Is this profile ready for the adoption page?
That's where agentic workflows come in. They're smart assistants that make judgment calls based on context - the kind of decisions that would normally need a human to review every single case.
In our pet shelter, we use two flavors:
Content generatorswrite engaging pet profiles automatically
Decision makersevaluate health symptoms and choose whether treatment is needed
Data reviewersassess if adoption information is complete
The difference from traditional code? Instead of writing hundreds of if-else rules for every possible symptom combination, you describe what matters to the AI. It reads the context and makes an informed call.
When a pet arrives with "coughing, lethargy, loss of appetite" - the AI evaluates these symptoms together and decides if treatment is needed. No hardcoded rules. Just intelligent analysis of the situation.
Creating Your First Agentic Step
Let's start with a content generation agentic step that automatically enriches pet profiles when they're created.
Step 1: Set Up Pet Creation to Emit Events
First, update your pet creation endpoint to emit events that will trigger the agentic step.
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constcreatePetSchema=z.object({name: z.string().min(1,'Name is required').trim(),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0,'Age must be a positive number')})exportconstconfig:ApiRouteConfig={type:'api',name:'TsCreatePet',path:'/ts/pets',method:'POST',emits: ['ts.pet.created','ts.feeding.reminder.enqueued'],flows: ['TsPetManagement']}exportconsthandler:Handlers['TsCreatePet']=async(req, {emit,logger})=>{try{constvalidatedData=createPetSchema.parse(req.body)constpet=TSStore.create({name: validatedData.name,species: validatedData.species,ageMonths: validatedData.ageMonths})if(logger) {logger.info('🐾 Pet created', { petId: pet.id, name: pet.name, species: pet.species, status: pet.status })}if(emit) {await(emitasany)({topic:'ts.pet.created',data: { petId: pet.id, event:'pet.created', name: pet.name, species: validatedData.species }})await(emitasany)({topic:'ts.feeding.reminder.enqueued',data: { petId: pet.id, enqueuedAt: Date.now() }})}return{ status:201, body: pet }}catch(error) {if(errorinstanceofz.ZodError) {return{status:400,body: {message:'Validation error',errors: error.errors}}}return{status:500,body: { message:'Internal server error'}}}}
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constcreatePetSchema=z.object({name: z.string().min(1,'Name is required').trim(),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0,'Age must be a positive number')})exportconstconfig:ApiRouteConfig={type:'api',name:'TsCreatePet',path:'/ts/pets',method:'POST',emits: ['ts.pet.created','ts.feeding.reminder.enqueued'],flows: ['TsPetManagement']}exportconsthandler:Handlers['TsCreatePet']=async(req, {emit,logger})=>{try{constvalidatedData=createPetSchema.parse(req.body)constpet=TSStore.create({name: validatedData.name,species: validatedData.species,ageMonths: validatedData.ageMonths})if(logger) {logger.info('🐾 Pet created', { petId: pet.id, name: pet.name, species: pet.species, status: pet.status })}if(emit) {await(emitasany)({topic:'ts.pet.created',data: { petId: pet.id, event:'pet.created', name: pet.name, species: validatedData.species }})await(emitasany)({topic:'ts.feeding.reminder.enqueued',data: { petId: pet.id, enqueuedAt: Date.now() }})}return{ status:201, body: pet }}catch(error) {if(errorinstanceofz.ZodError) {return{status:400,body: {message:'Validation error',errors: error.errors}}}return{status:500,body: { message:'Internal server error'}}}}
The API endpoint now emits an event after creating a pet. The response returns immediately while the agentic step processes asynchronously in the background.
Step 2: Create the AI Profile Enrichment Agentic Step
Now let's create the agentic step that listens for new pets and enriches their profiles with AI-generated content.
View on GitHub:
TypeScript
Python
JavaScript
// steps/typescript/ai-profile-enrichment.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore, PetProfile }from'./ts-store';exportconstconfig={type:'event',name:'TsAiProfileEnrichment',description:'Agentic step that enriches pet profiles using OpenAI',subscribes: ['ts.pet.created'],emits: [],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsAiProfileEnrichment']=async(input, {logger})=>{const{petId,name,species}=input;if(logger) {logger.info('🤖 AI Profile Enrichment started', { petId, name, species });}try{constapiKey=process.env.OPENAI_API_KEY;if(!apiKey) {thrownewError('OPENAI_API_KEY environment variable is not set');}constprompt=`Generate a pet profile for adoption purposes. Pet details:- Name: ${name}- Species: ${species}Please provide a JSON response with these fields:- bio: A warm, engaging 2-3 sentence description that would appeal to potential adopters- breedGuess: Your best guess at the breed or breed mix (be specific but realistic)- temperamentTags: An array of 3-5 personality traits (e.g., "friendly", "energetic", "calm")- adopterHints: Practical advice for potential adopters (family type, living situation, care needs)Keep it positive, realistic, and adoption-focused.`;constresponse=awaitfetch('https://api.openai.com/v1/chat/completions', {method:'POST',headers: {'Authorization':`Bearer ${apiKey}`,'Content-Type':'application/json',},body:JSON.stringify({model:'gpt-3.5-turbo',messages: [{role:'system',content:'You are a pet adoption specialist who creates compelling, accurate pet profiles. Always respond with valid JSON only.'},{role:'user',content: prompt}],max_tokens:500,temperature:0.7,}),});if(!response.ok) {thrownewError(`OpenAI API error: ${response.status} ${response.statusText}`);}constdata=awaitresponse.json();constaiResponse=data.choices[0]?.message?.content;if(!aiResponse) {thrownewError('No response from OpenAI API');}letprofile:PetProfile;try{profile=JSON.parse(aiResponse);}catch(parseError) {profile={bio:`${name} is a wonderful ${species} looking for a loving home. This pet has a unique personality and would make a great companion.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','loving','loyal'],adopterHints:`${name} would do well in a caring home with patience and love.`};if(logger) {logger.warn('⚠️ AI response parsing failed, using fallback profile', { petId, parseError: parseErrorinstanceofError?parseError.message:String(parseError) });}}constupdatedPet=TSStore.updateProfile(petId, profile);if(!updatedPet) {thrownewError(`Pet not found: ${petId}`);}if(logger) {logger.info('✅ AI Profile Enrichment completed', {petId,profile: {bio: profile.bio.substring(0,50)+'...',breedGuess: profile.breedGuess,temperamentTags: profile.temperamentTags,adopterHints: profile.adopterHints.substring(0,50)+'...'}});}}catch(error:any) {if(logger) {logger.error('❌ AI Profile Enrichment failed', {petId,error: error.message});}constfallbackProfile:PetProfile={bio:`${name} is a lovely ${species} with a unique personality, ready to find their forever home.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','adaptable'],adopterHints:`${name} is looking for a patient and loving family.`};TSStore.updateProfile(petId, fallbackProfile);}};
// steps/typescript/ai-profile-enrichment.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore, PetProfile }from'./ts-store';exportconstconfig={type:'event',name:'TsAiProfileEnrichment',description:'Agentic step that enriches pet profiles using OpenAI',subscribes: ['ts.pet.created'],emits: [],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsAiProfileEnrichment']=async(input, {logger})=>{const{petId,name,species}=input;if(logger) {logger.info('🤖 AI Profile Enrichment started', { petId, name, species });}try{constapiKey=process.env.OPENAI_API_KEY;if(!apiKey) {thrownewError('OPENAI_API_KEY environment variable is not set');}constprompt=`Generate a pet profile for adoption purposes. Pet details:- Name: ${name}- Species: ${species}Please provide a JSON response with these fields:- bio: A warm, engaging 2-3 sentence description that would appeal to potential adopters- breedGuess: Your best guess at the breed or breed mix (be specific but realistic)- temperamentTags: An array of 3-5 personality traits (e.g., "friendly", "energetic", "calm")- adopterHints: Practical advice for potential adopters (family type, living situation, care needs)Keep it positive, realistic, and adoption-focused.`;constresponse=awaitfetch('https://api.openai.com/v1/chat/completions', {method:'POST',headers: {'Authorization':`Bearer ${apiKey}`,'Content-Type':'application/json',},body:JSON.stringify({model:'gpt-3.5-turbo',messages: [{role:'system',content:'You are a pet adoption specialist who creates compelling, accurate pet profiles. Always respond with valid JSON only.'},{role:'user',content: prompt}],max_tokens:500,temperature:0.7,}),});if(!response.ok) {thrownewError(`OpenAI API error: ${response.status} ${response.statusText}`);}constdata=awaitresponse.json();constaiResponse=data.choices[0]?.message?.content;if(!aiResponse) {thrownewError('No response from OpenAI API');}letprofile:PetProfile;try{profile=JSON.parse(aiResponse);}catch(parseError) {profile={bio:`${name} is a wonderful ${species} looking for a loving home. This pet has a unique personality and would make a great companion.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','loving','loyal'],adopterHints:`${name} would do well in a caring home with patience and love.`};if(logger) {logger.warn('⚠️ AI response parsing failed, using fallback profile', { petId, parseError: parseErrorinstanceofError?parseError.message:String(parseError) });}}constupdatedPet=TSStore.updateProfile(petId, profile);if(!updatedPet) {thrownewError(`Pet not found: ${petId}`);}if(logger) {logger.info('✅ AI Profile Enrichment completed', {petId,profile: {bio: profile.bio.substring(0,50)+'...',breedGuess: profile.breedGuess,temperamentTags: profile.temperamentTags,adopterHints: profile.adopterHints.substring(0,50)+'...'}});}}catch(error:any) {if(logger) {logger.error('❌ AI Profile Enrichment failed', {petId,error: error.message});}constfallbackProfile:PetProfile={bio:`${name} is a lovely ${species} with a unique personality, ready to find their forever home.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','adaptable'],adopterHints:`${name} is looking for a patient and loving family.`};TSStore.updateProfile(petId, fallbackProfile);}};
How This Agentic Step Works
This is acontent generation agentic step- it enriches data without making workflow decisions:
Subscribestopet.createdevents
pet.created
Calls OpenAIwith a carefully crafted prompt
Parses the responseinto structured data
Updates the petwith AI-generated content
Has a fallbackif the AI call fails
The key is the prompt engineering - we tell the AI exactly what fields we need and what tone to use. The AI returns JSON that we can parse and store directly.
Testing Your Agentic Step
The best way to test your agentic step is throughWorkbench. It lets you create pets, watch the AI enrichment happen in real-time, and see all the logs in one place.
Create a Pet
Open Workbench and test the CreatePet endpoint. The AI will automatically start enriching the profile in the background.
Prefer using curl?
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
Check the logs in Workbench to see the agentic step in action:
You'll see:
"Pet created" log from the API endpoint
"AI Profile Enrichment started" log
"AI Profile Enrichment completed" with generated content
View the Enriched Profile
Fetch the pet in Workbench to see the AI-generated profile, or use curl:
Using curl?
curlhttp://localhost:3000/ts/pets/1
curlhttp://localhost:3000/ts/pets/1
You'll get back something like:
Building a Decision-Making Agentic Step
Now let's create an agentic step that doesn't just generate content - it makes decisions that control the workflow. This is calledagentic routing.
The Health Review Agentic Step
This agentic step analyzes pet symptoms and decides if treatment is needed. Instead of you writing complex if-else logic, the AI evaluates the context and chooses the appropriate action.
View on GitHub:
TypeScript
Python
JavaScript
// steps/typescript/health-review-agent.step.tsimport{ ApiRouteConfig, Handlers }from'motia';import{ TSStore }from'./ts-store';import{HEALTH_REVIEW_EMITS,buildAgentContext,callAgentDecision,getAgentArtifacts}from'./agent-decision-framework';exportconstconfig:ApiRouteConfig={type:'api',name:'TsHealthReviewAgent',path:'/ts/pets/:id/health-review',method:'POST',emits: ['ts.health.treatment_required','ts.health.no_treatment_needed'],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsHealthReviewAgent']=async(req, {emit,logger})=>{constpetId=req.pathParams?.id;if(!petId) {return{ status:400, body: { message:'Pet ID is required'} };}constpet=TSStore.get(petId);if(!pet) {return{ status:404, body: { message:'Pet not found'} };}if(logger) {logger.info('🏥 Health Review Agent triggered', {petId,currentStatus: pet.status,symptoms: pet.symptoms||[]});}if(!['healthy','in_quarantine','available'].includes(pet.status)) {return{status:400,body: {message:'Health review can only be performed on healthy, quarantined, or available pets',currentStatus: pet.status}};}constagentContext=buildAgentContext(pet);constrecentArtifacts=getAgentArtifacts(petId).filter(a=>a.agentType==='health-review'&&a.success&&a.inputs.currentStatus===pet.status&&(Date.now()-a.timestamp)<60000);if(recentArtifacts.length>0) {constrecent=recentArtifacts[recentArtifacts.length-1];if(logger) {logger.info('🔄 Idempotent health review - returning cached decision', {petId,chosenEmit: recent.parsedDecision.chosenEmit,timestamp: recent.timestamp});}return{status:200,body: {message:'Health review completed (cached)',petId,agentDecision: recent.parsedDecision,artifact: {timestamp: recent.timestamp,success: recent.success}}};}try{if(logger) {logger.info('🔍 Starting agent decision call', { petId, agentContext });}constartifact=awaitcallAgentDecision('health-review',agentContext,HEALTH_REVIEW_EMITS,logger);if(logger) {logger.info('✅ Agent decision call completed', { petId, success: artifact.success });}if(!artifact.success) {if(logger) {logger.warn('⚠️ Agent decision failed, but returning error response', {petId,error: artifact.error});}return{status:500,body: {message:'Agent decision failed',error: artifact.error,petId,suggestion:'Check OpenAI API key and try again'}};}constchosenEmitDef=HEALTH_REVIEW_EMITS.find(e=>e.id===artifact.parsedDecision.chosenEmit);if(!chosenEmitDef) {return{status:500,body: {message:'Invalid emit chosen by agent',chosenEmit: artifact.parsedDecision.chosenEmit}};}if(emit) {(emitasany)({topic: chosenEmitDef.topicas'ts.health.treatment_required'|'ts.health.no_treatment_needed',data: {petId,event: chosenEmitDef.id.replace('emit.',''),agentDecision: artifact.parsedDecision,timestamp: artifact.timestamp,context: agentContext}});if(logger) {logger.info('✅ Health review emit fired', {petId,chosenEmit: artifact.parsedDecision.chosenEmit,topic: chosenEmitDef.topic,rationale: artifact.parsedDecision.rationale});}}return{status:200,body: {message:'Health review completed',petId,agentDecision: artifact.parsedDecision,emitFired: chosenEmitDef.topic,artifact: {timestamp: artifact.timestamp,success: artifact.success,availableEmits: artifact.availableEmits.map(e=>e.id)}}};}catch(error:any) {if(logger) {logger.error('❌ Health review agent error', {petId,error: error.message});}return{status:500,body: {message:'Health review failed',error: error.message,petId}};}};
// steps/typescript/health-review-agent.step.tsimport{ ApiRouteConfig, Handlers }from'motia';import{ TSStore }from'./ts-store';import{HEALTH_REVIEW_EMITS,buildAgentContext,callAgentDecision,getAgentArtifacts}from'./agent-decision-framework';exportconstconfig:ApiRouteConfig={type:'api',name:'TsHealthReviewAgent',path:'/ts/pets/:id/health-review',method:'POST',emits: ['ts.health.treatment_required','ts.health.no_treatment_needed'],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsHealthReviewAgent']=async(req, {emit,logger})=>{constpetId=req.pathParams?.id;if(!petId) {return{ status:400, body: { message:'Pet ID is required'} };}constpet=TSStore.get(petId);if(!pet) {return{ status:404, body: { message:'Pet not found'} };}if(logger) {logger.info('🏥 Health Review Agent triggered', {petId,currentStatus: pet.status,symptoms: pet.symptoms||[]});}if(!['healthy','in_quarantine','available'].includes(pet.status)) {return{status:400,body: {message:'Health review can only be performed on healthy, quarantined, or available pets',currentStatus: pet.status}};}constagentContext=buildAgentContext(pet);constrecentArtifacts=getAgentArtifacts(petId).filter(a=>a.agentType==='health-review'&&a.success&&a.inputs.currentStatus===pet.status&&(Date.now()-a.timestamp)<60000);if(recentArtifacts.length>0) {constrecent=recentArtifacts[recentArtifacts.length-1];if(logger) {logger.info('🔄 Idempotent health review - returning cached decision', {petId,chosenEmit: recent.parsedDecision.chosenEmit,timestamp: recent.timestamp});}return{status:200,body: {message:'Health review completed (cached)',petId,agentDecision: recent.parsedDecision,artifact: {timestamp: recent.timestamp,success: recent.success}}};}try{if(logger) {logger.info('🔍 Starting agent decision call', { petId, agentContext });}constartifact=awaitcallAgentDecision('health-review',agentContext,HEALTH_REVIEW_EMITS,logger);if(logger) {logger.info('✅ Agent decision call completed', { petId, success: artifact.success });}if(!artifact.success) {if(logger) {logger.warn('⚠️ Agent decision failed, but returning error response', {petId,error: artifact.error});}return{status:500,body: {message:'Agent decision failed',error: artifact.error,petId,suggestion:'Check OpenAI API key and try again'}};}constchosenEmitDef=HEALTH_REVIEW_EMITS.find(e=>e.id===artifact.parsedDecision.chosenEmit);if(!chosenEmitDef) {return{status:500,body: {message:'Invalid emit chosen by agent',chosenEmit: artifact.parsedDecision.chosenEmit}};}if(emit) {(emitasany)({topic: chosenEmitDef.topicas'ts.health.treatment_required'|'ts.health.no_treatment_needed',data: {petId,event: chosenEmitDef.id.replace('emit.',''),agentDecision: artifact.parsedDecision,timestamp: artifact.timestamp,context: agentContext}});if(logger) {logger.info('✅ Health review emit fired', {petId,chosenEmit: artifact.parsedDecision.chosenEmit,topic: chosenEmitDef.topic,rationale: artifact.parsedDecision.rationale});}}return{status:200,body: {message:'Health review completed',petId,agentDecision: artifact.parsedDecision,emitFired: chosenEmitDef.topic,artifact: {timestamp: artifact.timestamp,success: artifact.success,availableEmits: artifact.availableEmits.map(e=>e.id)}}};}catch(error:any) {if(logger) {logger.error('❌ Health review agent error', {petId,error: error.message});}return{status:500,body: {message:'Health review failed',error: error.message,petId}};}};
How Decision-Making Agentic Steps Work
This agentic step is fundamentally different from the enrichment agentic step:
It's an API Step- Staff trigger it explicitly when they need a decision
It defines an emits registry- Lists all possible actions the AI can choose from (inagent-decision-framework.ts/js)
agent-decision-framework.ts/js
It calls the AI with context + options- The AI evaluates and picks one
It fires the chosen emit- This emit goes to the orchestrator, changing workflow state
It uses idempotency checking- Caches recent decisions to prevent duplicate AI calls
The framework functions (buildAgentContext,callAgentDecision,getAgentArtifacts) handle the OpenAI call and ensure the AI picks from valid options.
buildAgentContext
callAgentDecision
getAgentArtifacts
Testing the Health Review Agentic Step
The best way to test decision-making agentic steps is throughWorkbench. You can create pets, trigger the health review, and watch the AI make decisions in real-time.
Create a Pet
Use Workbench to create a pet. The AI enrichment will automatically trigger.
Prefer using curl?
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Buddy","species": "dog","ageMonths": 36}'
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Buddy","species": "dog","ageMonths": 36}'
Trigger the Health Review
In Workbench, test the health review endpoint to see the AI make a decision.
Using curl?
curl-XPOSThttp://localhost:3000/ts/pets/1/health-review\-H"Content-Type: application/json"
curl-XPOSThttp://localhost:3000/ts/pets/1/health-review\-H"Content-Type: application/json"
You'll get a response like:
{"message":"Health review completed","petId":"1","agentDecision": {"chosenEmit":"emit.health.treatment_required","rationale":"The pet shows concerning symptoms including coughing, lethargy, and loss of appetite. These symptoms suggest a potential respiratory infection or illness requiring veterinary attention."},"emitFired":"ts.health.treatment_required","artifact": {"timestamp":1234567890,"success":true,"availableEmits": ["emit.health.treatment_required","emit.health.no_treatment_needed"]}}
{"message":"Health review completed","petId":"1","agentDecision": {"chosenEmit":"emit.health.treatment_required","rationale":"The pet shows concerning symptoms including coughing, lethargy, and loss of appetite. These symptoms suggest a potential respiratory infection or illness requiring veterinary attention."},"emitFired":"ts.health.treatment_required","artifact": {"timestamp":1234567890,"success":true,"availableEmits": ["emit.health.treatment_required","emit.health.no_treatment_needed"]}}
The AI evaluates the pet's data and makes a decision. The emit it fires will trigger the orchestrator to handle the appropriate state transition.
Verify the Status Change
Check the pet status in Workbench to see the AI's decision reflected in the workflow state.
Using curl?
curlhttp://localhost:3000/ts/pets/1
curlhttp://localhost:3000/ts/pets/1
The pet's status has automatically changed based on the AI's decision!
Connecting Agentic Steps to the Orchestrator
The real power comes when your agentic steps integrate with a workflow orchestrator. The orchestrator subscribes to the events emitted by agentic steps and handles the actual state transitions.
The orchestrator configuration shows it subscribes to agentic step events:
exportconstconfig={type:'event',name:'TsPetLifecycleOrchestrator',description:'Pet lifecycle state management with staff interaction points',subscribes: ['ts.feeding.reminder.completed','ts.pet.status.update.requested','ts.health.treatment_required',// From Health Review Agentic Step'ts.health.no_treatment_needed',// From Health Review Agentic Step'ts.adoption.needs_data',// From Adoption Review Agentic Step'ts.adoption.ready'// From Adoption Review Agentic Step],emits: ['ts.treatment.required','ts.adoption.ready','ts.treatment.completed'],flows: ['TsPetManagement']}// The orchestrator has transition rules that handle agentic step eventsconstTRANSITION_RULES:TransitionRule[]=[// ... other rules ...// Agentic step-driven health transitions{from: ["healthy","in_quarantine"],to:"ill",event:"health.treatment_required",description:"Agent assessment - pet requires medical treatment"},{from: ["healthy","in_quarantine"],to:"healthy",event:"health.no_treatment_needed",description:"Agent assessment - pet remains healthy"},// Agentic step-driven adoption transitions{from: ["healthy"],to:"healthy",event:"adoption.needs_data",description:"Agent assessment - pet needs additional data before adoption",flagAction: { action:'add', flag:'needs_data'}},{from: ["healthy"],to:"available",event:"adoption.ready",description:"Agent assessment - pet ready for adoption",guards: ['no_needs_data_flag']}]
exportconstconfig={type:'event',name:'TsPetLifecycleOrchestrator',description:'Pet lifecycle state management with staff interaction points',subscribes: ['ts.feeding.reminder.completed','ts.pet.status.update.requested','ts.health.treatment_required',// From Health Review Agentic Step'ts.health.no_treatment_needed',// From Health Review Agentic Step'ts.adoption.needs_data',// From Adoption Review Agentic Step'ts.adoption.ready'// From Adoption Review Agentic Step],emits: ['ts.treatment.required','ts.adoption.ready','ts.treatment.completed'],flows: ['TsPetManagement']}// The orchestrator has transition rules that handle agentic step eventsconstTRANSITION_RULES:TransitionRule[]=[// ... other rules ...// Agentic step-driven health transitions{from: ["healthy","in_quarantine"],to:"ill",event:"health.treatment_required",description:"Agent assessment - pet requires medical treatment"},{from: ["healthy","in_quarantine"],to:"healthy",event:"health.no_treatment_needed",description:"Agent assessment - pet remains healthy"},// Agentic step-driven adoption transitions{from: ["healthy"],to:"healthy",event:"adoption.needs_data",description:"Agent assessment - pet needs additional data before adoption",flagAction: { action:'add', flag:'needs_data'}},{from: ["healthy"],to:"available",event:"adoption.ready",description:"Agent assessment - pet ready for adoption",guards: ['no_needs_data_flag']}]
🎉Congratulations!You've built intelligent agentic workflows that make decisions and drive workflows. Your pet shelter now has automated intelligence that would have taken hundreds of lines of complex logic to implement manually.
What's Next?
Your pet shelter now has intelligent agentic workflows making decisions! But how do you give users real-time feedback while all this AI processing happens in the background?
In the final guide, we'll addReal-Time Streamingto provide live updates as your workflows execute:
Stream Configuration- Define stream schemas for type-safe updates
API with Streaming- Initialize streams and return immediately to clients
Background Job Streaming- Push real-time progress updates as jobs process
Agentic Step Streaming- Stream AI enrichment progress in real-time
Multi-Step Streaming- Multiple steps updating the same stream
Let's complete your system by adding real-time streaming capabilities!
Explore more examples in theMotia Examples Repository.
Workflows
Learn how to build automated workflows that manage complex business logic with Motia
Real-Time Streaming
Learn how to add real-time streaming updates to your Motia workflows
On this page



===== https://www.motia.dev/docs/getting-started/build-your-first-motia-app/streaming-agents =====

Real-Time Streaming
Learn how to add real-time streaming updates to your Motia workflows
What You'll Build
A pet management system with real-time streaming that provides live updates to clients:
Stream Configuration- Define stream schemas for type-safe updates
API with Streaming- APIs that initialize streams and return immediately
Background Job Streaming- Jobs that push real-time progress updates
Agentic Step Streaming- AI enrichment with live progress updates
Multi-Step Streaming- Multiple steps updating the same stream
Getting Started
Clone the example repository:
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutstream-ai-agents
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutstream-ai-agents
Install dependencies:
npminstall
npminstall
Set up your OpenAI API key in.env:
.env
OPENAI_API_KEY=your_api_key_here
OPENAI_API_KEY=your_api_key_here
Start the Workbench:
npmrundev
npmrundev
Your Workbench will be available athttp://localhost:3000.
http://localhost:3000
Project Structure
Files likefeatures.jsonandtutorial.tsxare only for the interactive tutorial and are not part of Motia's project structure.
features.json
tutorial.tsx
All code examples in this guide are available in thebuild-your-first-apprepository.
You can follow this guide to learn how to build real-time streaming with Motia step by step, or you can clone the repository and dive into our Interactive Tutorial to learn by doing directly in the Workbench.
Understanding Real-Time Streaming
You've built APIs that return immediately, background jobs that process asynchronously, workflows that orchestrate complex logic, and agentic workflows that make intelligent decisions. But how do you give users real-time feedback while all this async processing happens in the background?
That's wherestreamingcomes in. Motia provides streams as part of the context in any step handler - you can use them anywhere in your code. Streams use Server-Sent Events (SSE) to push live updates directly to clients as your workflow progresses.
In our pet shelter example:
The API initializes a stream and returns immediately with a stream ID
Background jobs push updates as they process (quarantine entry, health checks)
Agentic steps stream enrichment progress (bio generation, breed analysis)
Clients get live feedback throughout the entire workflow
The power is in the simplicity -streamsis available in your handler's context, just likeemit,logger, andstate. Any step can update any stream, creating a unified real-time experience without complex orchestration.
streams
emit
logger
state
Creating Your First Stream
Step 1: Define the Stream Configuration
First, define a stream configuration file. This makes the stream available in thecontext.streamsobject for all your step handlers.
context.streams
View on GitHub:
TypeScript
Python
JavaScript
import{ StreamConfig }from'motia'import{ z }from'zod'exportconstconfig:StreamConfig={/*** This will be available as context.streams.petCreation in the FlowContext*/name:'petCreation',/*** Schema defines the structure of stream updates*/schema: z.object({message: z.string()}),/*** Use default storage for the stream*/baseConfig: {storageType:'default',},}
import{ StreamConfig }from'motia'import{ z }from'zod'exportconstconfig:StreamConfig={/*** This will be available as context.streams.petCreation in the FlowContext*/name:'petCreation',/*** Schema defines the structure of stream updates*/schema: z.object({message: z.string()}),/*** Use default storage for the stream*/baseConfig: {storageType:'default',},}
How Stream Configuration Works
Stream configuration is simple:
name- Identifier for accessing the stream (e.g.,context.streams.petCreation)
context.streams.petCreation
schema- Zod schema defining what data can be pushed to the stream
baseConfig- Storage settings (default uses in-memory storage)
Once you create this configuration file, the stream is automatically available asstreams.petCreationin the context of any step handler. It's just likeemit,logger, orstate- part of the tools available in your handler.
streams.petCreation
emit
logger
state
Step 2: Initialize Streams from APIs
Now let's update the pet creation API to initialize a stream and return it immediately to the client.
View on GitHub:
TypeScript
Python
JavaScript
// steps/typescript/create-pet.step.tsimport{ ApiRouteConfig, Handlers }from'motia';import{ z }from'zod';import{ TSStore }from'./ts-store';constcreatePetSchema=z.object({name: z.string().min(1,'Name is required').trim(),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0,'Age must be a positive number'),weightKg: z.number().positive().optional(),symptoms: z.array(z.string()).optional()});exportconstconfig:ApiRouteConfig={type:'api',name:'TsCreatePet',path:'/ts/pets',method:'POST',emits: ['ts.pet.created','ts.feeding.reminder.enqueued'],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsCreatePet']=async(req, {emit,logger,streams,traceId})=>{try{constvalidatedData=createPetSchema.parse(req.body);constpet=TSStore.create({name: validatedData.name,species: validatedData.species,ageMonths: validatedData.ageMonths,weightKg: validatedData.weightKg,symptoms: validatedData.symptoms});if(logger) {logger.info('🐾 Pet created', { petId: pet.id, name: pet.name, species: pet.species, status: pet.status });}// Create & return the initial stream record (following working pattern)constresult=awaitstreams.petCreation.set(traceId,'message', {message:`Pet ${pet.name} (ID: ${pet.id}) created successfully - Species: ${pet.species}, Age: ${pet.ageMonths} months, Status: ${pet.status}`});if(emit) {awaitemit({topic:'ts.pet.created',data: { petId: pet.id, event:'pet.created', name: pet.name, species: validatedData.species, traceId }}asany);awaitemit({topic:'ts.feeding.reminder.enqueued',data: { petId: pet.id, enqueuedAt: Date.now(), traceId }}asany);}return{status:201,body: result};}catch(error) {if(errorinstanceofz.ZodError) {return{status:400,body: {message:'Validation error',errors: error.errors}};}return{status:500,body: { message:'Internal server error'}};}};
// steps/typescript/create-pet.step.tsimport{ ApiRouteConfig, Handlers }from'motia';import{ z }from'zod';import{ TSStore }from'./ts-store';constcreatePetSchema=z.object({name: z.string().min(1,'Name is required').trim(),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0,'Age must be a positive number'),weightKg: z.number().positive().optional(),symptoms: z.array(z.string()).optional()});exportconstconfig:ApiRouteConfig={type:'api',name:'TsCreatePet',path:'/ts/pets',method:'POST',emits: ['ts.pet.created','ts.feeding.reminder.enqueued'],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsCreatePet']=async(req, {emit,logger,streams,traceId})=>{try{constvalidatedData=createPetSchema.parse(req.body);constpet=TSStore.create({name: validatedData.name,species: validatedData.species,ageMonths: validatedData.ageMonths,weightKg: validatedData.weightKg,symptoms: validatedData.symptoms});if(logger) {logger.info('🐾 Pet created', { petId: pet.id, name: pet.name, species: pet.species, status: pet.status });}// Create & return the initial stream record (following working pattern)constresult=awaitstreams.petCreation.set(traceId,'message', {message:`Pet ${pet.name} (ID: ${pet.id}) created successfully - Species: ${pet.species}, Age: ${pet.ageMonths} months, Status: ${pet.status}`});if(emit) {awaitemit({topic:'ts.pet.created',data: { petId: pet.id, event:'pet.created', name: pet.name, species: validatedData.species, traceId }}asany);awaitemit({topic:'ts.feeding.reminder.enqueued',data: { petId: pet.id, enqueuedAt: Date.now(), traceId }}asany);}return{status:201,body: result};}catch(error) {if(errorinstanceofz.ZodError) {return{status:400,body: {message:'Validation error',errors: error.errors}};}return{status:500,body: { message:'Internal server error'}};}};
How API Stream Initialization Works
The key changes from a regular API:
Access streams from context-streamsis available in the FlowContext
streams
Create initial stream message-await streams.petCreation.set(traceId, 'message', data)
await streams.petCreation.set(traceId, 'message', data)
Return the stream result- Contains stream ID and initial message
Background jobs update the same stream- Using the same traceId
The API returns immediately with a stream ID. Clients can connect to this stream via SSE to receive real-time updates as background jobs process.
Step 3: Stream Updates from Background Jobs
Now let's update the feeding reminder job to push real-time updates to the stream as it processes.
View on GitHub:
TypeScript
Python
JavaScript
// steps/typescript/set-next-feeding-reminder.job.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore }from'./ts-store';exportconstconfig={type:'event',name:'TsSetNextFeedingReminder',description:'Background job that sets next feeding reminder and adds welcome notes',subscribes: ['ts.feeding.reminder.enqueued'],emits: ['ts.feeding.reminder.completed'],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsSetNextFeedingReminder']=async(input, {emit,logger,streams,traceId})=>{const{petId,enqueuedAt}=input;if(logger) {logger.info('🔄 Setting next feeding reminder', { petId, enqueuedAt });}try{// Calculate next feeding time (24 hours from now)constnextFeedingAt=Date.now()+(24*60*60*1000);// Fill in non-critical details and change status to in_quarantineconstupdates={notes:'Welcome to our pet store! We\'ll take great care of this pet.',nextFeedingAt: nextFeedingAt,status:'in_quarantine'asconst};constupdatedPet=TSStore.update(petId, updates);if(!updatedPet) {if(logger) {logger.error('❌ Failed to set feeding reminder - pet not found', { petId });}return;}if(logger) {logger.info('✅ Next feeding reminder set', {petId,notes: updatedPet.notes?.substring(0,50)+'...',nextFeedingAt:newDate(nextFeedingAt).toISOString()});}// Stream status updates using the simple patternif(streams?.petCreation&&traceId) {awaitstreams.petCreation.set(traceId,'message', {message:`Pet ${updatedPet.name} entered quarantine period`});// Check symptoms and stream appropriate updatesif(!updatedPet.symptoms||updatedPet.symptoms.length===0) {awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`Health check passed for ${updatedPet.name} - no symptoms found`});awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`${updatedPet.name} is healthy and ready for adoption! ✅`});}else{awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`Health check failed for ${updatedPet.name} - symptoms detected: ${updatedPet.symptoms.join(', ')}`});awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`${updatedPet.name} needs medical treatment ❌`});}}if(emit) {(emitasany)({topic:'ts.feeding.reminder.completed',data: {petId,event:'feeding.reminder.completed',completedAt: Date.now(),processingTimeMs: Date.now()-enqueuedAt}});}}catch(error:any) {if(logger) {logger.error('❌ Feeding reminder job error', { petId, error: error.message });}}};
// steps/typescript/set-next-feeding-reminder.job.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore }from'./ts-store';exportconstconfig={type:'event',name:'TsSetNextFeedingReminder',description:'Background job that sets next feeding reminder and adds welcome notes',subscribes: ['ts.feeding.reminder.enqueued'],emits: ['ts.feeding.reminder.completed'],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsSetNextFeedingReminder']=async(input, {emit,logger,streams,traceId})=>{const{petId,enqueuedAt}=input;if(logger) {logger.info('🔄 Setting next feeding reminder', { petId, enqueuedAt });}try{// Calculate next feeding time (24 hours from now)constnextFeedingAt=Date.now()+(24*60*60*1000);// Fill in non-critical details and change status to in_quarantineconstupdates={notes:'Welcome to our pet store! We\'ll take great care of this pet.',nextFeedingAt: nextFeedingAt,status:'in_quarantine'asconst};constupdatedPet=TSStore.update(petId, updates);if(!updatedPet) {if(logger) {logger.error('❌ Failed to set feeding reminder - pet not found', { petId });}return;}if(logger) {logger.info('✅ Next feeding reminder set', {petId,notes: updatedPet.notes?.substring(0,50)+'...',nextFeedingAt:newDate(nextFeedingAt).toISOString()});}// Stream status updates using the simple patternif(streams?.petCreation&&traceId) {awaitstreams.petCreation.set(traceId,'message', {message:`Pet ${updatedPet.name} entered quarantine period`});// Check symptoms and stream appropriate updatesif(!updatedPet.symptoms||updatedPet.symptoms.length===0) {awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`Health check passed for ${updatedPet.name} - no symptoms found`});awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`${updatedPet.name} is healthy and ready for adoption! ✅`});}else{awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`Health check failed for ${updatedPet.name} - symptoms detected: ${updatedPet.symptoms.join(', ')}`});awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`${updatedPet.name} needs medical treatment ❌`});}}if(emit) {(emitasany)({topic:'ts.feeding.reminder.completed',data: {petId,event:'feeding.reminder.completed',completedAt: Date.now(),processingTimeMs: Date.now()-enqueuedAt}});}}catch(error:any) {if(logger) {logger.error('❌ Feeding reminder job error', { petId, error: error.message });}}};
How Background Job Streaming Works
Background jobs can push multiple updates to a stream:
Access the stream-streams.petCreationis available in context
streams.petCreation
Push updates-await streams.petCreation.set(traceId, 'message', data)
await streams.petCreation.set(traceId, 'message', data)
Use the same traceId- Links updates to the original API request
Send multiple updates- Eachset()call sends immediately to connected clients
set()
The background job processes asynchronously, pushing updates at each stage. Clients connected to the stream receive these updates in real-time via SSE.
Step 4: Agentic Step Streaming
Agentic steps can also stream progress updates as they generate content. This provides live feedback during potentially long-running AI operations.
View on GitHub:
TypeScript
Python
JavaScript
// steps/typescript/ai-profile-enrichment.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore, PetProfile }from'./ts-store';exportconstconfig={type:'event',name:'TsAiProfileEnrichment',description:'Agentic step that enriches pet profiles using OpenAI',subscribes: ['ts.pet.created'],emits: [],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsAiProfileEnrichment']=async(input, {logger,streams,traceId})=>{const{petId,name,species}=input;if(logger) {logger.info('🤖 AI Profile Enrichment started', { petId, name, species });}// Stream enrichment started eventif(streams&&traceId) {await(streamsasany).petCreation.set(traceId,'enrichment_started', {message:`AI enrichment started for ${name}`}asany);}try{constapiKey=process.env.OPENAI_API_KEY;if(!apiKey) {thrownewError('OPENAI_API_KEY environment variable is not set');}constprompt=`Generate a pet profile for adoption purposes. Pet details:- Name: ${name}- Species: ${species}Please provide a JSON response with these fields:- bio: A warm, engaging 2-3 sentence description that would appeal to potential adopters- breedGuess: Your best guess at the breed or breed mix (be specific but realistic)- temperamentTags: An array of 3-5 personality traits (e.g., "friendly", "energetic", "calm")- adopterHints: Practical advice for potential adopters (family type, living situation, care needs)Keep it positive, realistic, and adoption-focused.`;constenrichmentFields=['bio','breedGuess','temperamentTags','adopterHints'];constenrichedProfile:any={};constresponse=awaitfetch('https://api.openai.com/v1/chat/completions', {method:'POST',headers: {'Authorization':`Bearer ${apiKey}`,'Content-Type':'application/json',},body:JSON.stringify({model:'gpt-3.5-turbo',messages: [{role:'system',content:'You are a pet adoption specialist who creates compelling, accurate pet profiles. Always respond with valid JSON only.'},{role:'user',content: prompt}],max_tokens:500,temperature:0.7,}),});if(!response.ok) {thrownewError(`OpenAI API error: ${response.status} ${response.statusText}`);}constdata=awaitresponse.json();constaiResponse=data.choices[0]?.message?.content;if(!aiResponse) {thrownewError('No response from OpenAI API');}letprofile:PetProfile;try{profile=JSON.parse(aiResponse);}catch(parseError) {profile={bio:`${name} is a wonderful ${species} looking for a loving home. This pet has a unique personality and would make a great companion.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','loving','loyal'],adopterHints:`${name} would do well in a caring home with patience and love.`};if(logger) {logger.warn('⚠️ AI response parsing failed, using fallback profile', { petId, parseError: parseErrorinstanceofError?parseError.message:String(parseError) });}}constupdatedPet=TSStore.updateProfile(petId, profile);if(!updatedPet) {thrownewError(`Pet not found: ${petId}`);}if(logger) {logger.info('✅ AI Profile Enrichment completed', {petId,profile: {bio: profile.bio.substring(0,50)+'...',breedGuess: profile.breedGuess,temperamentTags: profile.temperamentTags,adopterHints: profile.adopterHints.substring(0,50)+'...'}});}// Stream each field as it's processedfor(constfieldofenrichmentFields) {awaitnewPromise(resolve=>setTimeout(resolve,300));constvalue=profile[fieldaskeyofPetProfile];if(streams&&traceId) {await(streamsasany).petCreation.set(traceId,`progress_${field}`, {message:`Generated ${field} for ${name}`}asany);}}// Stream enrichment completed eventif(streams&&traceId) {await(streamsasany).petCreation.set(traceId,'completed', {message:`AI enrichment completed for ${name}`}asany);}}catch(error:any) {if(logger) {logger.error('❌ AI Profile Enrichment failed', {petId,error: error.message});}constfallbackProfile:PetProfile={bio:`${name} is a lovely ${species} with a unique personality, ready to find their forever home.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','adaptable'],adopterHints:`${name} is looking for a patient and loving family.`};TSStore.updateProfile(petId, fallbackProfile);// Stream fallback profile completionif(streams&&traceId) {await(streamsasany).petCreation.set(traceId,'completed', {message:`AI enrichment completed with fallback profile for ${name}`}asany);}}};
// steps/typescript/ai-profile-enrichment.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore, PetProfile }from'./ts-store';exportconstconfig={type:'event',name:'TsAiProfileEnrichment',description:'Agentic step that enriches pet profiles using OpenAI',subscribes: ['ts.pet.created'],emits: [],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsAiProfileEnrichment']=async(input, {logger,streams,traceId})=>{const{petId,name,species}=input;if(logger) {logger.info('🤖 AI Profile Enrichment started', { petId, name, species });}// Stream enrichment started eventif(streams&&traceId) {await(streamsasany).petCreation.set(traceId,'enrichment_started', {message:`AI enrichment started for ${name}`}asany);}try{constapiKey=process.env.OPENAI_API_KEY;if(!apiKey) {thrownewError('OPENAI_API_KEY environment variable is not set');}constprompt=`Generate a pet profile for adoption purposes. Pet details:- Name: ${name}- Species: ${species}Please provide a JSON response with these fields:- bio: A warm, engaging 2-3 sentence description that would appeal to potential adopters- breedGuess: Your best guess at the breed or breed mix (be specific but realistic)- temperamentTags: An array of 3-5 personality traits (e.g., "friendly", "energetic", "calm")- adopterHints: Practical advice for potential adopters (family type, living situation, care needs)Keep it positive, realistic, and adoption-focused.`;constenrichmentFields=['bio','breedGuess','temperamentTags','adopterHints'];constenrichedProfile:any={};constresponse=awaitfetch('https://api.openai.com/v1/chat/completions', {method:'POST',headers: {'Authorization':`Bearer ${apiKey}`,'Content-Type':'application/json',},body:JSON.stringify({model:'gpt-3.5-turbo',messages: [{role:'system',content:'You are a pet adoption specialist who creates compelling, accurate pet profiles. Always respond with valid JSON only.'},{role:'user',content: prompt}],max_tokens:500,temperature:0.7,}),});if(!response.ok) {thrownewError(`OpenAI API error: ${response.status} ${response.statusText}`);}constdata=awaitresponse.json();constaiResponse=data.choices[0]?.message?.content;if(!aiResponse) {thrownewError('No response from OpenAI API');}letprofile:PetProfile;try{profile=JSON.parse(aiResponse);}catch(parseError) {profile={bio:`${name} is a wonderful ${species} looking for a loving home. This pet has a unique personality and would make a great companion.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','loving','loyal'],adopterHints:`${name} would do well in a caring home with patience and love.`};if(logger) {logger.warn('⚠️ AI response parsing failed, using fallback profile', { petId, parseError: parseErrorinstanceofError?parseError.message:String(parseError) });}}constupdatedPet=TSStore.updateProfile(petId, profile);if(!updatedPet) {thrownewError(`Pet not found: ${petId}`);}if(logger) {logger.info('✅ AI Profile Enrichment completed', {petId,profile: {bio: profile.bio.substring(0,50)+'...',breedGuess: profile.breedGuess,temperamentTags: profile.temperamentTags,adopterHints: profile.adopterHints.substring(0,50)+'...'}});}// Stream each field as it's processedfor(constfieldofenrichmentFields) {awaitnewPromise(resolve=>setTimeout(resolve,300));constvalue=profile[fieldaskeyofPetProfile];if(streams&&traceId) {await(streamsasany).petCreation.set(traceId,`progress_${field}`, {message:`Generated ${field} for ${name}`}asany);}}// Stream enrichment completed eventif(streams&&traceId) {await(streamsasany).petCreation.set(traceId,'completed', {message:`AI enrichment completed for ${name}`}asany);}}catch(error:any) {if(logger) {logger.error('❌ AI Profile Enrichment failed', {petId,error: error.message});}constfallbackProfile:PetProfile={bio:`${name} is a lovely ${species} with a unique personality, ready to find their forever home.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','adaptable'],adopterHints:`${name} is looking for a patient and loving family.`};TSStore.updateProfile(petId, fallbackProfile);// Stream fallback profile completionif(streams&&traceId) {await(streamsasany).petCreation.set(traceId,'completed', {message:`AI enrichment completed with fallback profile for ${name}`}asany);}}};
How Agentic Step Streaming Works
Agentic steps stream progress as they work:
Stream start notification- Let users know AI processing has begun
Progress updates- Stream each stage of generation (bio, breed, temperament, etc.)
Stream completion- Notify when AI processing is done
Error streaming- Stream errors gracefully with fallback messages
This transforms a potentially slow AI operation into an engaging real-time experience.
Testing Streaming in Action
The best way to test streams is throughWorkbench.
Test 1: Create a Pet with Streaming
Open Workbench and navigate to the Endpoints section, then test the Pet Creation endpoint:
Prefer using curl?
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Max","species": "dog","ageMonths": 24,"symptoms": ["coughing"]}'
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Max","species": "dog","ageMonths": 24,"symptoms": ["coughing"]}'
You'll get an immediate response with the stream result. The API returns right away while background jobs process asynchronously.
Test 2: Monitor Stream Updates in Workbench
After creating a pet, check the Tracing view in Workbench:
Automatically switched to theTracingtab so you can see the stream updates in real-time
Click on the most recent trace
Watch the timeline as steps execute
See stream updates appear in real-time in the timeline
You'll observe:
Pet creation completes immediately
Feeding reminder job streams quarantine updates
AI enrichment streams progress updates
All updates visible in the trace timeline
Test 3: Create Pet with Symptoms
Test the conditional streaming logic by creating a pet with symptoms:
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Luna","species": "cat","ageMonths": 18,"symptoms": ["sneezing", "watery eyes"]}'
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Luna","species": "cat","ageMonths": 18,"symptoms": ["sneezing", "watery eyes"]}'
Watch the logs to see different stream messages based on the symptoms detected.
Test 4: Create Pet Without Symptoms
Compare the streaming behavior with a healthy pet:
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Buddy","species": "dog","ageMonths": 12}'
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Buddy","species": "dog","ageMonths": 12}'
The stream will show health check passed messages instead of treatment needed messages.
Observing Stream Updates
Watch the Workbench console logs to see the real-time stream updates as they're pushed:
🐾 Pet created { petId: '1', name: 'Max', species: 'dog', status: 'new' }📋 Setting next feeding reminder { petId: '1' }🤖 AI Profile Enrichment started { petId: '1', name: 'Max' }✅ Next feeding reminder set { petId: '1' }✅ AI Profile Enrichment completed { petId: '1' }
🐾 Pet created { petId: '1', name: 'Max', species: 'dog', status: 'new' }📋 Setting next feeding reminder { petId: '1' }🤖 AI Profile Enrichment started { petId: '1', name: 'Max' }✅ Next feeding reminder set { petId: '1' }✅ AI Profile Enrichment completed { petId: '1' }
Each emoji-prefixed log corresponds to a stream update being pushed to connected clients.
🎉Congratulations!You've built a complete real-time streaming system with Motia. Your pet management system now provides live feedback to users while complex workflows execute in the background.
What's Next?
You've now mastered the complete Motia stack:
API Endpoints- Build RESTful APIs with validation
Background Jobs- Process async tasks efficiently
Workflows- Orchestrate complex business logic
Agentic Workflows- Make intelligent decisions with AI
Real-Time Streaming- Provide live updates using streams in any step handler
This is thecomplete progressionfrom simple APIs to intelligent, real-time systems!
Key Takeaway:Streams are just another tool in your step handler's context - use them wherever you need real-time updates!
Here are some ideas to extend your streaming implementation:
Add stream analytics- Track how many clients are connected, message delivery rates
Implement stream persistence- Use Redis adapter for stream storage across restarts
Create stream multiplexing- Multiple streams per workflow for different update types
Build progress bars- Use structured progress data (0-100%) instead of just messages
Add stream authentication- Ensure only authorized clients can access streams
Explore more examples in theMotia Examples Repository.
Agentic Workflows
Learn how to build intelligent agentic workflows that make decisions and automate workflows with Motia
Overview
One primitive, any language, event-driven by default - that's Motia
On this page



===== https://www.motia.dev/docs/concepts/overview =====

Overview
One primitive, any language, event-driven by default - that's Motia
Motia is a backend framework built around a single core primitive:everything is a Step.
Want an API? That's a Step.Need a background job? That's a Step.Scheduled task? Also a Step.
Write each Step in whatever language makes sense - TypeScript, Python, or JavaScript. They all run together, share the same state, and talk through events.
How It Works
Every Step is just a file with two parts:
1. Config→ When and how it runs2. Handler→ What it does
import{ ApiRouteConfig, Handlers }from'motia'// Config - when it runsexportconstconfig:ApiRouteConfig={name:'MyStep',type:'api',path:'/endpoint',method:'POST',emits: ['task.done']}// Handler - what it doesexportconsthandler:Handlers['MyStep']=async(req, {emit,logger})=>{logger.info('Processing request')awaitemit({topic:'task.done',data: { result:'success'}})return{ status:200, body: { success:true} }}
import{ ApiRouteConfig, Handlers }from'motia'// Config - when it runsexportconstconfig:ApiRouteConfig={name:'MyStep',type:'api',path:'/endpoint',method:'POST',emits: ['task.done']}// Handler - what it doesexportconsthandler:Handlers['MyStep']=async(req, {emit,logger})=>{logger.info('Processing request')awaitemit({topic:'task.done',data: { result:'success'}})return{ status:200, body: { success:true} }}
👉 Drop this file in yoursteps/folder and Motia finds it automatically. No registration, no imports, no setup.
steps/
Learn more about Steps →
Event-Driven Architecture
Steps don't call each other. Theyemitandsubscribeto events.
This means:
Your API can trigger a background job without waiting for it
Steps run independently and retry on failure
You can add new Steps without touching existing ones
Everything is traceable from start to finish
Example:An API emits an event, a background Step picks it up:
// API Step emitsawaitemit({ topic:'user.created', data: { email } })// Event Step subscribes and processesconfig={type:'event',subscribes: ['user.created']}
// API Step emitsawaitemit({ topic:'user.created', data: { email } })// Event Step subscribes and processesconfig={type:'event',subscribes: ['user.created']}
That's it. No coupling, no dependencies.
Project Structure & Auto-Discovery
Motia automatically discovers Steps - no manual registration required.
Basic Structure
Thesteps/directory is the heart of your Motia application. All your workflow logic lives here, and Motia automatically discovers any file following the naming pattern.
steps/
Auto-Discovery Rules
Motia scans thesteps/directory and automatically registers files that:
steps/
✅Match naming pattern:TypeScript:.step.tsJavaScript:.step.jsPython:_step.py(note: underscore beforestep)
✅Match naming pattern:
TypeScript:.step.ts
.step.ts
JavaScript:.step.js
.step.js
Python:_step.py(note: underscore beforestep)
_step.py
step
✅Export aconfigobjectwith Step configuration
✅Export aconfigobjectwith Step configuration
config
✅Export ahandlerfunctionwith business logic
✅Export ahandlerfunctionwith business logic
handler
No imports. No registration. Just create the file and Motia finds it.
Multi-Language Support
Every Step can be in a different language. They all run in the same process and share everything.
Currently Supported:
TypeScript→.step.ts
.step.ts
Python→_step.py
_step.py
JavaScript→.step.js
.step.js
Coming Soon:
Ruby →.step.rb
.step.rb
C# →.step.cs
.step.cs
Go →.step.go
.step.go
And many more...
Example project:
All three Steps work together. TypeScript API emits an event → Python processes with ML → JavaScript sends the result.
Core Concepts
State Management
Persistent key-value storage that works across all Steps and languages.
awaitstate.set('users','user-123', { name:'John'})constuser=awaitstate.get('users','user-123')
awaitstate.set('users','user-123', { name:'John'})constuser=awaitstate.get('users','user-123')
Learn about State →
Real-Time Streams
Push live updates to connected clients (browsers, mobile apps).
awaitstreams.notifications.set('user-123','notif-1', {message:'Order shipped!',timestamp:newDate().toISOString()})
awaitstreams.notifications.set('user-123','notif-1', {message:'Order shipped!',timestamp:newDate().toISOString()})
Clients receive updates instantly.
Learn about Streams →
Context Object
Every handler gets a context object with everything you need:
logger
emit
state
streams
traceId
Development Tool - Workbench
Visual interface for testing APIs, building and debugging flows:
See your entire flow as a beautiful diagram
Test API endpoints in the browser
Watch logs in real-time
Inspect state as it changes
Learn about Workbench →
What's Next?
📦 Steps
Deep dive into Steps - the only primitive you need
🚀 Quick Start
Build your first app in 5 minutes
Real-Time Streaming
Learn how to add real-time streaming updates to your Motia workflows
Steps
One primitive to build any backend. Simple, composable, and multi-language.
On this page



===== https://www.motia.dev/docs/concepts/steps =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/workbench =====

Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
Motia Workbench
Motia Workbench is a development platform that helps you build and debug your Motia flows. It serves as your control center where you can:
Visualize flows as interactive diagrams
Test steps directly in the UI
Monitor real-time logs
Debug issues
Getting Started
Start workbench by running:
npm run dev
Running the dev command starts:
Motia Server: Backend services and API endpoints
Motia Workbench: Web interface athttp://localhost:3000
Development Mode: Auto-reloads when changes are made
Key Features
Flow Visualization
See your entire flow as an interactive diagram:
Steps appear as connected nodes
API endpoints are highlighted as entry points
Event connections show data flow
Click any step to see its details
Real-time Testing
Test your flows directly in the interface:
Send test requests to API endpoints
Monitor how events flow through steps
Visualize step sequence execution
Inspect data at each stage
Live Logs
Monitor your flow execution in real-time with structured logging and trace information.
Development Tools
Hot Reload: Changes reflect immediately in the UI
Error Handling: Detailed error messages with contextual debugging information
State Inspector: Real-time monitoring of state management
Steps
One primitive to build any backend. Simple, composable, and multi-language.
Product Showcase
Next Page
On this page



===== https://www.motia.dev/docs/product-showcase =====

Product Showcase
Explore full-scale production applications built with Motia that demonstrate the framework's capabilities in real-world scenarios.
ChessArena AI
Production-grade chess platform with real-time AI battles, move evaluation, and live leaderboards
💻 Live Applications
These are not just examples or tutorials - they are fully functional, production-ready applications that handle real user traffic and demonstrate Motia's capabilities at scale.
Production-Ready Applications
These applications demonstrate Motia's enterprise capabilities with real user traffic, production deployments, and battle-tested architectures.
🏆 Live Chess Platform
📚 Source Code →
Contribute
Have you built something amazing with Motia? We'd love to feature your production application! Pleasereach out to uswith details about your project.
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
ChessArena AI
Next Page
On this page



===== https://www.motia.dev/docs/product-showcase/chessarena-ai =====

ChessArena AI
In the world of AI development, chess serves as the perfect benchmark for intelligence and strategic thinking. But how do you measure which AI models truly "understand" chess beyond simple win/loss statistics? ChessArena.AI solves this challenge by focusing on move quality and game insight rather than just outcomes.
This comprehensive guide explores how to build a production-ready chess platform using Motia's event-driven architecture and real-time streaming capabilities. We'll cover:
Real-Time Chess Streaming: How Motia Streams enable live game updates across all connected players
Multi-Language Architecture: Combining TypeScript orchestration with Python chess engine integration
AI Model Integration: Supporting multiple LLM providers (OpenAI, Anthropic Claude, Google Gemini, xAI Grok) for chess gameplay
Move Evaluation System: Using Stockfish engine for real-time move analysis and scoring
Production Deployment: How this exact platform powers the live ChessArena.AI website
Let's build a chess platform that measures AI intelligence through gameplay quality.
🏭 Production-Grade Chess Platform
This is not a tutorial project- this is battle-tested, production-ready code that handles real traffic at scale. Every aspect has been designed for enterprise use:
🎮 Live Chess Platform: Real-time games with multiple AI models competing simultaneously
📊 Move Quality Analysis: Every move evaluated by Stockfish engine for strategic insight
⚡ Real-Time Updates: Live game state synchronization across all connected clients
🤖 Multi-AI Support: OpenAI GPT, Anthropic Claude, XAI Grok, Google Gemini integration
🏆 Dynamic Leaderboards: Real-time scoring based on move quality, not just wins
🌍 Global Scale: Production deployment on Motia Cloud with worldwide accessibility
💰 Cost Efficient: Event-driven architecture that scales efficiently
Live Proof: Powering ChessArena.AI
This isn't just a demo- this exact code powers the live chess platform atChessArena.AI!
Visit the platform and you'll see:
🏆 Live AI Leaderboardranking models by move quality
⚡ Real-Time Gameswith instant move updates and evaluations
📊 Move Analysisshowing centipawn scores and blunder detection
🎮 Multi-Model Battleswith GPT-5, Claude Opus 4, Gemini 2.5 Flash, and Grok 4 competing
That live chess platform with real-time AI battles? That's this exact implementation in production, processing thousands of moves and providing instant feedback to chess enthusiasts worldwide!
The Power of Strategic AI Evaluation
At its core, ChessArena.AI solves a fundamental challenge: how do you measure AI intelligence in chess beyond simple win/loss statistics? Traditional chess platforms focus on game outcomes, but most LLM games end in draws, making it difficult to distinguish between models.
Our Motia-powered solution revolutionizes AI chess evaluation through:
Stockfish Integration: World's strongest open-source chess engine for move analysis
Centipawn Scoring: Precise move quality measurement in hundredths of a pawn
Real-Time Streaming: Live game updates and move evaluations
Multi-LLM Support: Support for OpenAI, Anthropic, and Google AI models
Instead of focusing on who wins, we measure how well each AI model understands chess strategy and tactics.
The Anatomy of Our Chess Platform
Our application consists of specialized components handling different aspects of chess gameplay, from game creation to move evaluation. Let's explore the complete architecture.
The entry point that exposes available AI models from different providers (OpenAI, Anthropic, Google, xAI) for chess gameplay. The platform supports cutting-edge models and allows easy extension for new providers.
import{ AiModelsSchema }from'@chessarena/types/ai-models'import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ supportedModelsByProvider }from'../../services/ai/models'// Current supported models (as of 2025)exportconstsupportedModelsByProvider:AiModels={openai: ['gpt-5-2025-08-07',// Latest GPT-5'o4-mini-2025-04-16',// O4 Mini'gpt-4.1-nano-2025-04-14',// GPT-4.1 Nano'o3-mini-2025-01-31',// O3 Mini'gpt-4o-mini-2024-07-18',// GPT-4o Mini],gemini: ['gemini-2.5-flash',// Latest Gemini 2.5 Flash'gemini-2.0-flash-001',// Gemini 2.0 Flash],claude: ['claude-opus-4-1-20250805',// Claude Opus 4.1'claude-opus-4-20250514',// Claude Opus 4'claude-sonnet-4-20250514',// Claude Sonnet 4'claude-3-7-sonnet-20250219',// Claude 3.7 Sonnet'claude-3-5-sonnet-20241022',// Claude 3.5 Sonnet'claude-3-5-haiku-20241022',// Claude 3.5 Haiku],grok: ['grok-4',// Latest Grok 4'grok-3',// Grok 3],}exportconstconfig:ApiRouteConfig={type:'api',name:'AvailableModels',description:'Expose all available AI models for supported providers',path:'/chess/models',method:'GET',emits: [],flows: ['chess'],responseSchema: {200: z.object({ models:AiModelsSchema() }),404: z.object({ message: z.string() }),400: z.object({ message: z.string() }),},}exportconsthandler:Handlers['AvailableModels']=async(_, {logger})=>{logger.info('Received available models request')return{status:200,body: {models: supportedModelsByProvider,},}}
import{ AiModelsSchema }from'@chessarena/types/ai-models'import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ supportedModelsByProvider }from'../../services/ai/models'// Current supported models (as of 2025)exportconstsupportedModelsByProvider:AiModels={openai: ['gpt-5-2025-08-07',// Latest GPT-5'o4-mini-2025-04-16',// O4 Mini'gpt-4.1-nano-2025-04-14',// GPT-4.1 Nano'o3-mini-2025-01-31',// O3 Mini'gpt-4o-mini-2024-07-18',// GPT-4o Mini],gemini: ['gemini-2.5-flash',// Latest Gemini 2.5 Flash'gemini-2.0-flash-001',// Gemini 2.0 Flash],claude: ['claude-opus-4-1-20250805',// Claude Opus 4.1'claude-opus-4-20250514',// Claude Opus 4'claude-sonnet-4-20250514',// Claude Sonnet 4'claude-3-7-sonnet-20250219',// Claude 3.7 Sonnet'claude-3-5-sonnet-20241022',// Claude 3.5 Sonnet'claude-3-5-haiku-20241022',// Claude 3.5 Haiku],grok: ['grok-4',// Latest Grok 4'grok-3',// Grok 3],}exportconstconfig:ApiRouteConfig={type:'api',name:'AvailableModels',description:'Expose all available AI models for supported providers',path:'/chess/models',method:'GET',emits: [],flows: ['chess'],responseSchema: {200: z.object({ models:AiModelsSchema() }),404: z.object({ message: z.string() }),400: z.object({ message: z.string() }),},}exportconsthandler:Handlers['AvailableModels']=async(_, {logger})=>{logger.info('Received available models request')return{status:200,body: {models: supportedModelsByProvider,},}}
Extensible AI Provider System
ChessArena.AI features a plugin-based architecture that makes adding new AI providers incredibly simple. The unifiedmakePromptsystem handles all provider differences behind a clean interface.
makePrompt
Adding New AI Providers
To add a new AI provider (like Anthropic's upcoming models or other LLM providers), you only need to:
Create a provider handlerinservices/ai/your-provider.ts:
services/ai/your-provider.ts
import{ Handler }from'./types'exportconstyourProvider:Handler=async({prompt,zod,logger,model})=>{// Initialize your AI clientconstclient=newYourAIClient({ apiKey: process.env.YOUR_API_KEY})// Make the API call with structured outputconstresponse=awaitclient.chat({model: model??'your-default-model',messages: [{ role:'user', content: prompt }],responseFormat: { type:'json_schema', schema:zodToJsonSchema(zod) },})logger.info('Your provider response received', { model })returnJSON.parse(response.content)}
import{ Handler }from'./types'exportconstyourProvider:Handler=async({prompt,zod,logger,model})=>{// Initialize your AI clientconstclient=newYourAIClient({ apiKey: process.env.YOUR_API_KEY})// Make the API call with structured outputconstresponse=awaitclient.chat({model: model??'your-default-model',messages: [{ role:'user', content: prompt }],responseFormat: { type:'json_schema', schema:zodToJsonSchema(zod) },})logger.info('Your provider response received', { model })returnJSON.parse(response.content)}
Register the providerinservices/ai/make-prompt.ts:
services/ai/make-prompt.ts
import{ yourProvider }from'./your-provider'constproviders:Record<AiModelProvider,Handler>={openai,gemini,claude,grok,yourProvider,// Add your provider here}
import{ yourProvider }from'./your-provider'constproviders:Record<AiModelProvider,Handler>={openai,gemini,claude,grok,yourProvider,// Add your provider here}
Update the type definitionsintypes/ai-models.ts:
types/ai-models.ts
exportconstAiModelProviderSchema=()=>z.enum(['openai','gemini','claude','grok','yourProvider'])
exportconstAiModelProviderSchema=()=>z.enum(['openai','gemini','claude','grok','yourProvider'])
Add supported modelsinservices/ai/models.ts:
services/ai/models.ts
exportconstsupportedModelsByProvider:AiModels={// ... existing providersyourProvider: ['your-model-v1','your-model-v2-turbo','your-model-reasoning',],}
exportconstsupportedModelsByProvider:AiModels={// ... existing providersyourProvider: ['your-model-v1','your-model-v2-turbo','your-model-reasoning',],}
That's it! Your new AI provider is now fully integrated and can compete in chess battles alongside GPT, Claude, Gemini, and Grok.
Current Provider Implementations
The platform currently supports four major AI providers with their latest models:
OpenAI: GPT-5, O4 Mini, GPT-4.1 series, O3 Mini
Anthropic: Claude Opus 4.1, Claude Sonnet 4, Claude 3.7 series
Google: Gemini 2.5 Flash, Gemini 2.0 Flash
xAI: Grok 4, Grok 3
Each provider uses optimized API calls with structured JSON output and proper error handling.
Real-Time Chess Architecture
The beauty of this chess platform lies in its event-driven, real-time architecture. Here's how live chess games flow through the system:
Game Creation→ User selects AI models and creates a new game
Move Generation→ AI models generate moves using LLM APIs
Move Validation→ Chess rules validation and board state updates
Stockfish Analysis→ Real-time move evaluation and scoring
Stream Updates→ Live game state propagated to all connected clients
Leaderboard Updates→ AI model rankings updated based on move quality
No manual state management, no complex WebSocket handling, no synchronization code required!
Key Features & Benefits
🎮Real-Time Chess Gameplay
Live games with instant move updates across all connected clients - watch AI models battle in real-time.
🏆Intelligent Scoring System
Move quality evaluation using Stockfish engine with centipawn precision and blunder detection.
🤖Multi-AI Integration
Support for OpenAI GPT, Anthropic Claude, and Google Gemini models with unified API interface.
⚡Event-Driven Architecture
Scalable, maintainable system where each component handles specific chess functionality.
📊Live Leaderboards
Real-time AI model rankings based on move quality, strategic insight, and game performance.
🌐Production-Ready
Battle-tested code powering the live ChessArena.AI platform with global accessibility.
Trying It Out
Ready to build your own AI chess platform? Let's get it running.
Clone and Install
Start by getting the project locally and installing dependencies.
gitclonehttps://github.com/MotiaDev/chessarena-ai.gitcdchessarena-aipnpminstall
gitclonehttps://github.com/MotiaDev/chessarena-ai.gitcdchessarena-aipnpminstall
Install Stockfish Engine
The platform requires Stockfish for move evaluation. Choose your installation method:
Option A: Using Homebrew (macOS - Recommended)
brewinstallstockfish
brewinstallstockfish
Option B: Using the project installer
pnpminstall-stockfish<platform># Supported: linux-x86, mac-m1
pnpminstall-stockfish<platform># Supported: linux-x86, mac-m1
Option C: Manual InstallationDownload fromstockfishchess.org
Configure Environment Variables
Create a.envfile with your AI provider API keys:
.env
# Required: AI Model API KeysOPENAI_API_KEY="sk-..."ANTHROPIC_API_KEY="sk-ant-..."GOOGLE_AI_API_KEY="..."# Required: Stockfish Engine PathSTOCKFISH_BIN_PATH="/opt/homebrew/bin/stockfish"# Optional: Authentication (for user management)JWT_SECRET="your-jwt-secret"
# Required: AI Model API KeysOPENAI_API_KEY="sk-..."ANTHROPIC_API_KEY="sk-ant-..."GOOGLE_AI_API_KEY="..."# Required: Stockfish Engine PathSTOCKFISH_BIN_PATH="/opt/homebrew/bin/stockfish"# Optional: Authentication (for user management)JWT_SECRET="your-jwt-secret"
Start the Chess Platform
Launch both the API backend and React frontend:
pnpmdev
pnpmdev
This starts:
API Backend:http://localhost:3000(Motia API with chess logic)
http://localhost:3000
React Frontend:http://localhost:5173(Chess game interface)
http://localhost:5173
Create Your First AI Battle
Open the Chess Platform: Navigate tohttp://localhost:5173
http://localhost:5173
Select AI Models: Choose different models for white and black players
Start the Game: Watch AI models battle with real-time move evaluation
View Analysis: See centipawn scores, best moves, and blunder detection
Check Leaderboards: Monitor AI model performance rankings
Access Real-Time Data
Your chess games are available via the Motia streams API:
# Get all active gamescurlhttp://localhost:3000/api/streams/chessGame# Get specific game statecurlhttp://localhost:3000/api/streams/chessGame/{gameId}# Get move history with evaluationscurlhttp://localhost:3000/api/streams/chessGameMove/{gameId}# Get AI model leaderboardcurlhttp://localhost:3000/api/streams/chessLeaderboard
# Get all active gamescurlhttp://localhost:3000/api/streams/chessGame# Get specific game statecurlhttp://localhost:3000/api/streams/chessGame/{gameId}# Get move history with evaluationscurlhttp://localhost:3000/api/streams/chessGameMove/{gameId}# Get AI model leaderboardcurlhttp://localhost:3000/api/streams/chessLeaderboard
Deploy to Production
Once your chess platform is working locally, deploy it to production with Motia Cloud:
Option 1: CLI Deployment
# Deploy with version and API keymotiaclouddeploy--api-keyyour-api-key--version-name1.0.0# Deploy with environment variablesmotiaclouddeploy--api-keyyour-api-key\--version-name1.0.0\--env-file.env.production\--environment-idyour-env-id
# Deploy with version and API keymotiaclouddeploy--api-keyyour-api-key--version-name1.0.0# Deploy with environment variablesmotiaclouddeploy--api-keyyour-api-key\--version-name1.0.0\--env-file.env.production\--environment-idyour-env-id
Option 2: One-Click Web Deployment
Ensure your local project is running (pnpm dev)
pnpm dev
Go toMotia Cloud -> Import from Workbench
Select your local project port
Choose project and environment name
Upload environment variables (optional)
ClickDeployand watch the magic happen! ✨
🚀 Production Deployment Guide
Environment Variables
Configure these environment variables for production security and functionality:
# Required: AI Model API KeysOPENAI_API_KEY="sk-your-openai-key"# For GPT-5, O4 Mini, GPT-4.1 seriesANTHROPIC_API_KEY="sk-ant-your-anthropic-key"# For Claude Opus 4.1, Sonnet 4GEMINI_API_KEY="your-google-gemini-key"# For Gemini 2.5 Flash, 2.0 FlashXAI_API_KEY="your-xai-grok-key"# For Grok 4, Grok 3# Required: Stockfish Engine PathSTOCKFISH_BIN_PATH="/opt/homebrew/bin/stockfish"# Optional: Authentication for user managementJWT_SECRET="your-secure-jwt-secret"# Optional: Database configuration for user dataDATABASE_URL="postgresql://user:password@host:port/database"
# Required: AI Model API KeysOPENAI_API_KEY="sk-your-openai-key"# For GPT-5, O4 Mini, GPT-4.1 seriesANTHROPIC_API_KEY="sk-ant-your-anthropic-key"# For Claude Opus 4.1, Sonnet 4GEMINI_API_KEY="your-google-gemini-key"# For Gemini 2.5 Flash, 2.0 FlashXAI_API_KEY="your-xai-grok-key"# For Grok 4, Grok 3# Required: Stockfish Engine PathSTOCKFISH_BIN_PATH="/opt/homebrew/bin/stockfish"# Optional: Authentication for user managementJWT_SECRET="your-secure-jwt-secret"# Optional: Database configuration for user dataDATABASE_URL="postgresql://user:password@host:port/database"
Security Best Practices
For production deployments, ensure you:
Secure API keys:# Generate a cryptographically secure JWT secretopensslrand-hex32
Secure API keys:
# Generate a cryptographically secure JWT secretopensslrand-hex32
# Generate a cryptographically secure JWT secretopensslrand-hex32
Store secrets securely: Use environment variables, never commit API keys to code
Store secrets securely: Use environment variables, never commit API keys to code
Monitor AI usage: Track API usage and costs across different model providers
Monitor AI usage: Track API usage and costs across different model providers
Enable rate limiting: Implement request limits to prevent abuse
Enable rate limiting: Implement request limits to prevent abuse
Scaling Considerations
This architecture scales automatically with your chess platform traffic:
Multiple games: Each game gets its own stream for real-time updates
High concurrency: Motia streams handle thousands of concurrent chess games
Global distribution: Deploy to multiple regions for worldwide performance
AI model optimization: Load balance across different model providers
Cost optimization: Pay only for actual usage with serverless scaling
💻 Dive into the Code
Want to explore the complete chess platform implementation? Check out the full source code with AI integration, real-time streams, and production deployment:
Live ChessArena.AI Platform
Access the complete implementation powering the live chess platform. See exactly how AI models battle with real-time evaluation and scoring!
View ChessArena.AI Code
Play Live Chess →
Conclusion: Intelligence Through Strategic Play
This ChessArena.AI platform demonstrates how to build sophisticated AI evaluation systems using event-driven architecture. By focusing on move quality rather than simple win/loss statistics, we've created a platform that truly measures AI strategic understanding.
The beauty of this approach is its extensibility:
Add new AI models: Integrate any LLM provider with the unified interface
Enhanced analysis: Implement opening book analysis, endgame evaluation
Tournament modes: Multi-round competitions with advanced scoring
Educational features: Move explanations, tactical puzzles, learning modes
Key architectural benefits:
Real-time synchronization: All clients see live game updates automatically
Scalable evaluation: Stockfish analysis runs independently of game flow
Multi-language power: TypeScript orchestration with Python chess engine integration
Production reliability: Battle-tested code handling real user traffic
This exact implementation powers the live chess platform atChessArena.AI- that real-time AI battle system with move-by-move evaluation? It's this code in action, proven at scale with thousands of chess enthusiasts worldwide.
Production Metrics:
Handles 1,000+ concurrent chess games
Processes 10,000+ moves daily with real-time evaluation
Sub-100ms move analysis and streaming updates
99.9% uptime with automatic scaling
Ready to build AI evaluation platforms that measure true intelligence? Deploy production-ready chess systems with Motia today!
Product Showcase
Previous Page
Examples
Next Page
On this page



===== https://www.motia.dev/docs/examples =====

Examples
We have curated examples to help you learn Motia, organized by complexity from basic concepts to production-ready implementations.
📚 Basic Examples
Start here to learn core Motia concepts with straightforward implementations.
Sentiment Analysis
Learn dynamic workflows with LLM-driven decision making and event routing
Multi-Language Processing
Combine TypeScript, Python, and JavaScript in unified data pipelines
🔧 Intermediate Examples
Build more complex workflows with integrations and advanced patterns.
AI Content Moderation
Human-in-the-loop content moderation with AI analysis and Slack integration
RAG PDF Analyzer
Intelligent document processing with Docling and Weaviate vector database
Trello Automation
Automated card progression system with AI-powered summaries and notifications
🏭 Production Examples
Enterprise-ready implementations handling real traffic at scale.
Uptime Monitor
Complete monitoring system with smart alerting and Discord integration
GitHub Stars Counter
Real-time stars counter with secure webhooks and live streaming
GitHub Integration
Automated issue and PR management with AI-powered classification and routing
Gmail Automation
Smart email classification, auto-responses, and AI-powered filtering with OAuth2
Finance Agent
Event-driven financial analysis with web search and real-time market data
AI Research Agent
Comprehensive web research assistant with iterative depth and parallel processing
💻 Explore the Source Code
All examples include complete, runnable source code with configuration files, setup instructions, and production-ready implementations:
Motia Examples Repository
Access complete implementations, step-by-step tutorials, and production-ready configurations for all our examples. Perfect for learning, experimentation, and building your own applications.
Repository
RAG Example →
Monitor Example →
Contribute
We welcome contributions to the examples. Please submit a PR to theexamples repository.
ChessArena AI
Previous Page
Sentiment Analysis
Dynamic Workflows: Building a Sentiment Analyzer with Motia
On this page



===== https://www.motia.dev/docs/examples/sentiment-analysis =====

Sentiment Analysis
Dynamic Workflows: Building a Sentiment Analyzer with Motia
In modern application development, workflows are rarely linear. Whether you're building a simple "prompt => response" system or a complex, multi-stage data processing pipeline, you often need your application to make decisions and route data dynamically. This is where the power of event-driven architecture shines, and where the Motia framework provides a clear path forward.
This guide explores how to build a dynamic sentiment analysis application that uses an LLM to determine how to proceed. We'll cover:
The Motia Philosophy: Howstepsas a core primitive simplify complex architectures.
steps
Building the Workflow: A step-by-step guide to creating the four key components of our application.
Visualizing the Flow: How events chain together to create a cohesive, dynamic system.
Hands-On with the API: How to run and test your new sentiment analyzer.
Let's dive in.
A Step at a Time
At the heart of the Motia framework is a simple but powerful idea: thestep. A step is a self-contained, independent unit of logic that listens for an event, performs a task, and, optionally, emits a new event. This concept is the core primitive that allows you to break down even the most complex architectures into a series of simple, manageable components.
step
Instead of a monolithic application where business logic is tightly coupled, Motia encourages a decoupled, event-driven approach. This has several key advantages:
Clarity: Each step has a single responsibility, making the application easier to understand and reason about.
Scalability: Steps can be scaled independently, so you can allocate resources where they're needed most.
Extensibility: Adding new functionality is as simple as creating a new step and subscribing it to an existing event.
Resilience: The decoupled nature of steps means that a failure in one part of the system doesn't necessarily bring down the entire application.
In this project, we'll see this philosophy in action as we build a sentiment analyzer with four distinct steps, each with its own clear purpose.
The Anatomy of Our Sentiment Analyzer
Our application will be composed of four steps. Let's explore each one.
This is the entry point to our workflow. It's an API step that listens forPOSTrequests, validates the incoming data, and emits anopenai.analyzeSentimentRequestevent.
POST
openai.analyzeSentimentRequest
// Receives user text, emits "openai.analyzeSentimentRequest".import{ Handlers }from'motia'import{ z }from'zod'exportconstconfig={type:'api',name:'analyzeSentimentApi',description:'Receives user text and emits an event to trigger sentiment analysis.',path:'/api/analyze-sentiment',method:'POST',emits: ['openai.analyzeSentimentRequest'],bodySchema: z.object({text: z.string().min(1,'text is required'),}),flows: ['sentiment-demo'],}asconstexportconsthandler:Handlers['analyzeSentimentApi']=async(req, {emit,logger})=>{const{text}=req.bodylogger.info('[AnalyzeSentimentAPI] Received text', { text })// Emit an event to call OpenAIawaitemit({topic:'openai.analyzeSentimentRequest',data: { text },})// Return right awayreturn{status:200,body: { status:'Accepted', message:'Your text is being analyzed'},}}
// Receives user text, emits "openai.analyzeSentimentRequest".import{ Handlers }from'motia'import{ z }from'zod'exportconstconfig={type:'api',name:'analyzeSentimentApi',description:'Receives user text and emits an event to trigger sentiment analysis.',path:'/api/analyze-sentiment',method:'POST',emits: ['openai.analyzeSentimentRequest'],bodySchema: z.object({text: z.string().min(1,'text is required'),}),flows: ['sentiment-demo'],}asconstexportconsthandler:Handlers['analyzeSentimentApi']=async(req, {emit,logger})=>{const{text}=req.bodylogger.info('[AnalyzeSentimentAPI] Received text', { text })// Emit an event to call OpenAIawaitemit({topic:'openai.analyzeSentimentRequest',data: { text },})// Return right awayreturn{status:200,body: { status:'Accepted', message:'Your text is being analyzed'},}}
Explore the Workbench
You can explore the workflow in the Workbench.
You can also read your files and watch logs, traces, debug your architecture directly in the Workbench.
Trying It Out
Ready to see it in action? Let's get the project running.
Install Dependencies
First, install the necessary npm packages.
npminstall
npminstall
Set Your Environment Variables
You'll need an OpenAI API key for this project. Export it as an environment variable.
exportOPENAI_API_KEY="sk-..."
exportOPENAI_API_KEY="sk-..."
Run the Project
Start the Motia development server.
npmrundev
npmrundev
Test the API
Now you can send requests to your API and see the workflow in action.
curl-XPOSThttp://localhost:3000/api/analyze-sentiment\-H"Content-Type: application/json"\-d'{"text":"I absolutely love this new device! It is amazing and works perfectly."}'
curl-XPOSThttp://localhost:3000/api/analyze-sentiment\-H"Content-Type: application/json"\-d'{"text":"I absolutely love this new device! It is amazing and works perfectly."}'
Check your logs, and you should see the[Positive Responder]has been triggered.
[Positive Responder]
curl-XPOSThttp://localhost:3000/api/analyze-sentiment\-H"Content-Type: application/json"\-d'{"text":"This is the worst product I have ever used. It broke after one day."}'
curl-XPOSThttp://localhost:3000/api/analyze-sentiment\-H"Content-Type: application/json"\-d'{"text":"This is the worst product I have ever used. It broke after one day."}'
This time, the[Negative Responder]will fire.
[Negative Responder]
💻 Dive into the Code
Want to explore the complete implementation? Check out the full source code and additional examples in our GitHub repository:
Explore More Examples
Get hands-on with the complete source code, configuration files, and additional examples to accelerate your learning.
View Sentiment Example
More Examples →
Conclusion: The Power of a Simple Primitive
This sentiment analysis application is a powerful demonstration of the Motia philosophy. By embracing thestepas a core primitive, we've turned a potentially complex, branching workflow into a series of simple, understandable, and scalable components.
step
This is just the beginning. From here, you can extend the application by adding new steps to handle neutral sentiment, send notifications, or store results in a database. The event-driven architecture of Motia makes it easy to add new functionality without disrupting the existing flow.
We encourage you to explore, experiment, and see for yourself how Motia can simplify your most complex backend challenges. Happy coding!
Examples
Previous Page
Multi-Language Processing
Multi-Language Data Processing: Building a Unified Pipeline with Motia
On this page



===== https://www.motia.dev/docs/examples/multi-language-data-processing =====

Multi-Language Processing
Multi-Language Data Processing: Building a Unified Pipeline with Motia
Modern backend development often requires combining the strengths of different programming languages. TypeScript for APIs, Python for data processing and AI, JavaScript for rapid prototyping. Traditional approaches involve complex microservices architectures with intricate communication patterns.
This comprehensive guide explores how to build a unified multi-language data processing pipeline using Motia'sstepprimitive. We'll cover:
Steps as Core Primitive: How steps unify different languages under a single abstraction.
Building the Pipeline: A step-by-step guide to creating a cohesive multi-language data processing workflow.
Unified Execution Model: How steps enable seamless communication between different runtime environments.
Hands-On Development: How to build, run, and observe your unified multi-language pipeline.
Let's build a production-ready data processing system where steps unify TypeScript, Python, and JavaScript into a single cohesive workflow.
The Power of Steps: A Unified Multi-Language Primitive
At its core, our data processing pipeline demonstrates howstepssolve the fundamental challenge of multi-language systems: unifying different programming languages under a single, coherent abstraction. Traditional polyglot architectures require complex inter-process communication and deployment coordination. Motia'sstepprimitive unifies everything.
Steps enable true language unification:
TypeScriptsteps: Strong typing and excellent tooling for APIs and orchestration
Pythonsteps: Rich ecosystem for data processing, ML, and scientific computing
JavaScriptsteps: Dynamic processing and rapid development
Motia's Step Primitive: The unifying abstraction that makes all languages work as a single system
Instead of managing multiple services,stepsprovide a single programming model. Whether written in TypeScript, Python, or JavaScript, every step follows the same pattern: receive data, process it, emit events. This unification is what makes multi-language development straightforward.
The Anatomy of Our Multi-Language Pipeline
Our application consists of six specialized steps, each leveraging the optimal language for its specific task. Let's explore the complete architecture.
The entry point for our multi-language workflow. This TypeScript API endpoint receives data, validates it with Zod schemas, and kicks off the processing pipeline.
import{ z }from'zod'constbodySchema=z.object({data: z.record(z.unknown()).optional(),message: z.string().optional()})// API endpoint to start the multi-language pipelineexportconstconfig={type:'api',name:'AppStarter',description:'Start the multi-language app pipeline',method:'POST',path:'/start-app',bodySchema,responseSchema: {200: z.object({message: z.string(),appId: z.number(),traceId: z.string()})},emits: ['app.started'],flows: ['data-processing']}asconstexportconsthandler=async(req:any, {logger,emit,traceId}:any)=>{logger.info('🚀 Starting multi-language app', { body: req.body, traceId })constappData={id: Date.now(),input: req.body.data||{},started_at:newDate().toISOString(),traceId}// Emit to next stepawaitemit({topic:'app.started',data: appData})logger.info('✅ App started successfully', {appId: appData.id,traceId})return{status:200,body: {message:'Multi-language app started successfully',appId: appData.id,traceId}}}
import{ z }from'zod'constbodySchema=z.object({data: z.record(z.unknown()).optional(),message: z.string().optional()})// API endpoint to start the multi-language pipelineexportconstconfig={type:'api',name:'AppStarter',description:'Start the multi-language app pipeline',method:'POST',path:'/start-app',bodySchema,responseSchema: {200: z.object({message: z.string(),appId: z.number(),traceId: z.string()})},emits: ['app.started'],flows: ['data-processing']}asconstexportconsthandler=async(req:any, {logger,emit,traceId}:any)=>{logger.info('🚀 Starting multi-language app', { body: req.body, traceId })constappData={id: Date.now(),input: req.body.data||{},started_at:newDate().toISOString(),traceId}// Emit to next stepawaitemit({topic:'app.started',data: appData})logger.info('✅ App started successfully', {appId: appData.id,traceId})return{status:200,body: {message:'Multi-language app started successfully',appId: appData.id,traceId}}}
Type Definitions
Our unified system uses shared TypeScript types to ensure type safety across the multi-language pipeline:
// types/index.tsexportinterfaceAppData{id:numberinput:Record<string,unknown>started_at:stringtraceId:string}exportinterfaceProcessedResult{original_id:numberprocessed_at:stringresult:stringconfidence:numbermodel_version:string}exportinterfacePythonResult{id:numberpython_message:stringprocessed_by:string[]processing_time:number}exportinterfaceNotificationData{id:numbermessage:stringprocessed_by:string[]sent_at:string}exportinterfaceAppSummary{appId:numberstatus:stringcompleted_at:stringsteps_executed:string[]result:string}
// types/index.tsexportinterfaceAppData{id:numberinput:Record<string,unknown>started_at:stringtraceId:string}exportinterfaceProcessedResult{original_id:numberprocessed_at:stringresult:stringconfidence:numbermodel_version:string}exportinterfacePythonResult{id:numberpython_message:stringprocessed_by:string[]processing_time:number}exportinterfaceNotificationData{id:numbermessage:stringprocessed_by:string[]sent_at:string}exportinterfaceAppSummary{appId:numberstatus:stringcompleted_at:stringsteps_executed:string[]result:string}
Explore the Workbench
The Motia Workbench provides a visual representation of your multi-language pipeline, making it easy to trace data flow between TypeScript, Python, and JavaScript steps.
You can monitor real-time execution, view logs from all languages in a unified interface, and trace the complete data flow from the TypeScript API through Python processing to JavaScript summary generation.
Event Flow Architecture
The pipeline follows a clear event-driven flow that connects all languages seamlessly:
app.started- TypeScript API → TypeScript Bridge
app.started
data.processed- TypeScript Bridge → Python Processor
data.processed
python.done- Python Processor → TypeScript Notification Handler
python.done
notification.sent- TypeScript Notification → TypeScript Finalizer
notification.sent
app.completed- TypeScript Finalizer → JavaScript Summary Generator
app.completed
Each step only needs to know the events it subscribes to and emits, creating loose coupling while maintaining strong data flow guarantees.
Key Features & Benefits
🧩Step as Universal Primitive
Every piece of logic—whether TypeScript, Python, or JavaScript—follows the same step pattern, creating true unification.
🌐Seamless Language Integration
Steps eliminate the complexity of multi-language systems by providing a unified programming model.
📊Unified Development Experience
Write, debug, and monitor all languages through a single interface and shared execution model.
⚡Hot Reload Across Languages
Edit any step in any language and see changes instantly across the entire pipeline.
🔄Event-Driven Communication
Steps communicate through events, enabling loose coupling and independent scaling.
🎯Single Deployment Model
Deploy all languages together as a cohesive system, not as separate microservices.
🐍Python Step Naming
Python steps use the_step.pysuffix convention for proper module resolution (e.g.,simple-python_step.py).
_step.py
simple-python_step.py
Trying It Out
Ready to build your first multi-language Motia application? Let's get it running.
Create Your Motia App
Start by creating a new Motia project with the interactive setup.
npxmotia@latestcreate
npxmotia@latestcreate
Navigate and Start Development
Move into your project directory and start the development server.
cdmy-app# Replace with your project namenpmrundev
cdmy-app# Replace with your project namenpmrundev
Open the Workbench
Navigate tohttp://localhost:3000to access the Workbench and run your workflow.
http://localhost:3000
Test the Multi-Language Pipeline
Send a request to your API endpoint to see the multi-language workflow in action:
curl-XPOSThttp://localhost:3000/start-app\-H"Content-Type: application/json"\-d'{"data": {"test": "value"}, "message": "Hello!"}'
curl-XPOSThttp://localhost:3000/start-app\-H"Content-Type: application/json"\-d'{"data": {"test": "value"}, "message": "Hello!"}'
Watch in the Workbench as your data flows through:
TypeScriptvalidation and event emission
TypeScriptbridge processing and forwarding
Pythondata processing with rich logging
TypeScriptnotification handling
TypeScriptfinalization and aggregation
JavaScriptsummary generation and metrics
💻 Dive into the Code
Want to explore multi-language workflows further? Check out additional examples and the complete source code:
Multi-Language Examples
Access complete multi-language implementations, configuration examples, and learn how to integrate TypeScript, Python, and JavaScript in production applications.
Explore Examples
Quick Start →
Conclusion: The Power of Unification Through Steps
This multi-language data processing pipeline demonstrates howstepsfundamentally change multi-language development. By providing a single primitive that works across TypeScript, Python, and JavaScript, we've eliminated the traditional complexity of polyglot architectures.
The step primitive enables true unification:
Universal Pattern- Every step, regardless of language, follows the same receive-process-emit pattern
Seamless Integration- Add Ruby, Go, Rust, or any language using the same step abstraction
Unified Deployment- All languages deploy together as a single, coherent system
Shared Development Model- Write, debug, and monitor everything through the same interface
Key benefits of step-based unification:
Single Mental Model- Learn the step pattern once, apply it to any language
Cohesive System- All components work together as parts of one application, not separate services
Consistent Experience- Development, debugging, and monitoring work the same way across all languages
Natural Scaling- Each step can scale independently while maintaining system coherence
Extend your pipeline with more steps:
Add specialized processing steps for different data types and business logic
Integrate machine learning workflows with Python steps for AI processing
Build real-time analytics with streaming steps for live data processing
Connect to enterprise systems through database and API integration steps
Implement scheduled processing with cron steps for batch operations
Thestep primitivemakes all extensions natural and straightforward—every new capability follows the same unified pattern.
Ready to unify your multi-language systems? Start building with steps today!
Sentiment Analysis
Dynamic Workflows: Building a Sentiment Analyzer with Motia
AI Content Moderation
Intelligent Content Moderation: Building Human-in-the-Loop Systems with Motia
On this page



===== https://www.motia.dev/docs/examples/ai-content-moderation =====

AI Content Moderation
Intelligent Content Moderation: Building Human-in-the-Loop Systems with Motia
In today's digital landscape, content moderation is crucial for maintaining safe and appropriate user experiences. Whether you're building a social platform, forum, or any user-generated content system, you need intelligent moderation that can scale with your user base while maintaining human oversight for complex decisions.
This comprehensive guide explores how to build a production-ready content moderation system using Motia's event-driven architecture. We'll cover:
AI-Powered Analysis: Using OpenAI for text toxicity detection and image safety analysis
Confidence-Based Routing: Automatically handling clear cases while flagging uncertain content for human review
Slack Integration: Creating interactive moderation workflows within existing team communication tools
Human-in-the-Loop: Seamlessly integrating human decision-making into automated processes
Let's build a content moderation system that scales intelligently.
The Power of Intelligent Content Moderation
At its core, our content moderation system solves a fundamental challenge: how do you efficiently moderate user-generated content at scale while maintaining human oversight for complex decisions? Traditional approaches often involve either fully manual processes that don't scale or fully automated systems that lack nuance.
Our Motia-powered solution combines the best of both worlds through intelligent routing:
OpenAI Integration: Advanced AI analysis for text toxicity and image safety detection
Confidence-Based Routing: Automatic handling of clear cases, human review for uncertain content
Slack Integration: Interactive moderation workflows within existing team communication tools
Motia Framework: Event-driven orchestration with built-in state management and error handling
Instead of a monolithic moderation system, we get a flexible architecture where each component can be scaled, modified, or replaced independently.
The Anatomy of Our Content Moderation System
Our application consists of six specialized steps, each handling a specific part of the moderation workflow. Let's explore the complete architecture.
The entry point for content moderation. This API endpoint receives user-generated content (text and/or images) and initiates the moderation workflow.
import{ z }from"zod";import{ ApiRouteConfig, Handlers }from"motia";constContentSubmitInputSchema=z.object({text: z.string().optional(),imageUrl: z.string().optional(),userId: z.string(),platform: z.string(),});exportconstconfig:ApiRouteConfig={type:"api",name:"ContentSubmitAPI",description:"Receives user-generated content for moderation",path:"/content/submit",method:"POST",bodySchema: ContentSubmitInputSchema,emits: ["content.submitted"],flows: ["content-moderation"],};exportconsthandler:Handlers["ContentSubmitAPI"]=async(req,{logger,emit})=>{const{text,imageUrl,userId,platform}=req.body;constsubmissionId=`sub_${Date.now()}_${Math.random().toString(36).slice(2,11)}`;logger.info(`Content submitted for moderation`, {submissionId,hasText:!!text,hasImage:!!imageUrl,userId,platform,});awaitemit({topic:"content.submitted",data: {submissionId,text,imageUrl,userId,platform,timestamp:newDate().toISOString(),},});return{status:200,body: {message:"Content submitted for moderation",submissionId,},};};
import{ z }from"zod";import{ ApiRouteConfig, Handlers }from"motia";constContentSubmitInputSchema=z.object({text: z.string().optional(),imageUrl: z.string().optional(),userId: z.string(),platform: z.string(),});exportconstconfig:ApiRouteConfig={type:"api",name:"ContentSubmitAPI",description:"Receives user-generated content for moderation",path:"/content/submit",method:"POST",bodySchema: ContentSubmitInputSchema,emits: ["content.submitted"],flows: ["content-moderation"],};exportconsthandler:Handlers["ContentSubmitAPI"]=async(req,{logger,emit})=>{const{text,imageUrl,userId,platform}=req.body;constsubmissionId=`sub_${Date.now()}_${Math.random().toString(36).slice(2,11)}`;logger.info(`Content submitted for moderation`, {submissionId,hasText:!!text,hasImage:!!imageUrl,userId,platform,});awaitemit({topic:"content.submitted",data: {submissionId,text,imageUrl,userId,platform,timestamp:newDate().toISOString(),},});return{status:200,body: {message:"Content submitted for moderation",submissionId,},};};
Explore the Workbench
The Motia Workbench provides a visual representation of your content moderation pipeline, making it easy to understand the flow and monitor moderation decisions in real-time.
You can monitor real-time content analysis, view Slack notifications, and trace the execution of each moderation decision directly in the Workbench interface. This makes development and debugging significantly easier compared to traditional monolithic moderation systems.
Human-in-the-Loop Workflow Demo
Let's see the complete human-in-the-loop process in action using a real example. We'll submit problematic content and watch it flow through the moderation pipeline.
Step 1: Submit Content for Moderation
Submit the sample content that should trigger human review:
curl-XPOSThttp://localhost:3000/content/submit\-H"Content-Type: application/json"\-d'{"text": "I hate this stupid garbage, it\'scompletetrashandmakesmewanttohurtsomeone","userId": "user456","platform": "web"}'
curl-XPOSThttp://localhost:3000/content/submit\-H"Content-Type: application/json"\-d'{"text": "I hate this stupid garbage, it\'scompletetrashandmakesmewanttohurtsomeone","userId": "user456","platform": "web"}'
Step 2: AI Analysis & Routing
The system will:
Analyze the contentusing OpenAI's GPT-4 for toxicity detection
Calculate risk scoresbased on detected harmful content
Route for human reviewsince the content contains hate speech and violence references
You'll see logs like:
Content submitted for moderation: submissionId=sub_123, hasText=true, userId=user456Starting content analysis: submissionId=sub_123, hasText=trueContent analysis completed: submissionId=sub_123, overallScore=0.87, textScore=0.87Content needs human review: submissionId=sub_123, overallScore=0.87
Content submitted for moderation: submissionId=sub_123, hasText=true, userId=user456Starting content analysis: submissionId=sub_123, hasText=trueContent analysis completed: submissionId=sub_123, overallScore=0.87, textScore=0.87Content needs human review: submissionId=sub_123, overallScore=0.87
Step 3: Slack Notification for Human Review
The system automatically sends an interactive message to your moderation team in Slack:
The Slack message includes:
Risk score: 87% confidence of harmful content
Priority level: HIGH (since score ≥ 70%)
AI analysis: Detailed breakdown of detected issues
Interactive buttons: Approve, Reject, or Escalate options
Step 4: Human Decision & Execution
When a moderator clicks a button in Slack:
Decision is recordedwith moderator attribution
Content is processedaccording to the decision
User is notifiedof the moderation outcome
Audit trail is maintainedfor compliance
The complete workflow demonstrates how AI handles the initial analysis while humans provide the final judgment for nuanced decisions.
Key Features & Benefits
🤖AI-Powered Analysis
Advanced OpenAI integration for both text toxicity detection and image safety analysis with confidence scoring.
🎯Intelligent Routing
Confidence-based decision making that automatically handles clear cases while flagging uncertain content for human review.
💬Slack Integration
Interactive moderation workflows within existing team communication tools - no custom dashboard required.
👥Human-in-the-Loop
Seamless integration of human decision-making with approve/reject/escalate buttons and contextual information.
📊Priority-Based Routing
Content is routed to different Slack channels based on risk level and urgency.
🔒Security & Compliance
Built-in signature verification, audit trails, and comprehensive logging for compliance requirements.
Getting Started
Ready to build your own intelligent content moderation system? Here's how to set it up and run it.
1. Install Dependencies
Install the necessary npm packages and set up the development environment.
npminstall
npminstall
2. Configure Environment Variables
Create a.envfile with your API keys and Slack configuration:
.env
# Required: OpenAI API key for content analysisOPENAI_API_KEY="sk-..."# Required: Slack bot configurationSLACK_BOT_TOKEN="xoxb-your-bot-token"SLACK_SIGNING_SECRET="your-signing-secret"# Required: Slack channels for different priority levelsSLACK_CHANNEL_MODERATION="C1234567890"# Normal prioritySLACK_CHANNEL_URGENT="C0987654321"# High prioritySLACK_CHANNEL_ESCALATED="C1122334455"# Escalated content
# Required: OpenAI API key for content analysisOPENAI_API_KEY="sk-..."# Required: Slack bot configurationSLACK_BOT_TOKEN="xoxb-your-bot-token"SLACK_SIGNING_SECRET="your-signing-secret"# Required: Slack channels for different priority levelsSLACK_CHANNEL_MODERATION="C1234567890"# Normal prioritySLACK_CHANNEL_URGENT="C0987654321"# High prioritySLACK_CHANNEL_ESCALATED="C1122334455"# Escalated content
3. Set Up Slack Integration
Create a Slack app with the following permissions:chat:write- Send messages to channelschannels:read- Access channel information
chat:write- Send messages to channels
chat:write
channels:read- Access channel information
channels:read
Enable Interactive Components and set webhook URL to:https://your-domain.com/slack/webhook
https://your-domain.com/slack/webhook
Install the app to your workspace
Copy the bot token and signing secret to your.envfile
.env
4. Run the Moderation System
Start the Motia development server to begin processing content.
npmrundev
npmrundev
Advanced Configuration
Adjusting Confidence Thresholds
Modify the decision thresholds in the content router step:
// In 03-content-router.step.tsif(overallScore<=0.05) {decision="approved";// Auto-approve threshold (5%)}elseif(overallScore>=0.95) {decision="rejected";// Auto-reject threshold (95%)}else{decision="review";// Human review range (5-95%)}
// In 03-content-router.step.tsif(overallScore<=0.05) {decision="approved";// Auto-approve threshold (5%)}elseif(overallScore>=0.95) {decision="rejected";// Auto-reject threshold (95%)}else{decision="review";// Human review range (5-95%)}
Custom Channel Routing
Implement custom routing logic based on content type or user behavior:
// Route based on user history or content typeconstchannel=getChannelForContent(contentType, userHistory, riskScore);
// Route based on user history or content typeconstchannel=getChannelForContent(contentType, userHistory, riskScore);
Integration with External Systems
Extend the action executor to integrate with your existing systems:
// In 06-action-executor.step.tscase"approved":awaitpublishContent(submissionId);awaitnotifyUser(userId,"Your content has been approved");break;
// In 06-action-executor.step.tscase"approved":awaitpublishContent(submissionId);awaitnotifyUser(userId,"Your content has been approved");break;
💻 Dive into the Code
Want to explore the complete content moderation implementation? Check out the full source code, including all steps, Slack integration, and production-ready configuration:
Complete Content Moderation System
Access the full implementation with AI analysis, Slack integration, and human-in-the-loop workflows.
View Content Moderation Example
More Examples →
Conclusion: Intelligent Content Moderation at Scale
This content moderation system demonstrates the power of combining AI analysis with human oversight in an event-driven architecture. By breaking down moderation into discrete, specialized components, we've created a system that's not only intelligent but also flexible and maintainable.
The human-in-the-loop approach means you can:
Scale efficiently: Automatically handle 80-90% of content while maintaining quality
Adapt quickly: Adjust thresholds and routing logic without system changes
Maintain oversight: Human moderators focus on complex cases that require judgment
Integrate seamlessly: Use existing team communication tools like Slack
Key architectural benefits:
Intelligent routing: Confidence-based decisions reduce human workload
Flexible integration: Works with any team communication platform
Audit compliance: Complete decision trails and moderator attribution
Scalable architecture: Each component can be scaled independently
From here, you can extend the system by:
Adding support for video content moderation
Implementing custom AI models for specific content types
Building analytics dashboards for moderation insights
Integrating with user management and content management systems
Adding escalation policies and moderator workflows
The event-driven architecture makes all of these extensions straightforward to implement without disrupting the existing moderation pipeline.
Ready to build content moderation that scales with your platform? Start building with Motia today!
Multi-Language Processing
Multi-Language Data Processing: Building a Unified Pipeline with Motia
RAG PDF Analyzer
Intelligent Document Processing: Building a RAG System with Motia
On this page



===== https://www.motia.dev/docs/examples/rag-docling-weaviate =====

RAG PDF Analyzer
Intelligent Document Processing: Building a RAG System with Motia
In the era of AI-powered applications, the ability to extract insights from documents is crucial. Whether you're building a knowledge base, a research assistant, or a customer support system, you need to transform static PDFs into queryable, intelligent systems. This is where Retrieval-Augmented Generation (RAG) architecture shines, and where the Motia framework provides an elegant solution.
This comprehensive guide explores how to build a production-ready RAG system that intelligently processes PDFs and answers questions about their content. We'll cover:
The RAG Architecture: Understanding how document processing, vector storage, and AI generation work together.
Motia's Event-Driven Approach: Howstepscreate a scalable, maintainable RAG pipeline.
steps
Building the Workflow: A detailed walkthrough of our polyglot processing pipeline.
Advanced Features: Real-time progress tracking, error handling, and production considerations.
Hands-On Testing: How to ingest documents and query your knowledge base.
Let's transform your documents into an intelligent AI assistant.
The Power of Intelligent Document Processing
At its core, our RAG agent solves a fundamental challenge: how do you make unstructured documents searchable and queryable by AI? Traditional approaches often involve complex, monolithic systems that are difficult to scale and maintain. Our Motia-powered solution breaks this down into discrete, event-driven steps that each handle a specific aspect of the pipeline.
The magic happens through the integration of three powerful technologies:
Docling: Advanced PDF parsing with intelligent chunking that preserves document structure
Weaviate: Cloud-native vector database with built-in OpenAI integration
Motia: Event-driven framework that orchestrates the entire pipeline
Instead of a brittle, tightly-coupled system, we get a resilient architecture where each component can be scaled, modified, or replaced independently.
The Anatomy of Our RAG Pipeline
Our application consists of seven specialized steps, each handling a specific part of the document processing and querying workflow. Let's explore the complete architecture.
The entry point for document ingestion. This API endpoint receives a folder path, kicks off the processing pipeline, and returns immediately with a tracking ID for real-time progress monitoring.
import{ Handlers }from'motia'import{ z }from'zod'import{ v4asuuidv4 }from'uuid'exportconstconfig={type:'api',name:'api-process-pdfs',description:'API endpoint to start PDF processing pipeline',path:'/api/rag/process-pdfs',method:'POST',emits: ['rag.read.pdfs'],bodySchema: z.object({folderPath: z.string().min(1,'folderPath is required'),}),flows: ['rag-workflow'],}asconstexportconsthandler:Handlers['api-process-pdfs']=async(req, {emit,logger})=>{const{folderPath}=req.bodyconststreamId=uuidv4()logger.info('Starting PDF processing pipeline', { folderPath, streamId })// Emit event to start the processing chainawaitemit({topic:'rag.read.pdfs',data: { folderPath, streamId },})return{status:200,body: {message:'PDF processing started',streamId,status:'processing'},}}
import{ Handlers }from'motia'import{ z }from'zod'import{ v4asuuidv4 }from'uuid'exportconstconfig={type:'api',name:'api-process-pdfs',description:'API endpoint to start PDF processing pipeline',path:'/api/rag/process-pdfs',method:'POST',emits: ['rag.read.pdfs'],bodySchema: z.object({folderPath: z.string().min(1,'folderPath is required'),}),flows: ['rag-workflow'],}asconstexportconsthandler:Handlers['api-process-pdfs']=async(req, {emit,logger})=>{const{folderPath}=req.bodyconststreamId=uuidv4()logger.info('Starting PDF processing pipeline', { folderPath, streamId })// Emit event to start the processing chainawaitemit({topic:'rag.read.pdfs',data: { folderPath, streamId },})return{status:200,body: {message:'PDF processing started',streamId,status:'processing'},}}
Explore the Workbench
The Motia Workbench provides a visual representation of your RAG pipeline, making it easy to understand the flow and debug any issues.
You can monitor real-time processing, view logs, and trace the execution of each step directly in the Workbench interface. This makes development and debugging significantly easier compared to traditional monolithic approaches.
Key Features & Benefits
🚀Event-Driven Architecture
Each step is independent and communicates through events, making the system highly scalable and maintainable.
🧠Intelligent Document Processing
Docling's hybrid chunking preserves document structure while creating optimal chunks for embedding.
⚡High-Performance Vector Search
Weaviate's cloud-native architecture provides fast, scalable similarity search with built-in OpenAI integration.
🔄Real-Time Progress Tracking
Monitor document processing progress with detailed logging and status updates.
🌐Polyglot Support
Seamlessly combine Python (Docling) and TypeScript (orchestration) in a single workflow.
🛡️Production-Ready
Built-in error handling, batch processing, and resource cleanup ensure reliability.
Trying It Out
Ready to build your own intelligent document assistant? Let's get the system running.
Install Dependencies
Install both Node.js and Python dependencies. The prepare script automatically sets up the Python virtual environment.
npminstall
npminstall
Set Your Environment Variables
You'll need API keys for OpenAI and Weaviate Cloud. Create a.envfile:
.env
OPENAI_API_KEY="sk-..."WEAVIATE_URL="https://your-cluster.weaviate.network"WEAVIATE_API_KEY="your-weaviate-api-key"
OPENAI_API_KEY="sk-..."WEAVIATE_URL="https://your-cluster.weaviate.network"WEAVIATE_API_KEY="your-weaviate-api-key"
Run the Project
Start the Motia development server to begin processing documents.
npmrundev
npmrundev
Process Your First Documents
Add some PDF files to thedocs/pdfs/folder, then start the ingestion pipeline:
docs/pdfs/
curl-XPOSThttp://localhost:3000/api/rag/process-pdfs\-H"Content-Type: application/json"\-d'{"folderPath":"docs/pdfs"}'
curl-XPOSThttp://localhost:3000/api/rag/process-pdfs\-H"Content-Type: application/json"\-d'{"folderPath":"docs/pdfs"}'
Watch the logs as your documents are processed through the pipeline:
PDF Reading: Files are discovered and queued
Docling Processing: Intelligent chunking with structure preservation
Weaviate Loading: Chunks are embedded and stored
Query Your Knowledge Base
Once processing is complete, you can ask questions about your documents:
curl-XPOSThttp://localhost:3000/api/rag/query\-H"Content-Type: application/json"\-d'{"query":"What are the main topics covered in these documents?","limit":3}'
curl-XPOSThttp://localhost:3000/api/rag/query\-H"Content-Type: application/json"\-d'{"query":"What are the main topics covered in these documents?","limit":3}'
curl-XPOSThttp://localhost:3000/api/rag/query\-H"Content-Type: application/json"\-d'{"query":"What methodology was used in the research?","limit":5}'
curl-XPOSThttp://localhost:3000/api/rag/query\-H"Content-Type: application/json"\-d'{"query":"What methodology was used in the research?","limit":5}'
The response includes both a generated answer and the source chunks with page numbers for verification.
Advanced Usage
Custom Chunking Strategies
Modify the Python processing step to implement custom chunking logic:
# In process-pdfs.step.pychunker=HybridChunker(tokenizer="cl100k_base",max_tokens=1024,# Larger chunks for more contextoverlap_tokens=100,# More overlap for better continuityheading_hierarchies=True,split_by_page=True# Preserve page boundaries)
# In process-pdfs.step.pychunker=HybridChunker(tokenizer="cl100k_base",max_tokens=1024,# Larger chunks for more contextoverlap_tokens=100,# More overlap for better continuityheading_hierarchies=True,split_by_page=True# Preserve page boundaries)
Batch Processing Optimization
Adjust batch sizes in the Weaviate loading step for optimal performance:
// In load-weaviate.step.tsconstBATCH_SIZE=50// Smaller batches for large documents
// In load-weaviate.step.tsconstBATCH_SIZE=50// Smaller batches for large documents
Multi-Collection Support
Extend the system to handle different document types by creating separate Weaviate collections:
constCOLLECTIONS={research:'ResearchPapers',manuals:'TechnicalManuals',reports:'BusinessReports'}
constCOLLECTIONS={research:'ResearchPapers',manuals:'TechnicalManuals',reports:'BusinessReports'}
Troubleshooting
Common Issues
ENOENT Path Errors: The system automatically handles path normalization, but ensure yourfolderPathis relative to the project root.
folderPath
Empty Answers: Check that documents were successfully processed by examining the logs. Verify your OpenAI API key is valid.
Weaviate Connection Issues: Ensure yourWEAVIATE_URLandWEAVIATE_API_KEYare correct and your cluster is running.
WEAVIATE_URL
WEAVIATE_API_KEY
Performance Tips
Document Size: For large PDFs, consider preprocessing to split them into smaller files
Batch Size: Adjust the Weaviate batch size based on your cluster's capacity
Chunking Strategy: Experiment with different chunk sizes and overlap for your specific use case
💻 Dive into the Code
Want to explore the complete RAG implementation? Check out the full source code, including all steps, configuration files, and setup instructions:
Complete RAG Implementation
Access the full source code for this RAG agent, including Python processing scripts, TypeScript orchestration, and production configuration.
View RAG Example
More Examples →
Conclusion: The Future of Document Intelligence
This RAG system demonstrates the power of combining best-in-class technologies with Motia's event-driven architecture. By breaking down complex document processing into discrete, manageable steps, we've created a system that's not only powerful but also maintainable and scalable.
The polyglot nature of the solution: Python for document processing, TypeScript for orchestration, shows how Motia enables you to use the right tool for each job without sacrificing integration or maintainability.
From here, you can extend the system by:
Adding support for other document formats (Word, PowerPoint, etc.)
Implementing document classification and routing
Adding real-time document updates and synchronization
Building a web interface for document management
Integrating with existing business systems
The event-driven architecture makes all of these extensions straightforward to implement without disrupting the existing pipeline.
Ready to transform your documents into intelligent, queryable knowledge bases? Start building with Motia today!
AI Content Moderation
Intelligent Content Moderation: Building Human-in-the-Loop Systems with Motia
Trello Automation
Build an automated card progression system for Trello boards with AI-powered summaries
On this page



===== https://www.motia.dev/docs/examples/trello-automation =====

Trello Automation
Build an automated card progression system for Trello boards with AI-powered summaries
Let's build a Trello automation system that:
Automatically progresses cards across board lists
Validates card completeness
Generates AI-powered summaries for code review
Integrates with Slack for notifications
Monitors due dates and sends overdue alerts
Board Structure
The Trello board is organized into four main lists:
New Cards: Entry point for all new cards
In Progress: Active development stage
Needs Review: Code review stage with AI summaries
Completed: Successfully reviewed and approved cards
The Steps
Visual Overview
Here's how the automation flow works:
Card Validation→ Checks for required information
Progress Tracking→ Moves cards between lists
Review Process→ Generates AI summaries and notifies reviewers
Completion Handling→ Processes approved cards
Try It Out
Prerequisites
Make sure you have:
Trello account with API access
Node.js installed
Slack workspace (for notifications)
OpenAI API key (for AI summaries)
Clone the Repository
gitclonegit@github.com:MotiaDev/motia-examples.gitcdexamples/trello-flow
gitclonegit@github.com:MotiaDev/motia-examples.gitcdexamples/trello-flow
Install Dependencies
pnpminstall
pnpminstall
Configure Environment Variables
Create a.envfile by copying the example:
.env
cp.env.example.env
cp.env.example.env
Update your.envwith the following credentials:
.env
TRELLO_API_KEY=your_trello_api_keyTRELLO_TOKEN=your_trello_tokenOPENAI_API_KEY=your_openai_api_keyOPENAI_MODEL=your_openai_modelSLACK_WEBHOOK_URL=your_slack_webhook_urlTRELLO_NEW_TASKS_LIST_ID=your_new_tasks_list_idTRELLO_IN_PROGRESS_LIST_ID=your_in_progress_list_idTRELLO_NEEDS_REVIEW_LIST_ID=your_needs_review_list_idTRELLO_COMPLETED_LIST_ID=your_completed_list_id
TRELLO_API_KEY=your_trello_api_keyTRELLO_TOKEN=your_trello_tokenOPENAI_API_KEY=your_openai_api_keyOPENAI_MODEL=your_openai_modelSLACK_WEBHOOK_URL=your_slack_webhook_urlTRELLO_NEW_TASKS_LIST_ID=your_new_tasks_list_idTRELLO_IN_PROGRESS_LIST_ID=your_in_progress_list_idTRELLO_NEEDS_REVIEW_LIST_ID=your_needs_review_list_idTRELLO_COMPLETED_LIST_ID=your_completed_list_id
Set Up Trello Board
Create a new Trello board with these lists:New TasksIn ProgressNeeds ReviewCompleted
Create a new Trello board with these lists:
New Tasks
In Progress
Needs Review
Completed
Add a custom field:Status (dropdown: Todo, In Progress, Done)
Add a custom field:
Status (dropdown: Todo, In Progress, Done)
Run the Application
pnpmdev
pnpmdev
Test the Flow
Create a new card in the "New Tasks" list
Assign a member to see it move to "In Progress"
Add an "approved" comment to see it move to "Completed"
Check Slack for notifications
For more detailed setup instructions and configuration options, check out thefull
documentation.
RAG PDF Analyzer
Intelligent Document Processing: Building a RAG System with Motia
Uptime Monitor
Real-Time Uptime Monitoring: Building a Resilient Website Monitor with Motia
On this page



===== https://www.motia.dev/docs/examples/uptime-discord-monitor =====

Uptime Monitor
Real-Time Uptime Monitoring: Building a Resilient Website Monitor with Motia
In today's modern era, website uptime is critical for business success. Whether you're monitoring a personal blog or enterprise applications, you need a reliable system that can detect outages, send alerts, and provide visibility into your site's health. Traditional monitoring solutions often involve complex infrastructure and vendor lock-in, but there's a better way.
This comprehensive guide explores how to build a production-ready uptime monitoring system using Motia's event-driven architecture. We'll cover:
Event-Driven Monitoring: How Motia'sstepscreate a scalable, maintainable monitoring pipeline.
steps
Building the Architecture: A detailed walkthrough of our five-component monitoring system.
Smart Alerting: Implementing rate limiting and status change detection to prevent spam.
Let's build a monitoring system that actually works for you.
The Power of Event-Driven Monitoring
At its core, our uptime monitoring system solves a fundamental challenge: how do you continuously monitor multiple websites without creating a brittle, monolithic application? Traditional monitoring tools often suffer from tight coupling, making them difficult to scale and customize. Our Motia-powered solution breaks this down into discrete, event-driven components that each handle a specific aspect of monitoring.
The magic happens through the integration of proven technologies and patterns:
Cron-Based Scheduling: Configurable check intervals using familiar cron expressions
Discord Webhooks: Instant notifications with rich formatting
Token Bucket Rate Limiting: Intelligent alert throttling to prevent spam
Motia Framework: Event-driven orchestration with built-in observability
Instead of a monolithic monitoring daemon, we get a resilient architecture where each component can be scaled, modified, or replaced independently.
The Anatomy of Our Monitoring System
Our application consists of five specialized steps, each handling a specific part of the monitoring workflow. Let's explore the complete architecture.
The heartbeat of our monitoring system. This cron-triggered step periodically emits check requests for all configured websites, acting as the central scheduler.
import{ configasenvConfig }from'../lib/env.js';exportconstconfig={type:'cron',name:'UptimeCronTrigger',cron: envConfig.cron,emits: ['check.requested'],flows: ['uptime-monitoring']};exportasyncfunctionhandler(context) {context.logger.info(`Starting uptime checks for ${envConfig.sites.length} sites`);context.logger.info(`Sites configured: ${JSON.stringify(envConfig.sites)}`);try{// Emit one check.requested event per configured site URLfor(consturlofenvConfig.sites) {context.logger.info(`Scheduling check for: ${url}`);awaitcontext.emit({topic:'check.requested',data: { url: url }});context.logger.info(`Successfully emitted for: ${url}`);}context.logger.info(`Successfully scheduled checks for all ${envConfig.sites.length} sites`);}catch(error) {context.logger.error('Error during cron execution:', error);throwerror;}}
import{ configasenvConfig }from'../lib/env.js';exportconstconfig={type:'cron',name:'UptimeCronTrigger',cron: envConfig.cron,emits: ['check.requested'],flows: ['uptime-monitoring']};exportasyncfunctionhandler(context) {context.logger.info(`Starting uptime checks for ${envConfig.sites.length} sites`);context.logger.info(`Sites configured: ${JSON.stringify(envConfig.sites)}`);try{// Emit one check.requested event per configured site URLfor(consturlofenvConfig.sites) {context.logger.info(`Scheduling check for: ${url}`);awaitcontext.emit({topic:'check.requested',data: { url: url }});context.logger.info(`Successfully emitted for: ${url}`);}context.logger.info(`Successfully scheduled checks for all ${envConfig.sites.length} sites`);}catch(error) {context.logger.error('Error during cron execution:', error);throwerror;}}
Explore the Workbench
The Motia Workbench provides a visual representation of your monitoring pipeline, making it easy to understand the event flow and debug issues in real-time.
You can monitor real-time status checks, view Discord alert logs, and trace the execution of each step directly in the Workbench interface. This makes development and debugging significantly easier compared to traditional monitoring solutions.
Key Features & Benefits
⚡Event-Driven Architecture
Each component is independent and communicates through events, making the system highly scalable and maintainable.
🎯Smart Status Detection
Only triggers alerts when status actually changes (UP ↔ DOWN), eliminating noise from temporary fluctuations.
🚨Intelligent Rate Limiting
Token bucket algorithm prevents alert spam during site flapping while ensuring critical alerts get through.
📊Built-in Observability
Comprehensive logging, health checks, and real-time status tracking with persistent storage.
🔧Production-Ready
Robust error handling, timeout management, and configurable check intervals ensure reliability.
🎨Rich Discord Alerts
Beautiful embedded messages with response times, error details, and status transitions.
Data Flow & Event Architecture
Event Flow
Cron Trigger→ Emitscheck.requestedevents for each configured site
check.requested
Website Checker→ Receivescheck.requested, performs HTTP check
check.requested
Status Update→ Checker emitscheck.resultwith result
check.result
Alert Processing→ Alerter receivescheck.result, detects status changes
check.result
Discord Notification→ Alerter sends webhook if status changed and rate limit allows
Status Storage→ Status is persisted for health endpoint and future comparisons
Trying It Out
Ready to build your own production-ready monitoring system? Let's get it running.
Install Dependencies
Install the necessary npm packages and set up the development environment.
npminstall
npminstall
Configure Environment Variables
Create a.envfile with your monitoring configuration. You'll need a Discord webhook URL and the sites you want to monitor.
.env
# Required: Discord webhook for alertsDISCORD_WEBHOOK="https://discord.com/api/webhooks/123456789/your-webhook-token"# Required: JSON array of URLs to monitorSITES='["https://example.com", "https://api.yourdomain.com", "https://blog.yoursite.org"]'# Optional: Check frequency (default: every minute)CHECK_INTERVAL_CRON="*/1 * * * *"# Optional: Rate limiting (default: 3 alerts per 5 minutes)ALERT_BURST="3"ALERT_WINDOW_SEC="300"
# Required: Discord webhook for alertsDISCORD_WEBHOOK="https://discord.com/api/webhooks/123456789/your-webhook-token"# Required: JSON array of URLs to monitorSITES='["https://example.com", "https://api.yourdomain.com", "https://blog.yoursite.org"]'# Optional: Check frequency (default: every minute)CHECK_INTERVAL_CRON="*/1 * * * *"# Optional: Rate limiting (default: 3 alerts per 5 minutes)ALERT_BURST="3"ALERT_WINDOW_SEC="300"
Set Up Discord Webhook
Create a Discord webhook to receive alerts:
Go to your Discord server settings
Navigate toIntegrations→Webhooks
ClickNew Webhook
Copy the webhook URL and add it to your.envfile
.env
Run the Monitoring System
Start the Motia development server to begin monitoring your websites.
npmrundev
npmrundev
Check System Health
Verify your monitoring system is working correctly:
curlhttp://localhost:3000/healthz
curlhttp://localhost:3000/healthz
You should see a response with your configured sites and their current status:
{"status":"ok","sitesConfigured":3,"lastKnown": {"https://example.com": {"url":"https://example.com","status":"UP","code":200,"responseTime":245,"checkedAt":"2024-01-15T10:30:00.000Z","error":null}},"now":"2024-01-15T10:35:00.000Z"}
{"status":"ok","sitesConfigured":3,"lastKnown": {"https://example.com": {"url":"https://example.com","status":"UP","code":200,"responseTime":245,"checkedAt":"2024-01-15T10:30:00.000Z","error":null}},"now":"2024-01-15T10:35:00.000Z"}
Monitor the Logs
Watch the logs to see your monitoring system in action:
Cron triggers: Check scheduling for all configured sites
Website checks: HTTP requests and response analysis
Status changes: UP/DOWN transitions and Discord alerts
Rate limiting: Alert suppression during site flapping
Advanced Configuration
Custom Check Intervals
Modify the cron expression to change monitoring frequency:
# Every 5 minutesCHECK_INTERVAL_CRON="*/5 * * * *"# Every hourCHECK_INTERVAL_CRON="0 * * * *"# Every 6 hoursCHECK_INTERVAL_CRON="0 */6 * * *"# Business hours only (9 AM - 5 PM, Mon-Fri)CHECK_INTERVAL_CRON="* 9-17 * * 1-5"
# Every 5 minutesCHECK_INTERVAL_CRON="*/5 * * * *"# Every hourCHECK_INTERVAL_CRON="0 * * * *"# Every 6 hoursCHECK_INTERVAL_CRON="0 */6 * * *"# Business hours only (9 AM - 5 PM, Mon-Fri)CHECK_INTERVAL_CRON="* 9-17 * * 1-5"
Alert Rate Limiting
Fine-tune the rate limiting to match your needs:
# Very strict: 1 alert per 10 minutesALERT_BURST="1"ALERT_WINDOW_SEC="600"# More permissive: 5 alerts per 2 minutesALERT_BURST="5"ALERT_WINDOW_SEC="120"
# Very strict: 1 alert per 10 minutesALERT_BURST="1"ALERT_WINDOW_SEC="600"# More permissive: 5 alerts per 2 minutesALERT_BURST="5"ALERT_WINDOW_SEC="120"
Multi-Environment Monitoring
Set up different monitoring configurations for different environments:
# Production sitesSITES='["https://app.production.com", "https://api.production.com"]'# Staging sitesSITES='["https://app.staging.com", "https://api.staging.com"]'# Development sitesSITES='["https://app.dev.com", "http://localhost:8080"]'
# Production sitesSITES='["https://app.production.com", "https://api.production.com"]'# Staging sitesSITES='["https://app.staging.com", "https://api.staging.com"]'# Development sitesSITES='["https://app.dev.com", "http://localhost:8080"]'
Custom Discord Alert Formatting
Modify thecreateDiscordMessagefunction inalerter.step.jsto customize alert appearance:
createDiscordMessage
alerter.step.js
functioncreateDiscordMessage(result,previousStatus) {const{url,status,code,responseTime}=result// Custom colors for your brandconstcolor=status==='UP'?0x2ecc71:0xe74c3c// Custom emoji and formattingconstemoji=status==='UP'?'✅':'❌'consturgency=responseTime>5000?'🐌 SLOW':'⚡ FAST'return{content:`${emoji} **${url}** is ${status}`,embeds: [{title:`${urgency} Website ${status}`,description:`**${url}** changed from ${previousStatus} to ${status}`,color,timestamp: result.checkedAt,fields: [{name:'⏱️ Response Time',value:`${responseTime}ms`,inline:true},{name:'📊 Status Code',value: code?.toString()||'N/A',inline:true}]}]}}
functioncreateDiscordMessage(result,previousStatus) {const{url,status,code,responseTime}=result// Custom colors for your brandconstcolor=status==='UP'?0x2ecc71:0xe74c3c// Custom emoji and formattingconstemoji=status==='UP'?'✅':'❌'consturgency=responseTime>5000?'🐌 SLOW':'⚡ FAST'return{content:`${emoji} **${url}** is ${status}`,embeds: [{title:`${urgency} Website ${status}`,description:`**${url}** changed from ${previousStatus} to ${status}`,color,timestamp: result.checkedAt,fields: [{name:'⏱️ Response Time',value:`${responseTime}ms`,inline:true},{name:'📊 Status Code',value: code?.toString()||'N/A',inline:true}]}]}}
Troubleshooting
Common Issues
Sites not being checked:
VerifySITESenvironment variable is valid JSON
SITES
Check cron expression syntax usingcrontab.guru
Review logs for parsing errors
Discord alerts not working:
VerifyDISCORD_WEBHOOKURL is correct
DISCORD_WEBHOOK
Test webhook manually:curl -X POST $DISCORD_WEBHOOK -H "Content-Type: application/json" -d '{"content":"Test message"}'
curl -X POST $DISCORD_WEBHOOK -H "Content-Type: application/json" -d '{"content":"Test message"}'
Check Discord webhook permissions
High memory usage:
Monitor status store size with health endpoint
Consider implementing status history cleanup
Reduce check frequency for many sites
False positive alerts:
Increase timeout values in checker step
Implement retry logic before marking as DOWN
Adjust rate limiting to reduce noise
Performance Tips
Large Site Lists: Consider sharding across multiple instances
Slow Sites: Implement custom timeout values per site
High Frequency: Use Redis for status storage instead of file system
Alert Fatigue: Implement escalation policies and alert grouping
Monitoring the Monitor
Set up monitoring for your monitoring system:
# Monitor the health endpoint itselfcurl-fhttp://localhost:3000/healthz||echo"Monitor is down!"# Check for recent status updatescurlhttp://localhost:3000/healthz|jq'.lastKnown | to_entries | map(select(.value.checkedAt > (now - 300)))'# Verify all sites are being checkedcurlhttp://localhost:3000/healthz|jq'.sitesConfigured == (.lastKnown | length)'
# Monitor the health endpoint itselfcurl-fhttp://localhost:3000/healthz||echo"Monitor is down!"# Check for recent status updatescurlhttp://localhost:3000/healthz|jq'.lastKnown | to_entries | map(select(.value.checkedAt > (now - 300)))'# Verify all sites are being checkedcurlhttp://localhost:3000/healthz|jq'.sitesConfigured == (.lastKnown | length)'
💻 Dive into the Code
Want to explore the complete monitoring implementation? Check out the full source code, including all steps, utilities, and configuration examples:
Complete Uptime Monitor
Access the full implementation with event steps, utility libraries, Discord integration, and production-ready configuration.
View Monitor Example
More Examples →
Conclusion: Monitoring That Actually Works
This uptime monitoring system demonstrates the power of event-driven architecture for infrastructure monitoring. By breaking down monitoring into discrete, specialized components, we've created a system that's not only reliable but also extensible and maintainable.
The event-driven approach means you can easily:
Add new notification channels(Slack, PagerDuty, email) by creating new steps
Implement custom health checks(database connectivity, API endpoints, SSL certificates)
Scale monitoringacross multiple regions or environments
Integrate with existing systemswithout disrupting the core monitoring loop
Key architectural benefits:
Resilience: Component failures don't bring down the entire system
Observability: Built-in logging and tracing at every step
Flexibility: Easy to modify check intervals, alert logic, or add new features
Testing: Each component can be tested in isolation
From here, you can extend the system by:
Adding support for different check types (TCP, database, custom health endpoints)
Implementing escalation policies and on-call rotations
Building a web dashboard for historical data and trends
Adding integration with incident management systems
Implementing multi-region monitoring with failover
The event-driven architecture makes all of these extensions straightforward to implement without disrupting the existing monitoring pipeline.
Ready to build monitoring infrastructure that scales with your business? Start building with Motia today!
Trello Automation
Build an automated card progression system for Trello boards with AI-powered summaries
GitHub Stars Counter
Real-Time GitHub Stars Counter: Building Live Updates with Motia Streams
On this page



===== https://www.motia.dev/docs/examples/github-stars-counter =====

GitHub Stars Counter
Real-Time GitHub Stars Counter: Building Live Updates with Motia Streams
In today's social-driven development world, real-time metrics and live updates are essential for building engaging applications. Whether you're creating a portfolio site, an open-source project showcase, or a developer dashboard, you need systems that can display live data without complex infrastructure.
This comprehensive guide explores how to build a production-ready, real-time GitHub stars counter using Motia's event-driven architecture and streaming capabilities. We'll cover:
Real-Time Streams: How Motia's streams enable effortless live data synchronization
Secure Webhooks: Production-ready webhook signature verification and event handling
Minimal Architecture: Building powerful real-time features with just two components
Live Integration: How this exact counter powers the live star count on the Motia website
Let's build a stars counter that updates in real-time across all connected clients.
🏭 Production-Grade Example
This is not a tutorial project- this is battle-tested, production-ready code that handles real traffic at scale. Every aspect has been designed for enterprise use:
🔐 Enterprise Security: HMAC webhook verification, timing-safe comparisons, comprehensive input validation
⚡ High Performance: Handles thousands of concurrent connections with automatic scaling
📊 Full Observability: Structured logging, error tracking, and comprehensive monitoring
🛡️ Error Resilience: Graceful degradation, retry logic, and fault tolerance
🌍 Global Scale: Production deployment on Motia Cloud with worldwide CDN
💰 Cost Efficient: Serverless architecture that scales to zero when not in use
Live Proof: Powering Motia.dev Header
This isn't just a demo- this exact code powers the live GitHub star counter you can see right now in the header ofMotia.dev!
Look at the top-right corner of the Motia website and you'll see:
🏠 Motialogo on the left
📑 Blog, Docs, Manifestonavigation
⭐ GitHubicon with alive star count(currently showing 7953+ stars)
🚀 Vercel OSS 2025badge
That live-updating number next to the GitHub icon? That's this exact implementation in production, processing real webhook events and streaming updates to thousands of visitors in real-time!
The Power of Real-Time Simplicity
At its core, our GitHub stars counter solves a fundamental challenge: how do you display live, real-time metrics without complex WebSocket infrastructure or manual state management? Traditional approaches often involve intricate server-side event handling, client connection management, and complex state synchronization.
Our Motia-powered solution breaks this down into just two simple components:
GitHub Webhooks: Instant notifications when repository stars change
Motia Streams: Real-time data synchronization with automatic state management
Production Security: Built-in webhook signature verification
🎯Live in Action: This exact implementation powers the real-time star counter visible in the header ofMotia.dev(look for the GitHub icon with live count), updating instantly whenever developers star the repository!
Instead of complex infrastructure, we get a resilient real-time system where data flows effortlessly from GitHub events to live client updates.
The Anatomy of Our Real-Time Counter
Our application consists of just two specialized components, each handling a specific part of the real-time data flow. Let's explore the complete architecture.
The real-time data stream that holds our repository star counts. This stream automatically synchronizes data to all connected clients with zero configuration.
import{ StreamConfig }from'motia'import{ z }from'zod'constRepositoryStarsSchema=z.object({stars: z.number(),name: z.string(),fullName: z.string(),organization: z.string(),lastUpdated: z.string(),})exporttypeRepositoryStars=z.infer<typeofRepositoryStarsSchema>exportconstconfig:StreamConfig={name:'stars',schema: RepositoryStarsSchema,baseConfig: { storageType:'default'},}
import{ StreamConfig }from'motia'import{ z }from'zod'constRepositoryStarsSchema=z.object({stars: z.number(),name: z.string(),fullName: z.string(),organization: z.string(),lastUpdated: z.string(),})exporttypeRepositoryStars=z.infer<typeofRepositoryStarsSchema>exportconstconfig:StreamConfig={name:'stars',schema: RepositoryStarsSchema,baseConfig: { storageType:'default'},}
Real-Time Data Flow
The beauty of this architecture lies in its simplicity. Here's how real-time updates flow through the system:
GitHub Event→ User stars/unstars your repository
Webhook Delivery→ GitHub sends POST request to your endpoint
Security Validation→ Signature verification ensures request authenticity
Stream Update→ Data is written to Motia stream withstreams.stars.set()
streams.stars.set()
Live Propagation→ All connected clients automatically receive the update
UI Updates→ Client applications re-render with new star count
No manual WebSocket management, no connection handling, no state synchronization code required!
Key Features & Benefits
⚡Instant Real-Time Updates
Stars update across all connected clients the moment GitHub sends the webhook - no polling, no delays.
🔐Production-Ready Security
HMAC signature verification with timing-safe comparison prevents unauthorized webhook requests.
🧩Minimal Architecture
Just two components handle the complete real-time functionality - no complex infrastructure required.
📊Automatic State Management
Motia streams handle data persistence, synchronization, and client updates automatically.
🎯Type-Safe Development
Full TypeScript integration with Zod validation ensures zero runtime surprises.
🌐Live Production Usage
This exact implementation powers the real-time counter visible in the Motia website header - go check it out now!
🚀Production-Grade Architecture
Built for enterprise scale with proper error handling, security, monitoring, and deployment automation.
Trying It Out
Ready to build your own real-time GitHub stars counter? Let's get it running.
Clone and Install
Start by getting the project locally and installing dependencies.
gitclonehttps://github.com/MotiaDev/github-stars-counter.gitcdgithub-stars-counternpminstall
gitclonehttps://github.com/MotiaDev/github-stars-counter.gitcdgithub-stars-counternpminstall
Configure GitHub Webhook (Optional)
Set up webhook security with a secret for production use. This is optional for testing but essential for production deployments.
# Generate a secure random secretexportGITHUB_WEBHOOK_SECRET=$(opensslrand-hex32)echo"GITHUB_WEBHOOK_SECRET=$GITHUB_WEBHOOK_SECRET">>.env
# Generate a secure random secretexportGITHUB_WEBHOOK_SECRET=$(opensslrand-hex32)echo"GITHUB_WEBHOOK_SECRET=$GITHUB_WEBHOOK_SECRET">>.env
Start Development Server
Launch the Motia development server to begin receiving webhook events.
npmrundev
npmrundev
Your webhook endpoint will be available at:http://localhost:3000/webhooks/github/star
http://localhost:3000/webhooks/github/star
Set Up GitHub Webhook
Configure GitHub to send star events to your endpoint:
Go to your GitHub repository settings
Navigate toSettings→Webhooks
ClickAdd webhook
SetPayload URLto your endpoint (use ngrok for local testing)
SetContent typetoapplication/json
application/json
Add your webhook secret if configured
SelectIndividual events→Stars
ClickAdd webhook
Test the Real-Time Updates
Test your webhook by starring/unstarring your repository:
Star your repositoryon GitHub
Check the logs- you should see webhook processing
Access the stream- query/api/streams/starsto see current data
/api/streams/stars
Watch real-time updatesin the Motia Workbench
Access Real-Time Data
Your star data is now available via the Motia streams API:
# Get all repository star countscurlhttp://localhost:3000/api/streams/stars# Get specific repository star countcurlhttp://localhost:3000/api/streams/stars/{org}/{repo}
# Get all repository star countscurlhttp://localhost:3000/api/streams/stars# Get specific repository star countcurlhttp://localhost:3000/api/streams/stars/{org}/{repo}
The response includes live star counts that update automatically whenever GitHub sends webhook events.
Deploy to Production
Once your counter is working locally, deploy it to production with Motia Cloud:
Option 1: CLI Deployment
# Deploy with version and API keymotiaclouddeploy--api-keyyour-api-key--version-name1.0.0# Deploy with environment variablesmotiaclouddeploy--api-keyyour-api-key\--version-name1.0.0\--env-file.env.production\--environment-idyour-env-id
# Deploy with version and API keymotiaclouddeploy--api-keyyour-api-key--version-name1.0.0# Deploy with environment variablesmotiaclouddeploy--api-keyyour-api-key\--version-name1.0.0\--env-file.env.production\--environment-idyour-env-id
Option 2: One-Click Web Deployment
Ensure your local project is running (npm run dev)
npm run dev
Go toMotia Cloud -> Import from Workbench
Select your local project port
Choose project and environment name
Upload environment variables (optional)
ClickDeployand watch the magic happen! ✨
🚀 Production Deployment Guide
Environment Variables
Configure these environment variables for production security and functionality:
# Required: GitHub webhook secret for securityGITHUB_WEBHOOK_SECRET="your-secure-random-secret"# Optional: GitHub personal access token for enhanced API limitsGITHUB_TOKEN="ghp_your_github_token"
# Required: GitHub webhook secret for securityGITHUB_WEBHOOK_SECRET="your-secure-random-secret"# Optional: GitHub personal access token for enhanced API limitsGITHUB_TOKEN="ghp_your_github_token"
Security Best Practices
For production deployments, ensure you:
Generate secure webhook secrets:# Generate a cryptographically secure secretopensslrand-hex32
Generate secure webhook secrets:
# Generate a cryptographically secure secretopensslrand-hex32
# Generate a cryptographically secure secretopensslrand-hex32
Store secrets securely: Use environment variables, never commit to code
Store secrets securely: Use environment variables, never commit to code
Monitor webhook signatures: The handler automatically verifies signatures whenGITHUB_WEBHOOK_SECRETis set
Monitor webhook signatures: The handler automatically verifies signatures whenGITHUB_WEBHOOK_SECRETis set
GITHUB_WEBHOOK_SECRET
Enable logging: Monitor for signature verification failures and unauthorized requests
Enable logging: Monitor for signature verification failures and unauthorized requests
Scaling Considerations
This architecture scales automatically with your traffic:
Multiple repositories: Each repo gets its own stream key (org/repo)
org/repo
High concurrency: Motia streams handle thousands of concurrent connections
Global distribution: Deploy to multiple regions for worldwide performance
Cost optimization: Pay only for actual usage with serverless scaling
💻 Dive into the Code
Want to explore the complete real-time implementation? Check out the full source code and see how simple real-time features can be with Motia:
Live GitHub Stars Counter
Access the complete implementation with webhook security, real-time streams, and production deployment configurations. See exactly how the Motia website's live counter works!
View Stars Counter Code
See It Live in Header →
Conclusion: Real-Time Made Simple
This GitHub stars counter demonstrates how Motia transforms complex real-time development into simple, manageable components. With just two files and minimal configuration, we've built a production-ready system that handles webhook security, real-time synchronization, and live client updates.
The beauty of this approach is its scalability and extensibility:
Add more repositories: Each gets its own stream automatically
Enhance with analytics: Track starring patterns and user insights
Multiple notification channels: Slack, Discord, email alerts for milestones
Rich frontend integrations: React, Vue, vanilla JS - all work seamlessly
Key architectural benefits:
No WebSocket complexity: Streams handle all real-time synchronization automatically
Built-in security: Production-ready webhook verification out of the box
Type safety: Full TypeScript support prevents runtime errors
Zero configuration: Real-time features work with no additional setup
This exact implementation powers the live star counter you see in the header ofMotia.dev- that 7953+ count updating in real-time? It's this code in action, proven at enterprise scale with thousands of daily visitors.
Production Metrics:
Handles 10,000+ webhook events per day
Sub-50ms response times globally
99.9% uptime with automatic failover
Zero maintenance serverless architecture
Ready to add enterprise-grade real-time features to your applications? Deploy production-ready code with Motia today!
Uptime Monitor
Real-Time Uptime Monitoring: Building a Resilient Website Monitor with Motia
GitHub Integration
Build an automated GitHub issue and PR management system with AI-powered classification and routing
On this page



===== https://www.motia.dev/docs/examples/github-integration-workflow =====

GitHub Integration
Build an automated GitHub issue and PR management system with AI-powered classification and routing
Let's build a GitHub automation system that:
Automatically triages and classifies new issues
Intelligently assigns labels based on content
Suggests appropriate assignees and reviewers
Monitors PR test status
Generates contextual comments
Workflow Structure
The GitHub integration workflow is organized into two main components:
Issue Triage: Handles the management of GitHub issues
PR Classifier: Manages pull request workflows
The Steps
Visual Overview
Here's how the automation flow works:
Webhook Reception→ Captures GitHub events
Issue/PR Classification→ Analyzes content with AI
Automated Labeling→ Applies appropriate labels
Smart Assignment→ Suggests reviewers and assignees
Status Monitoring→ Tracks PR test status
Try It Out
Prerequisites
Make sure you have:
GitHub account with personal access token
Node.js installed
OpenAI API key (for AI classification)
Clone the Repository
gitclonegit@github.com:MotiaDev/motia-examples.gitcdexamples/github-integration-workflow
gitclonegit@github.com:MotiaDev/motia-examples.gitcdexamples/github-integration-workflow
Install Dependencies
npminstall
npminstall
Configure Environment Variables
Create a.envfile by copying the example:
.env
cp.env.example.env
cp.env.example.env
Update your.envwith the following credentials:
.env
GITHUB_TOKEN=your_github_token_hereOPENAI_API_KEY=your_openai_api_key
GITHUB_TOKEN=your_github_token_hereOPENAI_API_KEY=your_openai_api_key
Set Up GitHub Webhook
Go to your GitHub repository settings
Navigate to Webhooks and add a new webhook
Set the Payload URL to your Motia server endpoint
Select content type asapplication/json
application/json
Choose which events to trigger the webhook (Issues, Pull requests)
Save the webhook
Run the Application
npmrundev
npmrundev
Test the Flow
Create a new issue in your GitHub repository
Watch as it gets automatically classified and labeled
Create a new PR to see the reviewer assignment in action
Check the PR comments for test status updates
For more detailed setup instructions and configuration options, check out thefull
documentation.
GitHub Stars Counter
Real-Time GitHub Stars Counter: Building Live Updates with Motia Streams
Gmail Automation
Build an automated email system with smart labeling, auto-responses, and AI-powered filtering
On this page



===== https://www.motia.dev/docs/examples/gmail-automation =====

Gmail Automation
Build an automated email system with smart labeling, auto-responses, and AI-powered filtering
Let's build a Gmail automation system that:
📊 Smart email classification by category (work, personal, social, promotion, spam, update)
🚨 Urgency detection (high, medium, low) with prioritization
💬 Intelligent automated responses based on email context
🏷️ Automatic email organization (labeling, archiving)
📈 Daily summary reports via Discord
🔒 Secure Gmail API integration with OAuth2 authentication flow
⚡ Real-time email monitoring with webhook notifications
The Steps
Visual Overview
Here's how the automation flow works:
🌊 Workflow Architecture
The Gmail Account Manager workflow consists of the following steps:
1. Gmail Authentication (Multi-Step Flow)
Files:steps/gmail-get-auth-url.step.ts: Generates OAuth2 authorization URLsteps/gmail-auth.step.ts: Handles authorization code exchangesteps/gmail-token-status.step.ts: Checks token validity and refreshes if needed
steps/gmail-get-auth-url.step.ts: Generates OAuth2 authorization URL
steps/gmail-get-auth-url.step.ts
steps/gmail-auth.step.ts: Handles authorization code exchange
steps/gmail-auth.step.ts
steps/gmail-token-status.step.ts: Checks token validity and refreshes if needed
steps/gmail-token-status.step.ts
2. Gmail Webhook (API Step)
File:steps/gmail-webhook.step.ts
steps/gmail-webhook.step.ts
Purpose: Receives notifications from Gmail when new emails arrive
Emits:gmail.new_emailevent with message details
gmail.new_email
Endpoint:POST /api/gmail-webhook
POST /api/gmail-webhook
3. Gmail Watch (API Step)
File:steps/gmail-watch.step.ts
steps/gmail-watch.step.ts
Purpose: Sets up push notifications for the Gmail account
Endpoint:GET /api/watch
GET /api/watch
4. Fetch Email (Event Step)
File:steps/fetch-email.step.ts
steps/fetch-email.step.ts
Purpose: Retrieves the full email content from Gmail API
Subscribes to:gmail.email.received
gmail.email.received
Emits:gmail.email.fetchedwith complete email data
gmail.email.fetched
Key Functions: Authenticates with Gmail API, fetches message content, parses attachments
5. Analyze Email (Event Step)
File:steps/analyze-email.step.py
steps/analyze-email.step.py
Purpose: Uses Hugging Face models to analyze email content
Subscribes to:gmail.email.fetched
gmail.email.fetched
Emits:gmail.email.analyzedwith analysis results
gmail.email.analyzed
Analysis Performed:Category classificationUrgency detectionSentiment analysisKey information extraction
Category classification
Urgency detection
Sentiment analysis
Key information extraction
6. Organize Email (Event Step)
File:steps/organize-email.step.ts
steps/organize-email.step.ts
Purpose: Applies labels and organization based on analysis
Subscribes to:gmail.email.analyzed
gmail.email.analyzed
Emits:[gmail.email.organized, gmail.email.archived]
[gmail.email.organized, gmail.email.archived]
Actions: Creates/applies labels, archives certain emails, marks importance
7. Auto-Respond to Email (Event Step)
File:steps/auto-responder.step.ts
steps/auto-responder.step.ts
Purpose: Generates and sends appropriate responses for certain emails
Subscribes to:gmail.email.analyzed
gmail.email.analyzed
Emits:gmail.email.responded
gmail.email.responded
Features:Template selection based on email contextPersonalization of responsesAuto-reply for urgent messagesFollow-up scheduling
Template selection based on email context
Personalization of responses
Auto-reply for urgent messages
Follow-up scheduling
8. Daily Summary (Cron Step)
File:steps/daily-summary.step.ts
steps/daily-summary.step.ts
Purpose: Compiles and sends daily email activity summary
Schedule: Runs daily at 6:00 PM
Emits:gmail.summary.sent
gmail.summary.sent
Delivery: Sends report to Discord via webhook
Try It Out
📋 Prerequisites
Node.js(v18+)
Python(v3.8+)
Gmail API credentials(client_id and client_secret)
Google Cloud projectwith Pub/Sub API enabled
Hugging Face API token
Discord webhook URL(for daily summaries)
🚀 Quick Start
Clone this repositorygitclonehttps://github.com/yourusername/gmail-flow.gitcdgmail-flow
Clone this repository
gitclonehttps://github.com/yourusername/gmail-flow.gitcdgmail-flow
gitclonehttps://github.com/yourusername/gmail-flow.gitcdgmail-flow
Install Node.js dependenciespnpminstall
Install Node.js dependencies
pnpminstall
pnpminstall
Install Python dependenciespipinstall-rrequirements.txt
Install Python dependencies
pipinstall-rrequirements.txt
pipinstall-rrequirements.txt
Configure environment variablescp.env.example.envThen edit the.envfile with your credentials (see setup sections below).
Configure environment variables
cp.env.example.env
cp.env.example.env
Then edit the.envfile with your credentials (see setup sections below).
.env
Start the development serverpnpmdev
Start the development server
pnpmdev
pnpmdev
Open the Motia WorkbenchNavigate tohttp://localhost:3000to access the workflow UI.
Open the Motia Workbench
Navigate tohttp://localhost:3000to access the workflow UI.
🔧 Detailed Setup
Setting up Google Cloud Project and Gmail API
Before you can use the Gmail Account Manager, you need to set up a Google Cloud project with the Gmail API and Pub/Sub:
Create a Google Cloud Project:Go toGoogle Cloud ConsoleClick on "New Project" and follow the steps to create a new projectNote your project ID for later use
Create a Google Cloud Project:
Go toGoogle Cloud Console
Click on "New Project" and follow the steps to create a new project
Note your project ID for later use
Enable the Gmail API:In your project, go to "APIs & Services" > "Library"Search for "Gmail API" and click on itClick "Enable"
Enable the Gmail API:
In your project, go to "APIs & Services" > "Library"
Search for "Gmail API" and click on it
Click "Enable"
Enable the Pub/Sub API:In your project, go to "APIs & Services" > "Library"Search for "Cloud Pub/Sub API" and click on itClick "Enable"
Enable the Pub/Sub API:
In your project, go to "APIs & Services" > "Library"
Search for "Cloud Pub/Sub API" and click on it
Click "Enable"
Create OAuth Credentials:Go to "APIs & Services" > "Credentials"Click "Create Credentials" > "OAuth client ID"Set the application type to "Desktop app"Click "Create"Note your Client ID and Client Secret for your.envfile:GOOGLE_CLIENT_ID=your_client_idGOOGLE_CLIENT_SECRET=your_client_secret
Create OAuth Credentials:
Go to "APIs & Services" > "Credentials"
Click "Create Credentials" > "OAuth client ID"
Set the application type to "Desktop app"
Click "Create"
Note your Client ID and Client Secret for your.envfile:GOOGLE_CLIENT_ID=your_client_idGOOGLE_CLIENT_SECRET=your_client_secret
.env
GOOGLE_CLIENT_ID=your_client_idGOOGLE_CLIENT_SECRET=your_client_secret
GOOGLE_CLIENT_ID=your_client_idGOOGLE_CLIENT_SECRET=your_client_secret
Setting up Google Pub/Sub for Gmail Notifications
To enable real-time email notifications, you need to set up a Google Cloud Pub/Sub topic and subscription:
Create a Pub/Sub Topic:In your Google Cloud Console, go to "Pub/Sub" > "Topics"Click "Create Topic"Name your topic (e.g.,gmail-notifications)Add the service accountgmail-api-push@system.gserviceaccount.comas a Topic Publisher to allow Gmail to publish notificationsClick "Create"Note the full topic name (usuallyprojects/your-project-id/topics/gmail-notifications) for your.envfile:GOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications
Create a Pub/Sub Topic:
In your Google Cloud Console, go to "Pub/Sub" > "Topics"
Click "Create Topic"
Name your topic (e.g.,gmail-notifications)
gmail-notifications
Add the service accountgmail-api-push@system.gserviceaccount.comas a Topic Publisher to allow Gmail to publish notifications
gmail-api-push@system.gserviceaccount.com
Click "Create"
Note the full topic name (usuallyprojects/your-project-id/topics/gmail-notifications) for your.envfile:GOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications
projects/your-project-id/topics/gmail-notifications
.env
GOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications
GOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications
Create a Pub/Sub Subscription:Once your topic is created, click "Create Subscription"Name your subscription (e.g.,gmail-notifications-push)Set the Delivery Type to "Push"Set the Endpoint URL to your webhook URL (e.g.,https://your-domain.com/api/gmail-webhook)For local development, you'll need to use a tool like ngrok to expose your local serverClick "Create"
Create a Pub/Sub Subscription:
Once your topic is created, click "Create Subscription"
Name your subscription (e.g.,gmail-notifications-push)
gmail-notifications-push
Set the Delivery Type to "Push"
Set the Endpoint URL to your webhook URL (e.g.,https://your-domain.com/api/gmail-webhook)For local development, you'll need to use a tool like ngrok to expose your local server
https://your-domain.com/api/gmail-webhook
For local development, you'll need to use a tool like ngrok to expose your local server
Click "Create"
Set up Domain Verification(if needed):If you're using a custom domain for your webhook endpoint, you may need to verify domain ownershipFollow the instructions in Google Cloud Console for domain verification
Set up Domain Verification(if needed):
If you're using a custom domain for your webhook endpoint, you may need to verify domain ownership
Follow the instructions in Google Cloud Console for domain verification
Gmail API Authentication
This project includes a complete OAuth2 authentication flow for the Gmail API:
Start the development server:pnpm dev
pnpm dev
Navigate to the authentication workflow in the Motia Workbench
The workflow will generate an authorization URL
Open the URL in your browser and authorize the application
The application will receive and store your authentication tokens
Discord Webhook Configuration
To receive daily email summaries in Discord, follow these steps to set up a webhook:
Create a Discord Server(skip if you already have one):Open Discord and click the "+" icon on the left sidebarSelect "Create My Own" and follow the setup wizard
Create a Discord Server(skip if you already have one):
Open Discord and click the "+" icon on the left sidebar
Select "Create My Own" and follow the setup wizard
Create a Channel for Notifications:Right-click on your server name and select "Server Settings"Go to "Channels" and click "Create Channel"Name it (e.g., "email-summaries") and click "Create"
Create a Channel for Notifications:
Right-click on your server name and select "Server Settings"
Go to "Channels" and click "Create Channel"
Name it (e.g., "email-summaries") and click "Create"
Create a Webhook:Right-click on your new channel and select "Edit Channel"Go to "Integrations" tabClick "Create Webhook"Give it a name (e.g., "Gmail Summary Bot")Optionally, customize the avatarClick "Copy Webhook URL"
Create a Webhook:
Right-click on your new channel and select "Edit Channel"
Go to "Integrations" tab
Click "Create Webhook"
Give it a name (e.g., "Gmail Summary Bot")
Optionally, customize the avatar
Click "Copy Webhook URL"
Add Webhook URL to Environment Variables:Open your.envfileAdd or update the Discord webhook URL:DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url
Add Webhook URL to Environment Variables:
Open your.envfile
.env
Add or update the Discord webhook URL:DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url
DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url
DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url
Test the Webhook:You can test if your webhook is working correctly with this curl command:curl-XPOST-H"Content-Type: application/json"\-d'{"content": "Testing Gmail Account Manager webhook"}'\https://discord.com/api/webhooks/your-webhook-urlYou should see the message appear in your Discord channel
Test the Webhook:
You can test if your webhook is working correctly with this curl command:curl-XPOST-H"Content-Type: application/json"\-d'{"content": "Testing Gmail Account Manager webhook"}'\https://discord.com/api/webhooks/your-webhook-url
curl-XPOST-H"Content-Type: application/json"\-d'{"content": "Testing Gmail Account Manager webhook"}'\https://discord.com/api/webhooks/your-webhook-url
curl-XPOST-H"Content-Type: application/json"\-d'{"content": "Testing Gmail Account Manager webhook"}'\https://discord.com/api/webhooks/your-webhook-url
You should see the message appear in your Discord channel
Hugging Face Setup
Create a Hugging Face Account:Sign up atHugging Face
Create a Hugging Face Account:
Sign up atHugging Face
Generate an API Token:Go to yourHugging Face account settingsCreate a new API tokenCopy the token to your.envfile:HUGGINGFACE_API_TOKEN=your_api_token
Generate an API Token:
Go to yourHugging Face account settings
Create a new API token
Copy the token to your.envfile:HUGGINGFACE_API_TOKEN=your_api_token
.env
HUGGINGFACE_API_TOKEN=your_api_token
HUGGINGFACE_API_TOKEN=your_api_token
📁 Project Structure
steps/- Contains all workflow stepsgmail-get-auth-url.step.ts- Generates OAuth2 URLgmail-auth.step.ts- Handles OAuth2 flowgmail-token-status.step.ts- Manages token refreshgmail-webhook.step.ts- Webhook endpoint for Gmail notificationsgmail-watch.step.ts- Sets up Gmail push notificationsfetch-email.step.ts- Fetches email content from Gmail APIanalyze-email.step.py- Python step for email analysis using Hugging Faceorganize-email.step.ts- Organizes emails (labels, archives)auto-responder.step.ts- Generates appropriate responsesdaily-summary.step.ts- Sends daily summary to Discord
steps/
gmail-get-auth-url.step.ts- Generates OAuth2 URL
gmail-get-auth-url.step.ts
gmail-auth.step.ts- Handles OAuth2 flow
gmail-auth.step.ts
gmail-token-status.step.ts- Manages token refresh
gmail-token-status.step.ts
gmail-webhook.step.ts- Webhook endpoint for Gmail notifications
gmail-webhook.step.ts
gmail-watch.step.ts- Sets up Gmail push notifications
gmail-watch.step.ts
fetch-email.step.ts- Fetches email content from Gmail API
fetch-email.step.ts
analyze-email.step.py- Python step for email analysis using Hugging Face
analyze-email.step.py
organize-email.step.ts- Organizes emails (labels, archives)
organize-email.step.ts
auto-responder.step.ts- Generates appropriate responses
auto-responder.step.ts
daily-summary.step.ts- Sends daily summary to Discord
daily-summary.step.ts
services/- Shared service modules
services/
config/- Configuration files
config/
.motia/- Motia framework configuration
.motia/
📦 Dependencies
Node.js Dependencies
@motiadev/core,@motiadev/workbench,motia: Motia framework
googleapis,google-auth-library: Google API integration
gmail-api-parse-message-ts: Gmail message parsing
axios: HTTP client
zod: Schema validation
react: UI components
Python Dependencies
transformers,torch: Machine learning models
scikit-learn,numpy,pandas: Data processing
huggingface_hub: Access to Hugging Face models
python-dotenv: Environment variable loading
🛠️ Troubleshooting
Python Module Errors: Ensure you've installed all required Python packages withpip install -r requirements.txt
pip install -r requirements.txt
Authentication Errors: Verify your API credentials and follow the authentication flow
Webhook Issues: Make sure the webhook endpoint is publicly accessible or properly configured for testing
Token Refresh Errors: Check that your OAuth tokens are valid and that the refresh flow is working properly
Pub/Sub Not Working: Verify that your Pub/Sub topic and subscription are properly configured and that your service account has the necessary permissions
📝 Environment Variables
Create a.envfile with the following variables:
.env
# Google API ConfigurationGOOGLE_CLIENT_ID=your_client_idGOOGLE_CLIENT_SECRET=your_client_secretGOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications# HuggingFace ConfigurationHUGGINGFACE_API_TOKEN=your_huggingface_token# Discord IntegrationDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url# Auto-Responder ConfigurationAUTO_RESPONDER_NAME=Your NameAUTO_RESPONDER_EMAIL=your-email@example.com
# Google API ConfigurationGOOGLE_CLIENT_ID=your_client_idGOOGLE_CLIENT_SECRET=your_client_secretGOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications# HuggingFace ConfigurationHUGGINGFACE_API_TOKEN=your_huggingface_token# Discord IntegrationDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url# Auto-Responder ConfigurationAUTO_RESPONDER_NAME=Your NameAUTO_RESPONDER_EMAIL=your-email@example.com
GitHub Integration
Build an automated GitHub issue and PR management system with AI-powered classification and routing
Finance Agent
A powerful event-driven financial analysis workflow that combines web search, financial data, and AI analysis to provide comprehensive investment insights.
On this page



===== https://www.motia.dev/docs =====

Welcome to Motia
Motia is a multi-language, event-driven runtime manager built on a core primitive: the Step. It feels like a backend framework, but powers distributed backends for APIs, background jobs, queues, workflows, agents, streaming, state, and observability, all unified in one system.
Welcome to Motia
Why Motia?
Backend development today is fragmented.
APIs live in one framework, background jobs in another, queues and schedulers elsewhere, and now AI agents and streaming systems have their own runtimes. Add observability and state management on top, and you’re stitching together half a dozen tools before writing your first feature.
Motia unifies all of these concerns around one core primitive: the Step.
Just as React made frontend development simple by introducing components, Motia redefines backend development with Steps.
Every backend pattern, API endpoints, background jobs, queues, workflows, AI agents, streaming, observability, and state, is expressed with the same primitive.
To read more about this, check out ourmanifesto.
The Core Primitive: the Step
At the heart of Motia is a single primitive: theStep.
A Step is just a file with aconfigand ahandler. Motia auto-discovers these files from/stepsdirectory and connects them automatically.
config
handler
/steps
Here’s a simple example of two Steps working together: an API Step that emits an event, and an Event Step that processes it.
exportconstconfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
exportconstconfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
exportconstconfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler=async(input, {logger})=>{logger.info('Processing message', input);};
exportconstconfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you’ve built anAPI endpoint, aqueue, and aworker. No extra frameworks required.
Learn more about Steps here:What is a Step?.
Working with multiple Languages
The rapid advancement of AI has reshaped the software industry—many cutting-edge AI tools are available only in specific programming languages, this forces companies to decide if they either change their team's skillset to a different language or not leveraging these technologies at all.
Motia removes this limitation by allowing each Step to be written in any language, while still sharing a common state.
Each rectangle in the diagram above represents a Step, some of them are in TypeScript and others in Python.
Scalability
One of the biggest dilemmas in backend development is choosing between scalability and development velocity. In startup environments, speed often takes priority, resulting in systems that don't scale well and become problematic under increased load.
Motia addresses scalability by leveraging the core primitive ofSteps: Each step can scale independently avoiding the bottlenecks common in monolithic architectures.
Observability
Observability in traditional backends often demands significant engineering effort to implement logging, alerting, and tracing. Typically, these tools are only configured for cloud environments, local development is generally neglected—leading to low productivity and poor dev experience.
Motia offers a complete observability toolkit available in both cloud and local environments, including:
Logs visualization
Tracing tool to quickly visualize the flow of requests through the system
State visualization
Diagram representation of dependencies between steps and how they are connected
The image below shows the Workbench interface available when you runmotia dev. On the top panel you can see a workflow diagram with multiple steps connected.
On the bottom panel you can see the trace view of a single request and what happened in each step.
motia dev
Fault tolerance
With the rise of AI, many backend tasks have become less deterministic and more error-prone. These scenarios require robust error handling and retry mechanisms. In traditional systems, developers often need to set up and maintain queue infrastructures to ensure resilience, especially when dealing with unreliable responses from LLMs.
Motia provides fault tolerance out of the box, eliminating the need to manually spin up queue infrastructure.
Using Event Steps, you get retry mechanisms out of the box
Configuration of queue infrastructure is abstracted away
Building and Shipping
Building and deploying backends is inherently complex—especially in polyglot environments. Shipping production systems requires tight collaboration between developers and operations, and automation often takes weeks to get right.
Beyond that, cloud provider lock-in, complicated deployment strategies (e.g., rollbacks, blue/green deployments), and a lack of deployment tooling increase the risk of failure.
Motia abstracts these concerns by providing:
True cloud-provider agnosticism
Atomic blue/green deployments and one-click rollbacks via Motia Cloud (canary support coming soon)
First-class polyglot backend support (currently Node.js and Python, with more on the way)
The image above shows several Steps being build to a single Motia deployable that are ultimately deployed to a cloud provider of your choice.
Currently we're supporting AWS and Kubernetes, more Cloud providers coming soon. Check ourroadmapfor more details.
Rollbacks and deployment strategies
Deploying cloud-native, fault-tolerant applications often involves modifying queue systems and other infrastructure components.
These changes can introduce incompatibilities and lead to runtime failures.
Motia Cloud solves this withAtomic Deployments, which:
Each deployment spins up a new isolated service that shares the same data layer
Ensures safe, rollback-capable deployments without risking service downtime
Instant rollbacks with one click since each deployment is isolated
Real-time data streaming
Handling real-time data is one of the most common—and complex—challenges in backend development. It's necessary when building event-driven applications,
and it typically requires setting up and maintaining a significant amount of infrastructure.
Motia provides what we callStreams: Developers define the structure of the data—any changes to these objects are streamed to all subscribed clients in real-time.
The image above shows a Stream definition, a Node.js Step mutating the data and a client subscribing to the stream receiving real-time updates.
Quick Start
Get up and running with a new Motia project in just a few seconds.
On this page



===== https://www.motia.dev/docs/getting-started/quick-start =====

Quick Start
Get up and running with a new Motia project in just a few seconds.
1. Create Your Project
Usenpxto create a new Motia project. This single command will scaffold a new application and install all necessary dependencies.
npx
npxmotia@latestcreate
npxmotia@latestcreate
The installer will guide you through a few questions to set up your project. Once it's done, you will have a new project directory ready to go.
2. Start the Development Server
Navigate into your new project directory and start the Motia development server.
cd<your-project-name># If you've created a new folder for the project, navigate into itnpxmotiadev
cd<your-project-name># If you've created a new folder for the project, navigate into itnpxmotiadev
Thecreatecommand usesnpmby default. If you chose a different package manager during setup, usepnpm dev,yarn dev, orbun dev.
create
npm
pnpm dev
yarn dev
bun dev
This command starts the Motia runtime and the Workbench, a powerful UI for developing and debugging your workflows. By default, it's available athttp://localhost:3000.
http://localhost:3000
3. Run Your First Flow
The starter project comes with a pre-builtbasic-tutorialflow. Let's run it.
basic-tutorial
Open the Workbenchin your browser athttp://localhost:3000.
http://localhost:3000
Click theTutorialbutton on the top right of the workbench.
Tutorial
Complete theTutorialto get an understanding of the basics of Motia and using the Workbench.
Tutorial
Next Steps
Congratulations! You've successfully ran, and observed your first Motia workflow.
Build your first application from scratch, follow ourBuild Your First Motia Appguide.
To learn about Motia, dive into ourCore Concepts.
Welcome to Motia
Motia is a multi-language, event-driven runtime manager built on a core primitive: the Step. It feels like a backend framework, but powers distributed backends for APIs, background jobs, queues, workflows, agents, streaming, state, and observability, all unified in one system.
Build Your First Motia App
Learn Motia step-by-step by building a real pet store backend
On this page



===== https://www.motia.dev/docs/getting-started/build-your-first-motia-app =====

Build Your First Motia App
Learn Motia step-by-step by building a real pet store backend
What You'll Build
A complete pet store backend system that grows with you:
API Endpoints→ Handle requests, return responses
Background Jobs→ Process tasks without blocking APIs
Workflows→ Coordinate complex business logic automatically
AI Agents→ Make intelligent decisions that drive your workflows
Real-Time Streaming→ Push live updates to clients as workflows execute
By the end, you'll have a production-ready backend that handles everything from simple CRUD to intelligent, real-time systems.
Before You Start
You'll need:
Node.js installed (v18 or higher)
Basic understanding of TypeScript/JavaScript/Python
10-20 minutes per tutorial
That's it. No database setup, no complex config, no separate services to run.
Your Journey
1. API Endpoints
What:Create HTTP endpoints that handle pet operations.
You'll learn:
How to define API Steps
Request validation with schemas
Returning proper HTTP responses
Testing endpoints in Workbench
Time:10 minutes
Start with APIs →
Build your first HTTP endpoints
2. Background Jobs
What:Add async tasks that run without blocking your APIs.
You'll learn:
Event Steps that trigger from your APIs
Cron Steps that run on a schedule
How events connect your system
Monitoring jobs in Workbench
Time:15 minutes
Add Background Jobs →
Handle async tasks efficiently
3. Workflows
What:Coordinate complex processes with automatic transitions and validation.
You'll learn:
Building workflow orchestrators
Automatic vs manual transitions
State validation and progression
Chaining multiple actions together
Time:20 minutes
Build Workflows →
Orchestrate complex business logic
4. AI Agents
What:Add intelligent decision-making to your workflows.
You'll learn:
Content generation with AI
Decision-making agents
Integrating AI with workflows
Building agentic routing
Time:20 minutes
Add AI Agents →
Make your backend intelligent
5. Real-Time Streaming
What:Push live updates to clients while your workflows run in the background.
You'll learn:
Defining stream configurations
Streaming from APIs that return immediately
Background jobs that push progress updates
AI agents that stream enrichment progress
Connecting multiple steps to the same stream
Time:20 minutes
Add Streaming →
Build real-time experiences
The Example Project
All tutorials use the same project - a pet store backend that handles:
Pet management→ Create, update, list pets
Adoption workflow→ Guide pets through quarantine, health checks, and availability
Feeding reminders→ Set up schedules when pets arrive
Health decisions→ AI evaluates symptoms and recommends treatment
Cleanup jobs→ Remove soft-deleted pets on a schedule
Real-time updates→ Stream progress to clients as workflows execute
It's a real system with the kind of complexity you'll face building production backends.
Interactive Tutorials
Each guide includes aninteractive tutorialyou can run directly in Workbench. It walks you through the code, explains what's happening, and lets you test everything live.
Prefer reading? The written guides cover everything too. They're detailed, with code examples and explanations for every concept.
Ready?
Pick your starting point. If you're new to Motia, start with API Endpoints. If you've already covered the basics, jump to wherever you want to learn more.
API Endpoints
Start here if you're new
Background Jobs
Add async processing
Workflows
Coordinate complex logic
AI Agents
Build intelligent systems
Real-Time Streaming
Push live updates
Quick Start
Get up and running with a new Motia project in just a few seconds.
API Endpoints
Learn how to create HTTP API endpoints with Motia
On this page



===== https://www.motia.dev/docs/getting-started/build-your-first-motia-app/api-endpoints =====

API Endpoints
Learn how to create HTTP API endpoints with Motia
What You'll Build
A pet management API with these endpoints:
POST/pets- Create a new pet
/pets
GET/pets- List all pets
/pets
GET/pets/:id- Get a specific pet
/pets/:id
PUT/pets/:id- Update a pet
/pets/:id
DELETE/pets/:id- Delete a pet
/pets/:id
Getting Started
Clone the example repository:
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutapi-endpoints
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutapi-endpoints
Install dependencies:
npminstall
npminstall
Start the Workbench:
npmrundev
npmrundev
Your Workbench will be available athttp://localhost:3000.
http://localhost:3000
Project Structure
Files likefeatures.jsonandtutorial.tsxare only for the interactive tutorial and are not part of Motia's project structure.
features.json
tutorial.tsx
All code examples in this guide are available in thebuild-your-first-apprepository.
You can follow this guide to learn how to build a REST API with Motia step by step, or you can clone the repository and dive into our Interactive Tutorial to learn by doing directly in the Workbench.
Creating Your First Endpoint
This tutorial focuses on Motia's capabilities to create complete backend system from APIs to Streaming AI agents step-by-step. Here, we're showcasing writing APIs with Motia Steps - For data persistence, we use a simple JSON file store in the examples. In a real application, you would use a database like PostgreSQL, MongoDB, or any other data store of your choice. The complete store implementation is available in theGitHub repository.
Configuration
Every API endpoint has two parts:
Config- Defines when and how the step runs:
name
type
'api'
path
method
Handler- The function that executes your business logic.
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constcreatePetSchema=z.object({name: z.string().min(1,'Name is required'),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0),})exportconstconfig:ApiRouteConfig={name:'CreatePet',type:'api',path:'/pets',method:'POST',bodySchema: createPetSchema,flows: ['PetManagement'],}exportconsthandler:Handlers['CreatePet']=async(req, {logger})=>{constdata=createPetSchema.parse(req.body)// In a real application, this would be a database call// e.g., await db.pets.create(data)constpet=TSStore.create(data)logger.info('Pet created', { petId: pet.id })return{ status:201, body: pet }}
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constcreatePetSchema=z.object({name: z.string().min(1,'Name is required'),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0),})exportconstconfig:ApiRouteConfig={name:'CreatePet',type:'api',path:'/pets',method:'POST',bodySchema: createPetSchema,flows: ['PetManagement'],}exportconsthandler:Handlers['CreatePet']=async(req, {logger})=>{constdata=createPetSchema.parse(req.body)// In a real application, this would be a database call// e.g., await db.pets.create(data)constpet=TSStore.create(data)logger.info('Pet created', { petId: pet.id })return{ status:201, body: pet }}
Testing Your API
You can test your endpoints using curl or the Workbench interface.
Using curl
# Create a petcurl-XPOSThttp://localhost:3000/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
# Create a petcurl-XPOSThttp://localhost:3000/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
Using Workbench
You can also test your endpoint directly in the Workbench, which provides an interactive interface to test your API endpoints with real requests and see the responses in real-time:
Adding GET Endpoints
List All Pets
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:ApiRouteConfig={name:'GetPets',type:'api',path:'/pets',method:'GET',flows: ['PetManagement'],}exportconsthandler:Handlers['GetPets']=async(req, {logger})=>{// In a real application, this would be a database call// e.g., const pets = await db.pets.findMany()constpets=TSStore.list()logger.info('Retrieved all pets', { count: pets.length})return{ status:200, body: pets }}
import{ ApiRouteConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:ApiRouteConfig={name:'GetPets',type:'api',path:'/pets',method:'GET',flows: ['PetManagement'],}exportconsthandler:Handlers['GetPets']=async(req, {logger})=>{// In a real application, this would be a database call// e.g., const pets = await db.pets.findMany()constpets=TSStore.list()logger.info('Retrieved all pets', { count: pets.length})return{ status:200, body: pets }}
Testing List All Pets
Test with curl:
# List all petscurlhttp://localhost:3000/pets
# List all petscurlhttp://localhost:3000/pets
Or use the Workbench interface:
Get Single Pet
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:ApiRouteConfig={name:'GetPet',type:'api',path:'/pets/:id',method:'GET',flows: ['PetManagement'],}exportconsthandler:Handlers['GetPet']=async(req, {logger})=>{// In a real application, this would be a database call// e.g., const pet = await db.pets.findById(req.pathParams.id)constpet=TSStore.get(req.pathParams.id)if(!pet) {logger.warn('Pet not found', { id: req.pathParams.id })return{ status:404, body: { message:'Pet not found'} }}return{ status:200, body: pet }}
import{ ApiRouteConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:ApiRouteConfig={name:'GetPet',type:'api',path:'/pets/:id',method:'GET',flows: ['PetManagement'],}exportconsthandler:Handlers['GetPet']=async(req, {logger})=>{// In a real application, this would be a database call// e.g., const pet = await db.pets.findById(req.pathParams.id)constpet=TSStore.get(req.pathParams.id)if(!pet) {logger.warn('Pet not found', { id: req.pathParams.id })return{ status:404, body: { message:'Pet not found'} }}return{ status:200, body: pet }}
Testing tip:When testing GET endpoints with path parameters like/pets/:id, switch to theParamstab (not Body) to enter the ID value.
/pets/:id
The:idin the path creates a path parameter accessible viareq.pathParams.id.
:id
req.pathParams.id
Testing Get Single Pet
Test with curl:
# Get specific pet (replace 1 with an actual pet ID)curlhttp://localhost:3000/pets/1
# Get specific pet (replace 1 with an actual pet ID)curlhttp://localhost:3000/pets/1
Or use the Workbench interface:
Adding UPDATE Endpoint
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constupdatePetSchema=z.object({name: z.string().min(1).optional(),status: z.enum(['available','pending','adopted']).optional(),ageMonths: z.number().int().min(0).optional(),})exportconstconfig:ApiRouteConfig={name:'UpdatePet',type:'api',path:'/pets/:id',method:'PUT',bodySchema: updatePetSchema,flows: ['PetManagement'],}exportconsthandler:Handlers['UpdatePet']=async(req, {logger})=>{constupdates=updatePetSchema.parse(req.body)// In a real application, this would be a database call// e.g., const pet = await db.pets.update(req.pathParams.id, updates)constpet=TSStore.update(req.pathParams.id, updates)if(!pet) {return{ status:404, body: { message:'Pet not found'} }}logger.info('Pet updated', { petId: pet.id })return{ status:200, body: pet }}
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constupdatePetSchema=z.object({name: z.string().min(1).optional(),status: z.enum(['available','pending','adopted']).optional(),ageMonths: z.number().int().min(0).optional(),})exportconstconfig:ApiRouteConfig={name:'UpdatePet',type:'api',path:'/pets/:id',method:'PUT',bodySchema: updatePetSchema,flows: ['PetManagement'],}exportconsthandler:Handlers['UpdatePet']=async(req, {logger})=>{constupdates=updatePetSchema.parse(req.body)// In a real application, this would be a database call// e.g., const pet = await db.pets.update(req.pathParams.id, updates)constpet=TSStore.update(req.pathParams.id, updates)if(!pet) {return{ status:404, body: { message:'Pet not found'} }}logger.info('Pet updated', { petId: pet.id })return{ status:200, body: pet }}
Testing Update Pet
Test with curl:
# Update a pet (replace 1 with an actual pet ID)curl-XPUThttp://localhost:3000/pets/1\-H"Content-Type: application/json"\-d'{"status": "adopted"}'
# Update a pet (replace 1 with an actual pet ID)curl-XPUThttp://localhost:3000/pets/1\-H"Content-Type: application/json"\-d'{"status": "adopted"}'
Or use the Workbench interface:
Adding DELETE Endpoint
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:ApiRouteConfig={name:'DeletePet',type:'api',path:'/pets/:id',method:'DELETE',flows: ['PetManagement'],}exportconsthandler:Handlers['DeletePet']=async(req, {logger})=>{// In a real application, this would be a database call// e.g., const deleted = await db.pets.delete(req.pathParams.id)constdeleted=TSStore.remove(req.pathParams.id)if(!deleted) {return{ status:404, body: { message:'Pet not found'} }}logger.info('Pet deleted', { petId: req.pathParams.id })return{ status:204}}
import{ ApiRouteConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:ApiRouteConfig={name:'DeletePet',type:'api',path:'/pets/:id',method:'DELETE',flows: ['PetManagement'],}exportconsthandler:Handlers['DeletePet']=async(req, {logger})=>{// In a real application, this would be a database call// e.g., const deleted = await db.pets.delete(req.pathParams.id)constdeleted=TSStore.remove(req.pathParams.id)if(!deleted) {return{ status:404, body: { message:'Pet not found'} }}logger.info('Pet deleted', { petId: req.pathParams.id })return{ status:204}}
DELETE endpoints return204 No Contenton success.
204 No Content
Testing Delete Pet
Test with curl:
# Delete a pet (replace 1 with an actual pet ID)curl-XDELETEhttp://localhost:3000/pets/1
# Delete a pet (replace 1 with an actual pet ID)curl-XDELETEhttp://localhost:3000/pets/1
Or use the Workbench interface:
As you can see in this example, Motia handles routing, validation, and error handling automatically. With just a few lines of code, you've built a complete REST API with:
Automatic routingbased on your step configuration
Path parameter extraction(/pets/:id→req.pathParams.id)
/pets/:id
req.pathParams.id
HTTP method handling(GET, POST, PUT, DELETE)
Response formattingwith proper status codes
Built-in error handlingand validation
🎉Congratulations!You've successfully created your first API endpoints with Motia. Your pet store API is now ready to handle all CRUD operations.
What's Next?
You now have a working REST API for your pet store! But a complete backend system needs more than just API endpoints. In the next guide, we'll add background jobs using Event Steps and scheduled tasks with Cron Steps to handle tasks like:
SetNextFeedingReminder- Queue jobs that automatically schedule feeding reminders when pets are added or updated
Deletion Reaper- Cron jobs that run daily to clean up soft-deleted records and expired data
Let's continue building your complete backend system by adding these background jobs with Event Steps and scheduled tasks with Cron Steps.
Build Your First Motia App
Learn Motia step-by-step by building a real pet store backend
Background Jobs
Learn how to create async background jobs and scheduled tasks with Motia
On this page



===== https://www.motia.dev/docs/getting-started/build-your-first-motia-app/background-jobs =====

Background Jobs
Learn how to create async background jobs and scheduled tasks with Motia
What You'll Build
A pet management system with background jobs that handle:
Event Step- Async job that sets feeding reminders when pets are created
Cron Step- Scheduled job that runs daily to clean up deleted pets
Getting Started
Clone the example repository:
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutbackground-jobs
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutbackground-jobs
Install dependencies:
npminstall
npminstall
Start the Workbench:
npmrundev
npmrundev
Your Workbench will be available athttp://localhost:3000.
http://localhost:3000
Project Structure
Files likefeatures.jsonandtutorial.tsxare only for the interactive tutorial and are not part of Motia's project structure.
features.json
tutorial.tsx
All code examples in this guide are available in thebuild-your-first-apprepository.
You can follow this guide to learn how to build background jobs with Motia step by step, or you can clone the repository and dive into our Interactive Tutorial to learn by doing directly in the Workbench.
Understanding Background Jobs
Background jobs let you handle time-consuming tasks without blocking your API responses. When a user creates a pet, they get an immediate response while tasks like sending emails or processing data happen in the background.
Motia provides two types of background jobs:
Event Steps- Triggered by events from your API endpoints
Cron Steps- Run on a schedule (like daily cleanup tasks)
Creating Your First Event Step
Let's create a background job that sets feeding reminders when a pet is created. First, we need to emit an event from our API endpoint.
Step 1: Emit Events from API
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constcreatePetSchema=z.object({name: z.string().min(1,'Name is required').trim(),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0,'Age must be a positive number')})exportconstconfig:ApiRouteConfig={type:'api',name:'TsCreatePet',path:'/ts/pets',method:'POST',// Declare what events this endpoint can emitemits: ['ts.feeding.reminder.enqueued'],flows: ['TsPetManagement'],bodySchema: createPetSchema}exportconsthandler:Handlers['TsCreatePet']=async(req, {emit,logger})=>{try{constvalidatedData=createPetSchema.parse(req.body)constpet=TSStore.create({name: validatedData.name,species: validatedData.species,ageMonths: validatedData.ageMonths})if(logger) {logger.info('🐾 Pet created', {petId: pet.id,name: pet.name,species: pet.species,status: pet.status})}// Emit event to trigger background jobif(emit) {awaitemit({topic:'ts.feeding.reminder.enqueued',data: {petId: pet.id,enqueuedAt: Date.now()}})}return{ status:201, body: pet }}catch(error) {if(errorinstanceofz.ZodError) {return{status:400,body: {message:'Validation error',errors: error.errors}}}if(logger) {logger.error('❌ Pet creation failed', {error: errorinstanceofError?error.message:'Unknown error'})}return{status:500,body: { message:'Internal server error'}}}}
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constcreatePetSchema=z.object({name: z.string().min(1,'Name is required').trim(),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0,'Age must be a positive number')})exportconstconfig:ApiRouteConfig={type:'api',name:'TsCreatePet',path:'/ts/pets',method:'POST',// Declare what events this endpoint can emitemits: ['ts.feeding.reminder.enqueued'],flows: ['TsPetManagement'],bodySchema: createPetSchema}exportconsthandler:Handlers['TsCreatePet']=async(req, {emit,logger})=>{try{constvalidatedData=createPetSchema.parse(req.body)constpet=TSStore.create({name: validatedData.name,species: validatedData.species,ageMonths: validatedData.ageMonths})if(logger) {logger.info('🐾 Pet created', {petId: pet.id,name: pet.name,species: pet.species,status: pet.status})}// Emit event to trigger background jobif(emit) {awaitemit({topic:'ts.feeding.reminder.enqueued',data: {petId: pet.id,enqueuedAt: Date.now()}})}return{ status:201, body: pet }}catch(error) {if(errorinstanceofz.ZodError) {return{status:400,body: {message:'Validation error',errors: error.errors}}}if(logger) {logger.error('❌ Pet creation failed', {error: errorinstanceofError?error.message:'Unknown error'})}return{status:500,body: { message:'Internal server error'}}}}
The API endpoint now emits an event after creating a pet. The response returns immediately while the background job processes asynchronously.
Step 2: Create the Event Step
Now let's create the background job that listens for this event and sets feeding reminders.
View on GitHub:
TypeScript
Python
JavaScript
import{ EventConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig={type:'event',name:'TsSetNextFeedingReminder',description:'Background job that sets next feeding reminder and adds welcome notes',// Subscribe to the event emitted by CreatePetsubscribes: ['ts.feeding.reminder.enqueued'],emits: [],flows: ['TsPetManagement']}exportconsthandler:Handlers['TsSetNextFeedingReminder']=async(input, {emit,logger})=>{const{petId,enqueuedAt}=inputif(logger) {logger.info('🔄 Setting next feeding reminder', { petId, enqueuedAt })}try{// Calculate next feeding time (24 hours from now)constnextFeedingAt=Date.now()+(24*60*60*1000)// Fill in non-critical detailsconstupdates={notes:'Welcome to our pet store! We\'ll take great care of this pet.',nextFeedingAt: nextFeedingAt}constupdatedPet=TSStore.update(petId, updates)if(!updatedPet) {if(logger) {logger.error('❌ Failed to set feeding reminder - pet not found', { petId })}return}if(logger) {logger.info('✅ Next feeding reminder set', {petId,notes: updatedPet.notes?.substring(0,50)+'...',nextFeedingAt:newDate(nextFeedingAt).toISOString()})}// Feeding reminder scheduled successfully}catch(error:any) {if(logger) {logger.error('❌ Feeding reminder job error', { petId, error: error.message })}}}
import{ EventConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig={type:'event',name:'TsSetNextFeedingReminder',description:'Background job that sets next feeding reminder and adds welcome notes',// Subscribe to the event emitted by CreatePetsubscribes: ['ts.feeding.reminder.enqueued'],emits: [],flows: ['TsPetManagement']}exportconsthandler:Handlers['TsSetNextFeedingReminder']=async(input, {emit,logger})=>{const{petId,enqueuedAt}=inputif(logger) {logger.info('🔄 Setting next feeding reminder', { petId, enqueuedAt })}try{// Calculate next feeding time (24 hours from now)constnextFeedingAt=Date.now()+(24*60*60*1000)// Fill in non-critical detailsconstupdates={notes:'Welcome to our pet store! We\'ll take great care of this pet.',nextFeedingAt: nextFeedingAt}constupdatedPet=TSStore.update(petId, updates)if(!updatedPet) {if(logger) {logger.error('❌ Failed to set feeding reminder - pet not found', { petId })}return}if(logger) {logger.info('✅ Next feeding reminder set', {petId,notes: updatedPet.notes?.substring(0,50)+'...',nextFeedingAt:newDate(nextFeedingAt).toISOString()})}// Feeding reminder scheduled successfully}catch(error:any) {if(logger) {logger.error('❌ Feeding reminder job error', { petId, error: error.message })}}}
How Event Steps Work
Event Steps have a few key differences from API Steps:
typeis set to'event'instead of'api'
'event'
'api'
subscribeslists the events this job listens for
handlerreceives the event data as the first argument
When you create a pet, the API returns immediately. The background job picks up the event and processes it asynchronously.
Testing Your Background Job
Create a pet and watch the background job execute:
# Create a petcurl-XPOSThttp://localhost:3000/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
# Create a petcurl-XPOSThttp://localhost:3000/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
Check the logs in Workbench to see both the API call and the background job execution:
You'll see:
"Pet created" log from the API endpoint
"Setting next feeding reminder" log from the background job
"Next feeding reminder set" log when the job completes
Creating a Scheduled Cron Job
Now let's create a cron job that runs daily to clean up soft-deleted pets. This demonstrates how to handle scheduled maintenance tasks.
View on GitHub:
TypeScript
Python
JavaScript
import{ CronConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:CronConfig={type:'cron',name:'TsDeletionReaper',description:'Daily job that permanently removes pets scheduled for deletion',cron:'0 2 * * *',// Daily at 2:00 AMemits: [],flows: ['TsPetManagement']}exportconsthandler:Handlers['TsDeletionReaper']=async({emit,logger})=>{if(logger) {logger.info('🔄 Deletion Reaper started - scanning for pets to purge')}try{constpetsToReap=TSStore.findDeletedPetsReadyToPurge()if(petsToReap.length===0) {if(logger) {logger.info('✅ Deletion Reaper completed - no pets to purge')}// No emit - no subscribers for ts.reaper.completedreturn}letpurgedCount=0for(constpetofpetsToReap) {constsuccess=TSStore.remove(pet.id)if(success) {purgedCount++if(logger) {logger.info('💀 Pet permanently purged', {petId: pet.id,name: pet.name,deletedAt:newDate(pet.deletedAt!).toISOString(),purgeAt:newDate(pet.purgeAt!).toISOString()})}// No emit - no subscribers for ts.pet.purged}else{if(logger) {logger.warn('⚠️ Failed to purge pet', { petId: pet.id, name: pet.name })}}}if(logger) {logger.info('✅ Deletion Reaper completed', {totalScanned: petsToReap.length,purgedCount,failedCount: petsToReap.length-purgedCount})}// No emit - no subscribers for ts.reaper.completed}catch(error:any) {if(logger) {logger.error('❌ Deletion Reaper error', { error: error.message })}}}
import{ CronConfig, Handlers }from'motia'import{ TSStore }from'./ts-store'exportconstconfig:CronConfig={type:'cron',name:'TsDeletionReaper',description:'Daily job that permanently removes pets scheduled for deletion',cron:'0 2 * * *',// Daily at 2:00 AMemits: [],flows: ['TsPetManagement']}exportconsthandler:Handlers['TsDeletionReaper']=async({emit,logger})=>{if(logger) {logger.info('🔄 Deletion Reaper started - scanning for pets to purge')}try{constpetsToReap=TSStore.findDeletedPetsReadyToPurge()if(petsToReap.length===0) {if(logger) {logger.info('✅ Deletion Reaper completed - no pets to purge')}// No emit - no subscribers for ts.reaper.completedreturn}letpurgedCount=0for(constpetofpetsToReap) {constsuccess=TSStore.remove(pet.id)if(success) {purgedCount++if(logger) {logger.info('💀 Pet permanently purged', {petId: pet.id,name: pet.name,deletedAt:newDate(pet.deletedAt!).toISOString(),purgeAt:newDate(pet.purgeAt!).toISOString()})}// No emit - no subscribers for ts.pet.purged}else{if(logger) {logger.warn('⚠️ Failed to purge pet', { petId: pet.id, name: pet.name })}}}if(logger) {logger.info('✅ Deletion Reaper completed', {totalScanned: petsToReap.length,purgedCount,failedCount: petsToReap.length-purgedCount})}// No emit - no subscribers for ts.reaper.completed}catch(error:any) {if(logger) {logger.error('❌ Deletion Reaper error', { error: error.message })}}}
Understanding Cron Steps
Cron Steps run on a schedule defined by a cron expression:
typeis set to'cron'
'cron'
crondefines when the job runs (e.g.,'0 2 * * *'= daily at 2 AM)
'0 2 * * *'
handlerreceives only the context (no input data like Event Steps)
Common cron patterns:
'*/5 * * * *'- Every 5 minutes
'*/5 * * * *'
'0 * * * *'- Every hour
'0 * * * *'
'0 0 * * *'- Daily at midnight
'0 0 * * *'
'0 9 * * 1'- Every Monday at 9 AM
'0 9 * * 1'
Monitoring Background Jobs
Workbench provides tools to monitor your background jobs:
Tracing
See the complete execution flow from API call to background job:
Each trace shows:
When the API endpoint was called
When events were emitted
When background jobs started and completed
Total processing time
🎉Congratulations!You've successfully created background jobs with Motia. Your pet store now handles async tasks efficiently without blocking API responses.
What's Next?
You now have a complete backend system with API endpoints and background jobs! But there's more power in Motia when you combine everything into workflows.
In the next guide, we'll build completeworkflow orchestrationsthat connect multiple Steps together:
Queue-Based Job Processing- SetNextFeedingReminder triggered by pet creation, processing asynchronously without blocking API responses
Scheduled Maintenance Tasks- Deletion Reaper running daily at 2 AM to permanently remove soft-deleted pets past their purge date
Pet Lifecycle Orchestration- Staff-driven workflow managing pet status transitions from creation through quarantine, health checks, and adoption
Event-Driven State Management- Centralized orchestrator ensuring consistent pet status changes with automatic progressions and staff decision points
Let's continue building by creating workflows that orchestrate your APIs and background jobs into powerful, event-driven systems.
API Endpoints
Learn how to create HTTP API endpoints with Motia
Workflows
Learn how to build automated workflows that manage complex business logic with Motia
On this page



===== https://www.motia.dev/docs/getting-started/build-your-first-motia-app/workflows =====

Workflows
Learn how to build automated workflows that manage complex business logic with Motia
What You'll Build
A pet lifecycle management system that automatically guides pets through their journey at your shelter:
Automated Status Transitions- Pets move through stages automatically when conditions are met
Staff Decision Points- Critical checkpoints where staff make the calls
Smart Progressions- Some transitions trigger follow-up actions automatically
Validation Rules- Prevents invalid status changes to keep data consistent
Getting Started
Clone the example repository:
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutworkflow-orchestration
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutworkflow-orchestration
Install dependencies:
npminstall
npminstall
Start the Workbench:
npmrundev
npmrundev
Your Workbench will be available athttp://localhost:3000.
http://localhost:3000
Project Structure
Files likefeatures.jsonandtutorial.tsxare only for the interactive tutorial and are not part of Motia's project structure.
features.json
tutorial.tsx
All code examples in this guide are available in thebuild-your-first-apprepository.
You can follow this guide to learn how to build workflow orchestration with Motia step by step, or you can clone the repository and dive into our Interactive Tutorial to learn by doing directly in the Workbench.
Understanding Workflows
So far, you've built API endpoints that respond to requests and background jobs that handle async tasks. But what about coordinating complex business processes that involve multiple steps and decision points?
That's where workflows come in. It's the conductor of your system - making sure things happen in the right order, at the right time, and only when it makes sense.
In our pet shelter example, a pet goes through many stages:
New arrivals need health checks
Healthy pets become available for adoption
Sick pets need treatment before they're ready
Adoption applications require staff approval
A workflow manages all these transitions, enforcing the rules and keeping everything consistent.
The Pet Lifecycle Journey
When you create a pet, it starts asnew. Once the feeding reminder job completes, it automatically moves toin_quarantine. Staff then checks on it and marks ithealthy, which automatically progresses toavailable. When someone wants to adopt, it goespending, then finallyadopted.
new
in_quarantine
healthy
available
pending
adopted
The key here is some transitions happen automatically (likehealthy→available), while others need staff approval (likein_quarantine→healthy).
healthy
available
in_quarantine
healthy
What about sick pets?
If staff finds a pet isill, it automatically moves tounder_treatment. When staff marks itrecovered, it chains through automatic transitions:recovered→healthy→available.
ill
under_treatment
recovered
recovered
healthy
available
This mix of automatic progressions and human decision points is what makes workflows powerful - the system handles the routine stuff while keeping people in control of important calls.
Creating the Workflow
The workflow orchestrator is a single Event Step that manages all pet lifecycle transitions. Here's the complete implementation:
View on GitHub:
TypeScript
Python
JavaScript
// steps/typescript/pet-lifecycle-orchestrator.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore, Pet }from'./ts-store';typeLifecycleEvent=|'pet.created'|'feeding.reminder.completed'|'status.update.requested';typeTransitionRule={from:Pet["status"][];to:Pet["status"];event:LifecycleEvent;description:string;};constTRANSITION_RULES:TransitionRule[]=[{from: ["new"],to:"in_quarantine",event:"feeding.reminder.completed",description:"Pet moved to quarantine after feeding setup"},{from: ["in_quarantine"],to:"healthy",event:"status.update.requested",description:"Staff health check - pet cleared from quarantine"},{from: ["healthy","in_quarantine","available"],to:"ill",event:"status.update.requested",description:"Staff assessment - pet identified as ill"},{from: ["healthy"],to:"available",event:"status.update.requested",description:"Staff decision - pet ready for adoption"},{from: ["ill"],to:"under_treatment",event:"status.update.requested",description:"Staff decision - treatment started"},{from: ["under_treatment"],to:"recovered",event:"status.update.requested",description:"Staff assessment - treatment completed"},{from: ["recovered"],to:"healthy",event:"status.update.requested",description:"Staff clearance - pet fully recovered"},{from: ["available"],to:"pending",event:"status.update.requested",description:"Adoption application received"},{from: ["pending"],to:"adopted",event:"status.update.requested",description:"Adoption completed"},{from: ["pending"],to:"available",event:"status.update.requested",description:"Adoption application rejected/cancelled"}];exportconstconfig={type:'event',name:'TsPetLifecycleOrchestrator',description:'Pet lifecycle state management with staff interaction points',subscribes: ['ts.pet.created','ts.feeding.reminder.completed','ts.pet.status.update.requested'],emits: [],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsPetLifecycleOrchestrator']=async(input, {emit,logger})=>{const{petId,event:eventType,requestedStatus,automatic}=input;if(logger) {constlogMessage=automatic?'🤖 Automatic progression':'🔄 Lifecycle orchestrator processing';logger.info(logMessage, { petId, eventType, requestedStatus, automatic });}try{constpet=TSStore.get(petId);if(!pet) {if(logger) {logger.error('❌ Pet not found for lifecycle transition', { petId, eventType });}return;}// For status update requests, find the rule based on requested statusletrule;if(eventType==='status.update.requested'&&requestedStatus) {rule=TRANSITION_RULES.find(r=>r.event===eventType&&r.from.includes(pet.status)&&r.to===requestedStatus);}else{// For other events (like feeding.reminder.completed)rule=TRANSITION_RULES.find(r=>r.event===eventType&&r.from.includes(pet.status));}if(!rule) {constreason=eventType==='status.update.requested'?`Invalid transition: cannot change from ${pet.status} to ${requestedStatus}`:`No transition rule found for ${eventType} from ${pet.status}`;if(logger) {logger.warn('⚠️ Transition rejected', {petId,currentStatus: pet.status,requestedStatus,eventType,reason});}// Transition rejected - no event emission neededreturn;}// Check for idempotencyif(pet.status===rule.to) {if(logger) {logger.info('✅ Already in target status', {petId,status: pet.status,eventType});}return;}// Apply the transitionconstoldStatus=pet.status;constupdatedPet=TSStore.updateStatus(petId, rule.to);if(!updatedPet) {if(logger) {logger.error('❌ Failed to update pet status', { petId, oldStatus, newStatus: rule.to });}return;}if(logger) {logger.info('✅ Lifecycle transition completed', {petId,oldStatus,newStatus: rule.to,eventType,description: rule.description,timestamp: Date.now()});}// Transition completed successfullyif(logger) {logger.info('✅ Pet status transition completed', {petId,oldStatus,newStatus: rule.to,eventType,description: rule.description});}// Check for automatic progressions after successful transitionawaitprocessAutomaticProgression(petId, rule.to, emit, logger);}catch(error:any) {if(logger) {logger.error('❌ Lifecycle orchestrator error', { petId, eventType, error: error.message });}}};asyncfunctionprocessAutomaticProgression(petId:string,currentStatus:Pet["status"],emit:any,logger:any) {// Define automatic progressionsconstautomaticProgressions:Partial<Record<Pet["status"], {to:Pet["status"],description:string}>>={'healthy': { to:'available', description:'Automatic progression - pet ready for adoption'},'ill': { to:'under_treatment', description:'Automatic progression - treatment started'},'recovered': { to:'healthy', description:'Automatic progression - recovery complete'}};constprogression=automaticProgressions[currentStatus];if(progression) {if(logger) {logger.info('🤖 Processing automatic progression', {petId,currentStatus,nextStatus: progression.to});}// Find the transition rule for automatic progressionconstrule=TRANSITION_RULES.find(r=>r.event==='status.update.requested'&&r.from.includes(currentStatus)&&r.to===progression.to);if(rule) {// Apply the automatic transition immediatelyconstoldStatus=currentStatus;constupdatedPet=TSStore.updateStatus(petId, rule.to);if(updatedPet) {if(logger) {logger.info('✅ Automatic progression completed', {petId,oldStatus,newStatus: rule.to,description: progression.description,timestamp: Date.now()});}// Automatic progression completed successfullyif(logger) {logger.info('✅ Automatic progression completed', {petId,oldStatus,newStatus: rule.to,description: progression.description});}// Check for further automatic progressions (for chaining like recovered → healthy → available)awaitprocessAutomaticProgression(petId, rule.to, emit, logger);}elseif(logger) {logger.error('❌ Failed to apply automatic progression', { petId, oldStatus, newStatus: rule.to });}}elseif(logger) {logger.warn('⚠️ No transition rule found for automatic progression', {petId,currentStatus,targetStatus: progression.to});}}}
// steps/typescript/pet-lifecycle-orchestrator.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore, Pet }from'./ts-store';typeLifecycleEvent=|'pet.created'|'feeding.reminder.completed'|'status.update.requested';typeTransitionRule={from:Pet["status"][];to:Pet["status"];event:LifecycleEvent;description:string;};constTRANSITION_RULES:TransitionRule[]=[{from: ["new"],to:"in_quarantine",event:"feeding.reminder.completed",description:"Pet moved to quarantine after feeding setup"},{from: ["in_quarantine"],to:"healthy",event:"status.update.requested",description:"Staff health check - pet cleared from quarantine"},{from: ["healthy","in_quarantine","available"],to:"ill",event:"status.update.requested",description:"Staff assessment - pet identified as ill"},{from: ["healthy"],to:"available",event:"status.update.requested",description:"Staff decision - pet ready for adoption"},{from: ["ill"],to:"under_treatment",event:"status.update.requested",description:"Staff decision - treatment started"},{from: ["under_treatment"],to:"recovered",event:"status.update.requested",description:"Staff assessment - treatment completed"},{from: ["recovered"],to:"healthy",event:"status.update.requested",description:"Staff clearance - pet fully recovered"},{from: ["available"],to:"pending",event:"status.update.requested",description:"Adoption application received"},{from: ["pending"],to:"adopted",event:"status.update.requested",description:"Adoption completed"},{from: ["pending"],to:"available",event:"status.update.requested",description:"Adoption application rejected/cancelled"}];exportconstconfig={type:'event',name:'TsPetLifecycleOrchestrator',description:'Pet lifecycle state management with staff interaction points',subscribes: ['ts.pet.created','ts.feeding.reminder.completed','ts.pet.status.update.requested'],emits: [],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsPetLifecycleOrchestrator']=async(input, {emit,logger})=>{const{petId,event:eventType,requestedStatus,automatic}=input;if(logger) {constlogMessage=automatic?'🤖 Automatic progression':'🔄 Lifecycle orchestrator processing';logger.info(logMessage, { petId, eventType, requestedStatus, automatic });}try{constpet=TSStore.get(petId);if(!pet) {if(logger) {logger.error('❌ Pet not found for lifecycle transition', { petId, eventType });}return;}// For status update requests, find the rule based on requested statusletrule;if(eventType==='status.update.requested'&&requestedStatus) {rule=TRANSITION_RULES.find(r=>r.event===eventType&&r.from.includes(pet.status)&&r.to===requestedStatus);}else{// For other events (like feeding.reminder.completed)rule=TRANSITION_RULES.find(r=>r.event===eventType&&r.from.includes(pet.status));}if(!rule) {constreason=eventType==='status.update.requested'?`Invalid transition: cannot change from ${pet.status} to ${requestedStatus}`:`No transition rule found for ${eventType} from ${pet.status}`;if(logger) {logger.warn('⚠️ Transition rejected', {petId,currentStatus: pet.status,requestedStatus,eventType,reason});}// Transition rejected - no event emission neededreturn;}// Check for idempotencyif(pet.status===rule.to) {if(logger) {logger.info('✅ Already in target status', {petId,status: pet.status,eventType});}return;}// Apply the transitionconstoldStatus=pet.status;constupdatedPet=TSStore.updateStatus(petId, rule.to);if(!updatedPet) {if(logger) {logger.error('❌ Failed to update pet status', { petId, oldStatus, newStatus: rule.to });}return;}if(logger) {logger.info('✅ Lifecycle transition completed', {petId,oldStatus,newStatus: rule.to,eventType,description: rule.description,timestamp: Date.now()});}// Transition completed successfullyif(logger) {logger.info('✅ Pet status transition completed', {petId,oldStatus,newStatus: rule.to,eventType,description: rule.description});}// Check for automatic progressions after successful transitionawaitprocessAutomaticProgression(petId, rule.to, emit, logger);}catch(error:any) {if(logger) {logger.error('❌ Lifecycle orchestrator error', { petId, eventType, error: error.message });}}};asyncfunctionprocessAutomaticProgression(petId:string,currentStatus:Pet["status"],emit:any,logger:any) {// Define automatic progressionsconstautomaticProgressions:Partial<Record<Pet["status"], {to:Pet["status"],description:string}>>={'healthy': { to:'available', description:'Automatic progression - pet ready for adoption'},'ill': { to:'under_treatment', description:'Automatic progression - treatment started'},'recovered': { to:'healthy', description:'Automatic progression - recovery complete'}};constprogression=automaticProgressions[currentStatus];if(progression) {if(logger) {logger.info('🤖 Processing automatic progression', {petId,currentStatus,nextStatus: progression.to});}// Find the transition rule for automatic progressionconstrule=TRANSITION_RULES.find(r=>r.event==='status.update.requested'&&r.from.includes(currentStatus)&&r.to===progression.to);if(rule) {// Apply the automatic transition immediatelyconstoldStatus=currentStatus;constupdatedPet=TSStore.updateStatus(petId, rule.to);if(updatedPet) {if(logger) {logger.info('✅ Automatic progression completed', {petId,oldStatus,newStatus: rule.to,description: progression.description,timestamp: Date.now()});}// Automatic progression completed successfullyif(logger) {logger.info('✅ Automatic progression completed', {petId,oldStatus,newStatus: rule.to,description: progression.description});}// Check for further automatic progressions (for chaining like recovered → healthy → available)awaitprocessAutomaticProgression(petId, rule.to, emit, logger);}elseif(logger) {logger.error('❌ Failed to apply automatic progression', { petId, oldStatus, newStatus: rule.to });}}elseif(logger) {logger.warn('⚠️ No transition rule found for automatic progression', {petId,currentStatus,targetStatus: progression.to});}}}
How the Orchestrator Works
The orchestrator has three main responsibilities:
Validate Transitions- Ensures pets can only move to valid next statuses
Apply Transitions- Updates the pet's status in the store
Trigger Automatic Progressions- Some statuses automatically progress to the next stage
Key Points:
emits: []- The orchestrator doesn't declare emits because it only manages state internally
emits: []
JavaScript/Python emit events for workflow tracking (optional pattern)
TypeScript focuses purely on state management
All languages validate transitions using the sameTRANSITION_RULES
TRANSITION_RULES
Testing Your Orchestrator
The best way to test your orchestrator is throughWorkbench. It lets you send requests, watch the workflow execute in real-time, and see all the logs in one place.
Create a Pet
Open Workbench and test the CreatePet endpoint:
You'll see in the logs:
🐾 Pet created { petId: '1', name: 'Max', species: 'dog', status: 'new' }🔄 Setting next feeding reminder { petId: '1' }✅ Next feeding reminder set { petId: '1' }🔄 Lifecycle orchestrator processing { petId: '1', eventType: 'feeding.reminder.completed' }✅ Lifecycle transition completed { oldStatus: 'new', newStatus: 'in_quarantine' }
🐾 Pet created { petId: '1', name: 'Max', species: 'dog', status: 'new' }🔄 Setting next feeding reminder { petId: '1' }✅ Next feeding reminder set { petId: '1' }🔄 Lifecycle orchestrator processing { petId: '1', eventType: 'feeding.reminder.completed' }✅ Lifecycle transition completed { oldStatus: 'new', newStatus: 'in_quarantine' }
Prefer using curl?You can also test with command line:
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
Staff Health Check
Test the UpdatePet endpoint in Workbench to mark the pet as healthy:
Watch the automatic progression:
👤 Staff requesting status change { petId: '1', requestedStatus: 'healthy' }🔄 Lifecycle orchestrator processing { petId: '1', eventType: 'status.update.requested' }✅ Lifecycle transition completed { oldStatus: 'in_quarantine', newStatus: 'healthy' }🤖 Processing automatic progression { petId: '1', currentStatus: 'healthy', nextStatus: 'available' }✅ Automatic progression completed { oldStatus: 'healthy', newStatus: 'available' }
👤 Staff requesting status change { petId: '1', requestedStatus: 'healthy' }🔄 Lifecycle orchestrator processing { petId: '1', eventType: 'status.update.requested' }✅ Lifecycle transition completed { oldStatus: 'in_quarantine', newStatus: 'healthy' }🤖 Processing automatic progression { petId: '1', currentStatus: 'healthy', nextStatus: 'available' }✅ Automatic progression completed { oldStatus: 'healthy', newStatus: 'available' }
Using curl?
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "healthy"}'
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "healthy"}'
Test Invalid Transitions
Try to skip a step in Workbench:
The orchestrator rejects it:
⚠️ Transition rejected {currentStatus: 'in_quarantine',requestedStatus: 'available',reason: 'Invalid transition: cannot change from in_quarantine to available'}
⚠️ Transition rejected {currentStatus: 'in_quarantine',requestedStatus: 'available',reason: 'Invalid transition: cannot change from in_quarantine to available'}
Using curl?
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "available"}'
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "available"}'
Test the Illness Workflow
Mark a pet as ill in Workbench:
Watch the automatic treatment start:
✅ Lifecycle transition completed { oldStatus: 'healthy', newStatus: 'ill' }🤖 Processing automatic progression { currentStatus: 'ill', nextStatus: 'under_treatment' }✅ Automatic progression completed { oldStatus: 'ill', newStatus: 'under_treatment' }
✅ Lifecycle transition completed { oldStatus: 'healthy', newStatus: 'ill' }🤖 Processing automatic progression { currentStatus: 'ill', nextStatus: 'under_treatment' }✅ Automatic progression completed { oldStatus: 'ill', newStatus: 'under_treatment' }
Using curl?
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "ill"}'
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "ill"}'
Then mark the pet as recovered in Workbench:
Watch the chained automatic progressions:
✅ Lifecycle transition completed { oldStatus: 'under_treatment', newStatus: 'recovered' }🤖 Processing automatic progression { currentStatus: 'recovered', nextStatus: 'healthy' }✅ Automatic progression completed { oldStatus: 'recovered', newStatus: 'healthy' }🤖 Processing automatic progression { currentStatus: 'healthy', nextStatus: 'available' }✅ Automatic progression completed { oldStatus: 'healthy', newStatus: 'available' }
✅ Lifecycle transition completed { oldStatus: 'under_treatment', newStatus: 'recovered' }🤖 Processing automatic progression { currentStatus: 'recovered', nextStatus: 'healthy' }✅ Automatic progression completed { oldStatus: 'recovered', newStatus: 'healthy' }🤖 Processing automatic progression { currentStatus: 'healthy', nextStatus: 'available' }✅ Automatic progression completed { oldStatus: 'healthy', newStatus: 'available' }
Using curl?
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "recovered"}'
curl-XPUThttp://localhost:3000/ts/pets/1\-H"Content-Type: application/json"\-d'{"status": "recovered"}'
Monitoring Your Orchestrator
Use the Workbench to visualize the entire flow:
Tracing
See how events flow through your system:
Each trace shows:
The initial API call
Background job processing
Orchestrator transitions
Automatic progressions
Total time for each step
Logs
Filter by pet ID to see the complete lifecycle:
The logs tell the story of each pet's journey through your shelter.
🎉Congratulations!You've built a complete workflow orchestrator that manages complex business logic while keeping your code clean and maintainable.
What's Next?
Your pet shelter now has a complete backend system with workflow orchestration! But what about decisions that aren't black and white? Should this pet's symptoms require treatment?
In the next guide, we'll addAgentic Workflowsthat make intelligent decisions within your workflows:
Health Review Agentic Step- Analyzes symptoms and decides if treatment is needed
Adoption Review Agentic Step- Assesses if pets are ready for adoption
AI Profile Enrichment- Automatically generates engaging pet profiles
Agentic Decision Making- AI that chooses which workflow path to take
Let's continue building by adding intelligent decision-making to your workflows.
Background Jobs
Learn how to create async background jobs and scheduled tasks with Motia
Agentic Workflows
Learn how to build intelligent agentic workflows that make decisions and automate workflows with Motia
On this page



===== https://www.motia.dev/docs/getting-started/build-your-first-motia-app/ai-agents =====

Agentic Workflows
Learn how to build intelligent agentic workflows that make decisions and automate workflows with Motia
What You'll Build
An intelligent pet management system with agentic workflows that automate decisions and enrich data:
AI Profile Enrichment- Automatically generates detailed pet profiles using AI
Health Review Agentic Step- Makes intelligent health decisions based on symptoms
Adoption Review Agentic Step- Assesses adoption readiness and data completeness
Orchestrator Integration- AI decisions that drive real workflow changes
Getting Started
Clone the example repository:
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutai-agents
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutai-agents
Install dependencies:
npminstall
npminstall
Set up your OpenAI API key in.env:
.env
OPENAI_API_KEY=your_api_key_here
OPENAI_API_KEY=your_api_key_here
Important!This tutorial requires an OpenAI API key. Get yours atplatform.openai.com/api-keys. Without it, the agentic workflows won't work.
Start the Workbench:
npmrundev
npmrundev
Your Workbench will be available athttp://localhost:3000.
http://localhost:3000
Project Structure
Files likefeatures.jsonandtutorial.tsxare only for the interactive tutorial and are not part of Motia's project structure.
features.json
tutorial.tsx
All code examples in this guide are available in thebuild-your-first-apprepository.
You can follow this guide to learn how to build agentic workflows with Motia step by step, or you can clone the repository and dive into our Interactive Tutorial to learn by doing directly in the Workbench.
Understanding Agentic Workflows
You've built APIs, background jobs, and workflows that orchestrate your pet shelter. But what about decisions that aren't black and white? Should this pet's symptoms require treatment? Is this profile ready for the adoption page?
That's where agentic workflows come in. They're smart assistants that make judgment calls based on context - the kind of decisions that would normally need a human to review every single case.
In our pet shelter, we use two flavors:
Content generatorswrite engaging pet profiles automatically
Decision makersevaluate health symptoms and choose whether treatment is needed
Data reviewersassess if adoption information is complete
The difference from traditional code? Instead of writing hundreds of if-else rules for every possible symptom combination, you describe what matters to the AI. It reads the context and makes an informed call.
When a pet arrives with "coughing, lethargy, loss of appetite" - the AI evaluates these symptoms together and decides if treatment is needed. No hardcoded rules. Just intelligent analysis of the situation.
Creating Your First Agentic Step
Let's start with a content generation agentic step that automatically enriches pet profiles when they're created.
Step 1: Set Up Pet Creation to Emit Events
First, update your pet creation endpoint to emit events that will trigger the agentic step.
View on GitHub:
TypeScript
Python
JavaScript
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constcreatePetSchema=z.object({name: z.string().min(1,'Name is required').trim(),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0,'Age must be a positive number')})exportconstconfig:ApiRouteConfig={type:'api',name:'TsCreatePet',path:'/ts/pets',method:'POST',emits: ['ts.pet.created','ts.feeding.reminder.enqueued'],flows: ['TsPetManagement']}exportconsthandler:Handlers['TsCreatePet']=async(req, {emit,logger})=>{try{constvalidatedData=createPetSchema.parse(req.body)constpet=TSStore.create({name: validatedData.name,species: validatedData.species,ageMonths: validatedData.ageMonths})if(logger) {logger.info('🐾 Pet created', { petId: pet.id, name: pet.name, species: pet.species, status: pet.status })}if(emit) {await(emitasany)({topic:'ts.pet.created',data: { petId: pet.id, event:'pet.created', name: pet.name, species: validatedData.species }})await(emitasany)({topic:'ts.feeding.reminder.enqueued',data: { petId: pet.id, enqueuedAt: Date.now() }})}return{ status:201, body: pet }}catch(error) {if(errorinstanceofz.ZodError) {return{status:400,body: {message:'Validation error',errors: error.errors}}}return{status:500,body: { message:'Internal server error'}}}}
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ TSStore }from'./ts-store'constcreatePetSchema=z.object({name: z.string().min(1,'Name is required').trim(),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0,'Age must be a positive number')})exportconstconfig:ApiRouteConfig={type:'api',name:'TsCreatePet',path:'/ts/pets',method:'POST',emits: ['ts.pet.created','ts.feeding.reminder.enqueued'],flows: ['TsPetManagement']}exportconsthandler:Handlers['TsCreatePet']=async(req, {emit,logger})=>{try{constvalidatedData=createPetSchema.parse(req.body)constpet=TSStore.create({name: validatedData.name,species: validatedData.species,ageMonths: validatedData.ageMonths})if(logger) {logger.info('🐾 Pet created', { petId: pet.id, name: pet.name, species: pet.species, status: pet.status })}if(emit) {await(emitasany)({topic:'ts.pet.created',data: { petId: pet.id, event:'pet.created', name: pet.name, species: validatedData.species }})await(emitasany)({topic:'ts.feeding.reminder.enqueued',data: { petId: pet.id, enqueuedAt: Date.now() }})}return{ status:201, body: pet }}catch(error) {if(errorinstanceofz.ZodError) {return{status:400,body: {message:'Validation error',errors: error.errors}}}return{status:500,body: { message:'Internal server error'}}}}
The API endpoint now emits an event after creating a pet. The response returns immediately while the agentic step processes asynchronously in the background.
Step 2: Create the AI Profile Enrichment Agentic Step
Now let's create the agentic step that listens for new pets and enriches their profiles with AI-generated content.
View on GitHub:
TypeScript
Python
JavaScript
// steps/typescript/ai-profile-enrichment.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore, PetProfile }from'./ts-store';exportconstconfig={type:'event',name:'TsAiProfileEnrichment',description:'Agentic step that enriches pet profiles using OpenAI',subscribes: ['ts.pet.created'],emits: [],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsAiProfileEnrichment']=async(input, {logger})=>{const{petId,name,species}=input;if(logger) {logger.info('🤖 AI Profile Enrichment started', { petId, name, species });}try{constapiKey=process.env.OPENAI_API_KEY;if(!apiKey) {thrownewError('OPENAI_API_KEY environment variable is not set');}constprompt=`Generate a pet profile for adoption purposes. Pet details:- Name: ${name}- Species: ${species}Please provide a JSON response with these fields:- bio: A warm, engaging 2-3 sentence description that would appeal to potential adopters- breedGuess: Your best guess at the breed or breed mix (be specific but realistic)- temperamentTags: An array of 3-5 personality traits (e.g., "friendly", "energetic", "calm")- adopterHints: Practical advice for potential adopters (family type, living situation, care needs)Keep it positive, realistic, and adoption-focused.`;constresponse=awaitfetch('https://api.openai.com/v1/chat/completions', {method:'POST',headers: {'Authorization':`Bearer ${apiKey}`,'Content-Type':'application/json',},body:JSON.stringify({model:'gpt-3.5-turbo',messages: [{role:'system',content:'You are a pet adoption specialist who creates compelling, accurate pet profiles. Always respond with valid JSON only.'},{role:'user',content: prompt}],max_tokens:500,temperature:0.7,}),});if(!response.ok) {thrownewError(`OpenAI API error: ${response.status} ${response.statusText}`);}constdata=awaitresponse.json();constaiResponse=data.choices[0]?.message?.content;if(!aiResponse) {thrownewError('No response from OpenAI API');}letprofile:PetProfile;try{profile=JSON.parse(aiResponse);}catch(parseError) {profile={bio:`${name} is a wonderful ${species} looking for a loving home. This pet has a unique personality and would make a great companion.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','loving','loyal'],adopterHints:`${name} would do well in a caring home with patience and love.`};if(logger) {logger.warn('⚠️ AI response parsing failed, using fallback profile', { petId, parseError: parseErrorinstanceofError?parseError.message:String(parseError) });}}constupdatedPet=TSStore.updateProfile(petId, profile);if(!updatedPet) {thrownewError(`Pet not found: ${petId}`);}if(logger) {logger.info('✅ AI Profile Enrichment completed', {petId,profile: {bio: profile.bio.substring(0,50)+'...',breedGuess: profile.breedGuess,temperamentTags: profile.temperamentTags,adopterHints: profile.adopterHints.substring(0,50)+'...'}});}}catch(error:any) {if(logger) {logger.error('❌ AI Profile Enrichment failed', {petId,error: error.message});}constfallbackProfile:PetProfile={bio:`${name} is a lovely ${species} with a unique personality, ready to find their forever home.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','adaptable'],adopterHints:`${name} is looking for a patient and loving family.`};TSStore.updateProfile(petId, fallbackProfile);}};
// steps/typescript/ai-profile-enrichment.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore, PetProfile }from'./ts-store';exportconstconfig={type:'event',name:'TsAiProfileEnrichment',description:'Agentic step that enriches pet profiles using OpenAI',subscribes: ['ts.pet.created'],emits: [],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsAiProfileEnrichment']=async(input, {logger})=>{const{petId,name,species}=input;if(logger) {logger.info('🤖 AI Profile Enrichment started', { petId, name, species });}try{constapiKey=process.env.OPENAI_API_KEY;if(!apiKey) {thrownewError('OPENAI_API_KEY environment variable is not set');}constprompt=`Generate a pet profile for adoption purposes. Pet details:- Name: ${name}- Species: ${species}Please provide a JSON response with these fields:- bio: A warm, engaging 2-3 sentence description that would appeal to potential adopters- breedGuess: Your best guess at the breed or breed mix (be specific but realistic)- temperamentTags: An array of 3-5 personality traits (e.g., "friendly", "energetic", "calm")- adopterHints: Practical advice for potential adopters (family type, living situation, care needs)Keep it positive, realistic, and adoption-focused.`;constresponse=awaitfetch('https://api.openai.com/v1/chat/completions', {method:'POST',headers: {'Authorization':`Bearer ${apiKey}`,'Content-Type':'application/json',},body:JSON.stringify({model:'gpt-3.5-turbo',messages: [{role:'system',content:'You are a pet adoption specialist who creates compelling, accurate pet profiles. Always respond with valid JSON only.'},{role:'user',content: prompt}],max_tokens:500,temperature:0.7,}),});if(!response.ok) {thrownewError(`OpenAI API error: ${response.status} ${response.statusText}`);}constdata=awaitresponse.json();constaiResponse=data.choices[0]?.message?.content;if(!aiResponse) {thrownewError('No response from OpenAI API');}letprofile:PetProfile;try{profile=JSON.parse(aiResponse);}catch(parseError) {profile={bio:`${name} is a wonderful ${species} looking for a loving home. This pet has a unique personality and would make a great companion.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','loving','loyal'],adopterHints:`${name} would do well in a caring home with patience and love.`};if(logger) {logger.warn('⚠️ AI response parsing failed, using fallback profile', { petId, parseError: parseErrorinstanceofError?parseError.message:String(parseError) });}}constupdatedPet=TSStore.updateProfile(petId, profile);if(!updatedPet) {thrownewError(`Pet not found: ${petId}`);}if(logger) {logger.info('✅ AI Profile Enrichment completed', {petId,profile: {bio: profile.bio.substring(0,50)+'...',breedGuess: profile.breedGuess,temperamentTags: profile.temperamentTags,adopterHints: profile.adopterHints.substring(0,50)+'...'}});}}catch(error:any) {if(logger) {logger.error('❌ AI Profile Enrichment failed', {petId,error: error.message});}constfallbackProfile:PetProfile={bio:`${name} is a lovely ${species} with a unique personality, ready to find their forever home.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','adaptable'],adopterHints:`${name} is looking for a patient and loving family.`};TSStore.updateProfile(petId, fallbackProfile);}};
How This Agentic Step Works
This is acontent generation agentic step- it enriches data without making workflow decisions:
Subscribestopet.createdevents
pet.created
Calls OpenAIwith a carefully crafted prompt
Parses the responseinto structured data
Updates the petwith AI-generated content
Has a fallbackif the AI call fails
The key is the prompt engineering - we tell the AI exactly what fields we need and what tone to use. The AI returns JSON that we can parse and store directly.
Testing Your Agentic Step
The best way to test your agentic step is throughWorkbench. It lets you create pets, watch the AI enrichment happen in real-time, and see all the logs in one place.
Create a Pet
Open Workbench and test the CreatePet endpoint. The AI will automatically start enriching the profile in the background.
Prefer using curl?
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Max", "species": "dog", "ageMonths": 24}'
Check the logs in Workbench to see the agentic step in action:
You'll see:
"Pet created" log from the API endpoint
"AI Profile Enrichment started" log
"AI Profile Enrichment completed" with generated content
View the Enriched Profile
Fetch the pet in Workbench to see the AI-generated profile, or use curl:
Using curl?
curlhttp://localhost:3000/ts/pets/1
curlhttp://localhost:3000/ts/pets/1
You'll get back something like:
Building a Decision-Making Agentic Step
Now let's create an agentic step that doesn't just generate content - it makes decisions that control the workflow. This is calledagentic routing.
The Health Review Agentic Step
This agentic step analyzes pet symptoms and decides if treatment is needed. Instead of you writing complex if-else logic, the AI evaluates the context and chooses the appropriate action.
View on GitHub:
TypeScript
Python
JavaScript
// steps/typescript/health-review-agent.step.tsimport{ ApiRouteConfig, Handlers }from'motia';import{ TSStore }from'./ts-store';import{HEALTH_REVIEW_EMITS,buildAgentContext,callAgentDecision,getAgentArtifacts}from'./agent-decision-framework';exportconstconfig:ApiRouteConfig={type:'api',name:'TsHealthReviewAgent',path:'/ts/pets/:id/health-review',method:'POST',emits: ['ts.health.treatment_required','ts.health.no_treatment_needed'],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsHealthReviewAgent']=async(req, {emit,logger})=>{constpetId=req.pathParams?.id;if(!petId) {return{ status:400, body: { message:'Pet ID is required'} };}constpet=TSStore.get(petId);if(!pet) {return{ status:404, body: { message:'Pet not found'} };}if(logger) {logger.info('🏥 Health Review Agent triggered', {petId,currentStatus: pet.status,symptoms: pet.symptoms||[]});}if(!['healthy','in_quarantine','available'].includes(pet.status)) {return{status:400,body: {message:'Health review can only be performed on healthy, quarantined, or available pets',currentStatus: pet.status}};}constagentContext=buildAgentContext(pet);constrecentArtifacts=getAgentArtifacts(petId).filter(a=>a.agentType==='health-review'&&a.success&&a.inputs.currentStatus===pet.status&&(Date.now()-a.timestamp)<60000);if(recentArtifacts.length>0) {constrecent=recentArtifacts[recentArtifacts.length-1];if(logger) {logger.info('🔄 Idempotent health review - returning cached decision', {petId,chosenEmit: recent.parsedDecision.chosenEmit,timestamp: recent.timestamp});}return{status:200,body: {message:'Health review completed (cached)',petId,agentDecision: recent.parsedDecision,artifact: {timestamp: recent.timestamp,success: recent.success}}};}try{if(logger) {logger.info('🔍 Starting agent decision call', { petId, agentContext });}constartifact=awaitcallAgentDecision('health-review',agentContext,HEALTH_REVIEW_EMITS,logger);if(logger) {logger.info('✅ Agent decision call completed', { petId, success: artifact.success });}if(!artifact.success) {if(logger) {logger.warn('⚠️ Agent decision failed, but returning error response', {petId,error: artifact.error});}return{status:500,body: {message:'Agent decision failed',error: artifact.error,petId,suggestion:'Check OpenAI API key and try again'}};}constchosenEmitDef=HEALTH_REVIEW_EMITS.find(e=>e.id===artifact.parsedDecision.chosenEmit);if(!chosenEmitDef) {return{status:500,body: {message:'Invalid emit chosen by agent',chosenEmit: artifact.parsedDecision.chosenEmit}};}if(emit) {(emitasany)({topic: chosenEmitDef.topicas'ts.health.treatment_required'|'ts.health.no_treatment_needed',data: {petId,event: chosenEmitDef.id.replace('emit.',''),agentDecision: artifact.parsedDecision,timestamp: artifact.timestamp,context: agentContext}});if(logger) {logger.info('✅ Health review emit fired', {petId,chosenEmit: artifact.parsedDecision.chosenEmit,topic: chosenEmitDef.topic,rationale: artifact.parsedDecision.rationale});}}return{status:200,body: {message:'Health review completed',petId,agentDecision: artifact.parsedDecision,emitFired: chosenEmitDef.topic,artifact: {timestamp: artifact.timestamp,success: artifact.success,availableEmits: artifact.availableEmits.map(e=>e.id)}}};}catch(error:any) {if(logger) {logger.error('❌ Health review agent error', {petId,error: error.message});}return{status:500,body: {message:'Health review failed',error: error.message,petId}};}};
// steps/typescript/health-review-agent.step.tsimport{ ApiRouteConfig, Handlers }from'motia';import{ TSStore }from'./ts-store';import{HEALTH_REVIEW_EMITS,buildAgentContext,callAgentDecision,getAgentArtifacts}from'./agent-decision-framework';exportconstconfig:ApiRouteConfig={type:'api',name:'TsHealthReviewAgent',path:'/ts/pets/:id/health-review',method:'POST',emits: ['ts.health.treatment_required','ts.health.no_treatment_needed'],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsHealthReviewAgent']=async(req, {emit,logger})=>{constpetId=req.pathParams?.id;if(!petId) {return{ status:400, body: { message:'Pet ID is required'} };}constpet=TSStore.get(petId);if(!pet) {return{ status:404, body: { message:'Pet not found'} };}if(logger) {logger.info('🏥 Health Review Agent triggered', {petId,currentStatus: pet.status,symptoms: pet.symptoms||[]});}if(!['healthy','in_quarantine','available'].includes(pet.status)) {return{status:400,body: {message:'Health review can only be performed on healthy, quarantined, or available pets',currentStatus: pet.status}};}constagentContext=buildAgentContext(pet);constrecentArtifacts=getAgentArtifacts(petId).filter(a=>a.agentType==='health-review'&&a.success&&a.inputs.currentStatus===pet.status&&(Date.now()-a.timestamp)<60000);if(recentArtifacts.length>0) {constrecent=recentArtifacts[recentArtifacts.length-1];if(logger) {logger.info('🔄 Idempotent health review - returning cached decision', {petId,chosenEmit: recent.parsedDecision.chosenEmit,timestamp: recent.timestamp});}return{status:200,body: {message:'Health review completed (cached)',petId,agentDecision: recent.parsedDecision,artifact: {timestamp: recent.timestamp,success: recent.success}}};}try{if(logger) {logger.info('🔍 Starting agent decision call', { petId, agentContext });}constartifact=awaitcallAgentDecision('health-review',agentContext,HEALTH_REVIEW_EMITS,logger);if(logger) {logger.info('✅ Agent decision call completed', { petId, success: artifact.success });}if(!artifact.success) {if(logger) {logger.warn('⚠️ Agent decision failed, but returning error response', {petId,error: artifact.error});}return{status:500,body: {message:'Agent decision failed',error: artifact.error,petId,suggestion:'Check OpenAI API key and try again'}};}constchosenEmitDef=HEALTH_REVIEW_EMITS.find(e=>e.id===artifact.parsedDecision.chosenEmit);if(!chosenEmitDef) {return{status:500,body: {message:'Invalid emit chosen by agent',chosenEmit: artifact.parsedDecision.chosenEmit}};}if(emit) {(emitasany)({topic: chosenEmitDef.topicas'ts.health.treatment_required'|'ts.health.no_treatment_needed',data: {petId,event: chosenEmitDef.id.replace('emit.',''),agentDecision: artifact.parsedDecision,timestamp: artifact.timestamp,context: agentContext}});if(logger) {logger.info('✅ Health review emit fired', {petId,chosenEmit: artifact.parsedDecision.chosenEmit,topic: chosenEmitDef.topic,rationale: artifact.parsedDecision.rationale});}}return{status:200,body: {message:'Health review completed',petId,agentDecision: artifact.parsedDecision,emitFired: chosenEmitDef.topic,artifact: {timestamp: artifact.timestamp,success: artifact.success,availableEmits: artifact.availableEmits.map(e=>e.id)}}};}catch(error:any) {if(logger) {logger.error('❌ Health review agent error', {petId,error: error.message});}return{status:500,body: {message:'Health review failed',error: error.message,petId}};}};
How Decision-Making Agentic Steps Work
This agentic step is fundamentally different from the enrichment agentic step:
It's an API Step- Staff trigger it explicitly when they need a decision
It defines an emits registry- Lists all possible actions the AI can choose from (inagent-decision-framework.ts/js)
agent-decision-framework.ts/js
It calls the AI with context + options- The AI evaluates and picks one
It fires the chosen emit- This emit goes to the orchestrator, changing workflow state
It uses idempotency checking- Caches recent decisions to prevent duplicate AI calls
The framework functions (buildAgentContext,callAgentDecision,getAgentArtifacts) handle the OpenAI call and ensure the AI picks from valid options.
buildAgentContext
callAgentDecision
getAgentArtifacts
Testing the Health Review Agentic Step
The best way to test decision-making agentic steps is throughWorkbench. You can create pets, trigger the health review, and watch the AI make decisions in real-time.
Create a Pet
Use Workbench to create a pet. The AI enrichment will automatically trigger.
Prefer using curl?
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Buddy","species": "dog","ageMonths": 36}'
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Buddy","species": "dog","ageMonths": 36}'
Trigger the Health Review
In Workbench, test the health review endpoint to see the AI make a decision.
Using curl?
curl-XPOSThttp://localhost:3000/ts/pets/1/health-review\-H"Content-Type: application/json"
curl-XPOSThttp://localhost:3000/ts/pets/1/health-review\-H"Content-Type: application/json"
You'll get a response like:
{"message":"Health review completed","petId":"1","agentDecision": {"chosenEmit":"emit.health.treatment_required","rationale":"The pet shows concerning symptoms including coughing, lethargy, and loss of appetite. These symptoms suggest a potential respiratory infection or illness requiring veterinary attention."},"emitFired":"ts.health.treatment_required","artifact": {"timestamp":1234567890,"success":true,"availableEmits": ["emit.health.treatment_required","emit.health.no_treatment_needed"]}}
{"message":"Health review completed","petId":"1","agentDecision": {"chosenEmit":"emit.health.treatment_required","rationale":"The pet shows concerning symptoms including coughing, lethargy, and loss of appetite. These symptoms suggest a potential respiratory infection or illness requiring veterinary attention."},"emitFired":"ts.health.treatment_required","artifact": {"timestamp":1234567890,"success":true,"availableEmits": ["emit.health.treatment_required","emit.health.no_treatment_needed"]}}
The AI evaluates the pet's data and makes a decision. The emit it fires will trigger the orchestrator to handle the appropriate state transition.
Verify the Status Change
Check the pet status in Workbench to see the AI's decision reflected in the workflow state.
Using curl?
curlhttp://localhost:3000/ts/pets/1
curlhttp://localhost:3000/ts/pets/1
The pet's status has automatically changed based on the AI's decision!
Connecting Agentic Steps to the Orchestrator
The real power comes when your agentic steps integrate with a workflow orchestrator. The orchestrator subscribes to the events emitted by agentic steps and handles the actual state transitions.
The orchestrator configuration shows it subscribes to agentic step events:
exportconstconfig={type:'event',name:'TsPetLifecycleOrchestrator',description:'Pet lifecycle state management with staff interaction points',subscribes: ['ts.feeding.reminder.completed','ts.pet.status.update.requested','ts.health.treatment_required',// From Health Review Agentic Step'ts.health.no_treatment_needed',// From Health Review Agentic Step'ts.adoption.needs_data',// From Adoption Review Agentic Step'ts.adoption.ready'// From Adoption Review Agentic Step],emits: ['ts.treatment.required','ts.adoption.ready','ts.treatment.completed'],flows: ['TsPetManagement']}// The orchestrator has transition rules that handle agentic step eventsconstTRANSITION_RULES:TransitionRule[]=[// ... other rules ...// Agentic step-driven health transitions{from: ["healthy","in_quarantine"],to:"ill",event:"health.treatment_required",description:"Agent assessment - pet requires medical treatment"},{from: ["healthy","in_quarantine"],to:"healthy",event:"health.no_treatment_needed",description:"Agent assessment - pet remains healthy"},// Agentic step-driven adoption transitions{from: ["healthy"],to:"healthy",event:"adoption.needs_data",description:"Agent assessment - pet needs additional data before adoption",flagAction: { action:'add', flag:'needs_data'}},{from: ["healthy"],to:"available",event:"adoption.ready",description:"Agent assessment - pet ready for adoption",guards: ['no_needs_data_flag']}]
exportconstconfig={type:'event',name:'TsPetLifecycleOrchestrator',description:'Pet lifecycle state management with staff interaction points',subscribes: ['ts.feeding.reminder.completed','ts.pet.status.update.requested','ts.health.treatment_required',// From Health Review Agentic Step'ts.health.no_treatment_needed',// From Health Review Agentic Step'ts.adoption.needs_data',// From Adoption Review Agentic Step'ts.adoption.ready'// From Adoption Review Agentic Step],emits: ['ts.treatment.required','ts.adoption.ready','ts.treatment.completed'],flows: ['TsPetManagement']}// The orchestrator has transition rules that handle agentic step eventsconstTRANSITION_RULES:TransitionRule[]=[// ... other rules ...// Agentic step-driven health transitions{from: ["healthy","in_quarantine"],to:"ill",event:"health.treatment_required",description:"Agent assessment - pet requires medical treatment"},{from: ["healthy","in_quarantine"],to:"healthy",event:"health.no_treatment_needed",description:"Agent assessment - pet remains healthy"},// Agentic step-driven adoption transitions{from: ["healthy"],to:"healthy",event:"adoption.needs_data",description:"Agent assessment - pet needs additional data before adoption",flagAction: { action:'add', flag:'needs_data'}},{from: ["healthy"],to:"available",event:"adoption.ready",description:"Agent assessment - pet ready for adoption",guards: ['no_needs_data_flag']}]
🎉Congratulations!You've built intelligent agentic workflows that make decisions and drive workflows. Your pet shelter now has automated intelligence that would have taken hundreds of lines of complex logic to implement manually.
What's Next?
Your pet shelter now has intelligent agentic workflows making decisions! But how do you give users real-time feedback while all this AI processing happens in the background?
In the final guide, we'll addReal-Time Streamingto provide live updates as your workflows execute:
Stream Configuration- Define stream schemas for type-safe updates
API with Streaming- Initialize streams and return immediately to clients
Background Job Streaming- Push real-time progress updates as jobs process
Agentic Step Streaming- Stream AI enrichment progress in real-time
Multi-Step Streaming- Multiple steps updating the same stream
Let's complete your system by adding real-time streaming capabilities!
Explore more examples in theMotia Examples Repository.
Workflows
Learn how to build automated workflows that manage complex business logic with Motia
Real-Time Streaming
Learn how to add real-time streaming updates to your Motia workflows
On this page



===== https://www.motia.dev/docs/getting-started/build-your-first-motia-app/streaming-agents =====

Real-Time Streaming
Learn how to add real-time streaming updates to your Motia workflows
What You'll Build
A pet management system with real-time streaming that provides live updates to clients:
Stream Configuration- Define stream schemas for type-safe updates
API with Streaming- APIs that initialize streams and return immediately
Background Job Streaming- Jobs that push real-time progress updates
Agentic Step Streaming- AI enrichment with live progress updates
Multi-Step Streaming- Multiple steps updating the same stream
Getting Started
Clone the example repository:
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutstream-ai-agents
gitclonehttps://github.com/MotiaDev/build-your-first-app.gitcdbuild-your-first-appgitcheckoutstream-ai-agents
Install dependencies:
npminstall
npminstall
Set up your OpenAI API key in.env:
.env
OPENAI_API_KEY=your_api_key_here
OPENAI_API_KEY=your_api_key_here
Start the Workbench:
npmrundev
npmrundev
Your Workbench will be available athttp://localhost:3000.
http://localhost:3000
Project Structure
Files likefeatures.jsonandtutorial.tsxare only for the interactive tutorial and are not part of Motia's project structure.
features.json
tutorial.tsx
All code examples in this guide are available in thebuild-your-first-apprepository.
You can follow this guide to learn how to build real-time streaming with Motia step by step, or you can clone the repository and dive into our Interactive Tutorial to learn by doing directly in the Workbench.
Understanding Real-Time Streaming
You've built APIs that return immediately, background jobs that process asynchronously, workflows that orchestrate complex logic, and agentic workflows that make intelligent decisions. But how do you give users real-time feedback while all this async processing happens in the background?
That's wherestreamingcomes in. Motia provides streams as part of the context in any step handler - you can use them anywhere in your code. Streams use Server-Sent Events (SSE) to push live updates directly to clients as your workflow progresses.
In our pet shelter example:
The API initializes a stream and returns immediately with a stream ID
Background jobs push updates as they process (quarantine entry, health checks)
Agentic steps stream enrichment progress (bio generation, breed analysis)
Clients get live feedback throughout the entire workflow
The power is in the simplicity -streamsis available in your handler's context, just likeemit,logger, andstate. Any step can update any stream, creating a unified real-time experience without complex orchestration.
streams
emit
logger
state
Creating Your First Stream
Step 1: Define the Stream Configuration
First, define a stream configuration file. This makes the stream available in thecontext.streamsobject for all your step handlers.
context.streams
View on GitHub:
TypeScript
Python
JavaScript
import{ StreamConfig }from'motia'import{ z }from'zod'exportconstconfig:StreamConfig={/*** This will be available as context.streams.petCreation in the FlowContext*/name:'petCreation',/*** Schema defines the structure of stream updates*/schema: z.object({message: z.string()}),/*** Use default storage for the stream*/baseConfig: {storageType:'default',},}
import{ StreamConfig }from'motia'import{ z }from'zod'exportconstconfig:StreamConfig={/*** This will be available as context.streams.petCreation in the FlowContext*/name:'petCreation',/*** Schema defines the structure of stream updates*/schema: z.object({message: z.string()}),/*** Use default storage for the stream*/baseConfig: {storageType:'default',},}
How Stream Configuration Works
Stream configuration is simple:
name- Identifier for accessing the stream (e.g.,context.streams.petCreation)
context.streams.petCreation
schema- Zod schema defining what data can be pushed to the stream
baseConfig- Storage settings (default uses in-memory storage)
Once you create this configuration file, the stream is automatically available asstreams.petCreationin the context of any step handler. It's just likeemit,logger, orstate- part of the tools available in your handler.
streams.petCreation
emit
logger
state
Step 2: Initialize Streams from APIs
Now let's update the pet creation API to initialize a stream and return it immediately to the client.
View on GitHub:
TypeScript
Python
JavaScript
// steps/typescript/create-pet.step.tsimport{ ApiRouteConfig, Handlers }from'motia';import{ z }from'zod';import{ TSStore }from'./ts-store';constcreatePetSchema=z.object({name: z.string().min(1,'Name is required').trim(),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0,'Age must be a positive number'),weightKg: z.number().positive().optional(),symptoms: z.array(z.string()).optional()});exportconstconfig:ApiRouteConfig={type:'api',name:'TsCreatePet',path:'/ts/pets',method:'POST',emits: ['ts.pet.created','ts.feeding.reminder.enqueued'],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsCreatePet']=async(req, {emit,logger,streams,traceId})=>{try{constvalidatedData=createPetSchema.parse(req.body);constpet=TSStore.create({name: validatedData.name,species: validatedData.species,ageMonths: validatedData.ageMonths,weightKg: validatedData.weightKg,symptoms: validatedData.symptoms});if(logger) {logger.info('🐾 Pet created', { petId: pet.id, name: pet.name, species: pet.species, status: pet.status });}// Create & return the initial stream record (following working pattern)constresult=awaitstreams.petCreation.set(traceId,'message', {message:`Pet ${pet.name} (ID: ${pet.id}) created successfully - Species: ${pet.species}, Age: ${pet.ageMonths} months, Status: ${pet.status}`});if(emit) {awaitemit({topic:'ts.pet.created',data: { petId: pet.id, event:'pet.created', name: pet.name, species: validatedData.species, traceId }}asany);awaitemit({topic:'ts.feeding.reminder.enqueued',data: { petId: pet.id, enqueuedAt: Date.now(), traceId }}asany);}return{status:201,body: result};}catch(error) {if(errorinstanceofz.ZodError) {return{status:400,body: {message:'Validation error',errors: error.errors}};}return{status:500,body: { message:'Internal server error'}};}};
// steps/typescript/create-pet.step.tsimport{ ApiRouteConfig, Handlers }from'motia';import{ z }from'zod';import{ TSStore }from'./ts-store';constcreatePetSchema=z.object({name: z.string().min(1,'Name is required').trim(),species: z.enum(['dog','cat','bird','other']),ageMonths: z.number().int().min(0,'Age must be a positive number'),weightKg: z.number().positive().optional(),symptoms: z.array(z.string()).optional()});exportconstconfig:ApiRouteConfig={type:'api',name:'TsCreatePet',path:'/ts/pets',method:'POST',emits: ['ts.pet.created','ts.feeding.reminder.enqueued'],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsCreatePet']=async(req, {emit,logger,streams,traceId})=>{try{constvalidatedData=createPetSchema.parse(req.body);constpet=TSStore.create({name: validatedData.name,species: validatedData.species,ageMonths: validatedData.ageMonths,weightKg: validatedData.weightKg,symptoms: validatedData.symptoms});if(logger) {logger.info('🐾 Pet created', { petId: pet.id, name: pet.name, species: pet.species, status: pet.status });}// Create & return the initial stream record (following working pattern)constresult=awaitstreams.petCreation.set(traceId,'message', {message:`Pet ${pet.name} (ID: ${pet.id}) created successfully - Species: ${pet.species}, Age: ${pet.ageMonths} months, Status: ${pet.status}`});if(emit) {awaitemit({topic:'ts.pet.created',data: { petId: pet.id, event:'pet.created', name: pet.name, species: validatedData.species, traceId }}asany);awaitemit({topic:'ts.feeding.reminder.enqueued',data: { petId: pet.id, enqueuedAt: Date.now(), traceId }}asany);}return{status:201,body: result};}catch(error) {if(errorinstanceofz.ZodError) {return{status:400,body: {message:'Validation error',errors: error.errors}};}return{status:500,body: { message:'Internal server error'}};}};
How API Stream Initialization Works
The key changes from a regular API:
Access streams from context-streamsis available in the FlowContext
streams
Create initial stream message-await streams.petCreation.set(traceId, 'message', data)
await streams.petCreation.set(traceId, 'message', data)
Return the stream result- Contains stream ID and initial message
Background jobs update the same stream- Using the same traceId
The API returns immediately with a stream ID. Clients can connect to this stream via SSE to receive real-time updates as background jobs process.
Step 3: Stream Updates from Background Jobs
Now let's update the feeding reminder job to push real-time updates to the stream as it processes.
View on GitHub:
TypeScript
Python
JavaScript
// steps/typescript/set-next-feeding-reminder.job.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore }from'./ts-store';exportconstconfig={type:'event',name:'TsSetNextFeedingReminder',description:'Background job that sets next feeding reminder and adds welcome notes',subscribes: ['ts.feeding.reminder.enqueued'],emits: ['ts.feeding.reminder.completed'],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsSetNextFeedingReminder']=async(input, {emit,logger,streams,traceId})=>{const{petId,enqueuedAt}=input;if(logger) {logger.info('🔄 Setting next feeding reminder', { petId, enqueuedAt });}try{// Calculate next feeding time (24 hours from now)constnextFeedingAt=Date.now()+(24*60*60*1000);// Fill in non-critical details and change status to in_quarantineconstupdates={notes:'Welcome to our pet store! We\'ll take great care of this pet.',nextFeedingAt: nextFeedingAt,status:'in_quarantine'asconst};constupdatedPet=TSStore.update(petId, updates);if(!updatedPet) {if(logger) {logger.error('❌ Failed to set feeding reminder - pet not found', { petId });}return;}if(logger) {logger.info('✅ Next feeding reminder set', {petId,notes: updatedPet.notes?.substring(0,50)+'...',nextFeedingAt:newDate(nextFeedingAt).toISOString()});}// Stream status updates using the simple patternif(streams?.petCreation&&traceId) {awaitstreams.petCreation.set(traceId,'message', {message:`Pet ${updatedPet.name} entered quarantine period`});// Check symptoms and stream appropriate updatesif(!updatedPet.symptoms||updatedPet.symptoms.length===0) {awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`Health check passed for ${updatedPet.name} - no symptoms found`});awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`${updatedPet.name} is healthy and ready for adoption! ✅`});}else{awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`Health check failed for ${updatedPet.name} - symptoms detected: ${updatedPet.symptoms.join(', ')}`});awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`${updatedPet.name} needs medical treatment ❌`});}}if(emit) {(emitasany)({topic:'ts.feeding.reminder.completed',data: {petId,event:'feeding.reminder.completed',completedAt: Date.now(),processingTimeMs: Date.now()-enqueuedAt}});}}catch(error:any) {if(logger) {logger.error('❌ Feeding reminder job error', { petId, error: error.message });}}};
// steps/typescript/set-next-feeding-reminder.job.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore }from'./ts-store';exportconstconfig={type:'event',name:'TsSetNextFeedingReminder',description:'Background job that sets next feeding reminder and adds welcome notes',subscribes: ['ts.feeding.reminder.enqueued'],emits: ['ts.feeding.reminder.completed'],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsSetNextFeedingReminder']=async(input, {emit,logger,streams,traceId})=>{const{petId,enqueuedAt}=input;if(logger) {logger.info('🔄 Setting next feeding reminder', { petId, enqueuedAt });}try{// Calculate next feeding time (24 hours from now)constnextFeedingAt=Date.now()+(24*60*60*1000);// Fill in non-critical details and change status to in_quarantineconstupdates={notes:'Welcome to our pet store! We\'ll take great care of this pet.',nextFeedingAt: nextFeedingAt,status:'in_quarantine'asconst};constupdatedPet=TSStore.update(petId, updates);if(!updatedPet) {if(logger) {logger.error('❌ Failed to set feeding reminder - pet not found', { petId });}return;}if(logger) {logger.info('✅ Next feeding reminder set', {petId,notes: updatedPet.notes?.substring(0,50)+'...',nextFeedingAt:newDate(nextFeedingAt).toISOString()});}// Stream status updates using the simple patternif(streams?.petCreation&&traceId) {awaitstreams.petCreation.set(traceId,'message', {message:`Pet ${updatedPet.name} entered quarantine period`});// Check symptoms and stream appropriate updatesif(!updatedPet.symptoms||updatedPet.symptoms.length===0) {awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`Health check passed for ${updatedPet.name} - no symptoms found`});awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`${updatedPet.name} is healthy and ready for adoption! ✅`});}else{awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`Health check failed for ${updatedPet.name} - symptoms detected: ${updatedPet.symptoms.join(', ')}`});awaitnewPromise(resolve=>setTimeout(resolve,1000));awaitstreams.petCreation.set(traceId,'message', {message:`${updatedPet.name} needs medical treatment ❌`});}}if(emit) {(emitasany)({topic:'ts.feeding.reminder.completed',data: {petId,event:'feeding.reminder.completed',completedAt: Date.now(),processingTimeMs: Date.now()-enqueuedAt}});}}catch(error:any) {if(logger) {logger.error('❌ Feeding reminder job error', { petId, error: error.message });}}};
How Background Job Streaming Works
Background jobs can push multiple updates to a stream:
Access the stream-streams.petCreationis available in context
streams.petCreation
Push updates-await streams.petCreation.set(traceId, 'message', data)
await streams.petCreation.set(traceId, 'message', data)
Use the same traceId- Links updates to the original API request
Send multiple updates- Eachset()call sends immediately to connected clients
set()
The background job processes asynchronously, pushing updates at each stage. Clients connected to the stream receive these updates in real-time via SSE.
Step 4: Agentic Step Streaming
Agentic steps can also stream progress updates as they generate content. This provides live feedback during potentially long-running AI operations.
View on GitHub:
TypeScript
Python
JavaScript
// steps/typescript/ai-profile-enrichment.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore, PetProfile }from'./ts-store';exportconstconfig={type:'event',name:'TsAiProfileEnrichment',description:'Agentic step that enriches pet profiles using OpenAI',subscribes: ['ts.pet.created'],emits: [],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsAiProfileEnrichment']=async(input, {logger,streams,traceId})=>{const{petId,name,species}=input;if(logger) {logger.info('🤖 AI Profile Enrichment started', { petId, name, species });}// Stream enrichment started eventif(streams&&traceId) {await(streamsasany).petCreation.set(traceId,'enrichment_started', {message:`AI enrichment started for ${name}`}asany);}try{constapiKey=process.env.OPENAI_API_KEY;if(!apiKey) {thrownewError('OPENAI_API_KEY environment variable is not set');}constprompt=`Generate a pet profile for adoption purposes. Pet details:- Name: ${name}- Species: ${species}Please provide a JSON response with these fields:- bio: A warm, engaging 2-3 sentence description that would appeal to potential adopters- breedGuess: Your best guess at the breed or breed mix (be specific but realistic)- temperamentTags: An array of 3-5 personality traits (e.g., "friendly", "energetic", "calm")- adopterHints: Practical advice for potential adopters (family type, living situation, care needs)Keep it positive, realistic, and adoption-focused.`;constenrichmentFields=['bio','breedGuess','temperamentTags','adopterHints'];constenrichedProfile:any={};constresponse=awaitfetch('https://api.openai.com/v1/chat/completions', {method:'POST',headers: {'Authorization':`Bearer ${apiKey}`,'Content-Type':'application/json',},body:JSON.stringify({model:'gpt-3.5-turbo',messages: [{role:'system',content:'You are a pet adoption specialist who creates compelling, accurate pet profiles. Always respond with valid JSON only.'},{role:'user',content: prompt}],max_tokens:500,temperature:0.7,}),});if(!response.ok) {thrownewError(`OpenAI API error: ${response.status} ${response.statusText}`);}constdata=awaitresponse.json();constaiResponse=data.choices[0]?.message?.content;if(!aiResponse) {thrownewError('No response from OpenAI API');}letprofile:PetProfile;try{profile=JSON.parse(aiResponse);}catch(parseError) {profile={bio:`${name} is a wonderful ${species} looking for a loving home. This pet has a unique personality and would make a great companion.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','loving','loyal'],adopterHints:`${name} would do well in a caring home with patience and love.`};if(logger) {logger.warn('⚠️ AI response parsing failed, using fallback profile', { petId, parseError: parseErrorinstanceofError?parseError.message:String(parseError) });}}constupdatedPet=TSStore.updateProfile(petId, profile);if(!updatedPet) {thrownewError(`Pet not found: ${petId}`);}if(logger) {logger.info('✅ AI Profile Enrichment completed', {petId,profile: {bio: profile.bio.substring(0,50)+'...',breedGuess: profile.breedGuess,temperamentTags: profile.temperamentTags,adopterHints: profile.adopterHints.substring(0,50)+'...'}});}// Stream each field as it's processedfor(constfieldofenrichmentFields) {awaitnewPromise(resolve=>setTimeout(resolve,300));constvalue=profile[fieldaskeyofPetProfile];if(streams&&traceId) {await(streamsasany).petCreation.set(traceId,`progress_${field}`, {message:`Generated ${field} for ${name}`}asany);}}// Stream enrichment completed eventif(streams&&traceId) {await(streamsasany).petCreation.set(traceId,'completed', {message:`AI enrichment completed for ${name}`}asany);}}catch(error:any) {if(logger) {logger.error('❌ AI Profile Enrichment failed', {petId,error: error.message});}constfallbackProfile:PetProfile={bio:`${name} is a lovely ${species} with a unique personality, ready to find their forever home.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','adaptable'],adopterHints:`${name} is looking for a patient and loving family.`};TSStore.updateProfile(petId, fallbackProfile);// Stream fallback profile completionif(streams&&traceId) {await(streamsasany).petCreation.set(traceId,'completed', {message:`AI enrichment completed with fallback profile for ${name}`}asany);}}};
// steps/typescript/ai-profile-enrichment.step.tsimport{ EventConfig, Handlers }from'motia';import{ TSStore, PetProfile }from'./ts-store';exportconstconfig={type:'event',name:'TsAiProfileEnrichment',description:'Agentic step that enriches pet profiles using OpenAI',subscribes: ['ts.pet.created'],emits: [],flows: ['TsPetManagement']};exportconsthandler:Handlers['TsAiProfileEnrichment']=async(input, {logger,streams,traceId})=>{const{petId,name,species}=input;if(logger) {logger.info('🤖 AI Profile Enrichment started', { petId, name, species });}// Stream enrichment started eventif(streams&&traceId) {await(streamsasany).petCreation.set(traceId,'enrichment_started', {message:`AI enrichment started for ${name}`}asany);}try{constapiKey=process.env.OPENAI_API_KEY;if(!apiKey) {thrownewError('OPENAI_API_KEY environment variable is not set');}constprompt=`Generate a pet profile for adoption purposes. Pet details:- Name: ${name}- Species: ${species}Please provide a JSON response with these fields:- bio: A warm, engaging 2-3 sentence description that would appeal to potential adopters- breedGuess: Your best guess at the breed or breed mix (be specific but realistic)- temperamentTags: An array of 3-5 personality traits (e.g., "friendly", "energetic", "calm")- adopterHints: Practical advice for potential adopters (family type, living situation, care needs)Keep it positive, realistic, and adoption-focused.`;constenrichmentFields=['bio','breedGuess','temperamentTags','adopterHints'];constenrichedProfile:any={};constresponse=awaitfetch('https://api.openai.com/v1/chat/completions', {method:'POST',headers: {'Authorization':`Bearer ${apiKey}`,'Content-Type':'application/json',},body:JSON.stringify({model:'gpt-3.5-turbo',messages: [{role:'system',content:'You are a pet adoption specialist who creates compelling, accurate pet profiles. Always respond with valid JSON only.'},{role:'user',content: prompt}],max_tokens:500,temperature:0.7,}),});if(!response.ok) {thrownewError(`OpenAI API error: ${response.status} ${response.statusText}`);}constdata=awaitresponse.json();constaiResponse=data.choices[0]?.message?.content;if(!aiResponse) {thrownewError('No response from OpenAI API');}letprofile:PetProfile;try{profile=JSON.parse(aiResponse);}catch(parseError) {profile={bio:`${name} is a wonderful ${species} looking for a loving home. This pet has a unique personality and would make a great companion.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','loving','loyal'],adopterHints:`${name} would do well in a caring home with patience and love.`};if(logger) {logger.warn('⚠️ AI response parsing failed, using fallback profile', { petId, parseError: parseErrorinstanceofError?parseError.message:String(parseError) });}}constupdatedPet=TSStore.updateProfile(petId, profile);if(!updatedPet) {thrownewError(`Pet not found: ${petId}`);}if(logger) {logger.info('✅ AI Profile Enrichment completed', {petId,profile: {bio: profile.bio.substring(0,50)+'...',breedGuess: profile.breedGuess,temperamentTags: profile.temperamentTags,adopterHints: profile.adopterHints.substring(0,50)+'...'}});}// Stream each field as it's processedfor(constfieldofenrichmentFields) {awaitnewPromise(resolve=>setTimeout(resolve,300));constvalue=profile[fieldaskeyofPetProfile];if(streams&&traceId) {await(streamsasany).petCreation.set(traceId,`progress_${field}`, {message:`Generated ${field} for ${name}`}asany);}}// Stream enrichment completed eventif(streams&&traceId) {await(streamsasany).petCreation.set(traceId,'completed', {message:`AI enrichment completed for ${name}`}asany);}}catch(error:any) {if(logger) {logger.error('❌ AI Profile Enrichment failed', {petId,error: error.message});}constfallbackProfile:PetProfile={bio:`${name} is a lovely ${species} with a unique personality, ready to find their forever home.`,breedGuess: species==='dog'?'Mixed Breed':species==='cat'?'Domestic Shorthair':'Mixed Breed',temperamentTags: ['friendly','adaptable'],adopterHints:`${name} is looking for a patient and loving family.`};TSStore.updateProfile(petId, fallbackProfile);// Stream fallback profile completionif(streams&&traceId) {await(streamsasany).petCreation.set(traceId,'completed', {message:`AI enrichment completed with fallback profile for ${name}`}asany);}}};
How Agentic Step Streaming Works
Agentic steps stream progress as they work:
Stream start notification- Let users know AI processing has begun
Progress updates- Stream each stage of generation (bio, breed, temperament, etc.)
Stream completion- Notify when AI processing is done
Error streaming- Stream errors gracefully with fallback messages
This transforms a potentially slow AI operation into an engaging real-time experience.
Testing Streaming in Action
The best way to test streams is throughWorkbench.
Test 1: Create a Pet with Streaming
Open Workbench and navigate to the Endpoints section, then test the Pet Creation endpoint:
Prefer using curl?
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Max","species": "dog","ageMonths": 24,"symptoms": ["coughing"]}'
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Max","species": "dog","ageMonths": 24,"symptoms": ["coughing"]}'
You'll get an immediate response with the stream result. The API returns right away while background jobs process asynchronously.
Test 2: Monitor Stream Updates in Workbench
After creating a pet, check the Tracing view in Workbench:
Automatically switched to theTracingtab so you can see the stream updates in real-time
Click on the most recent trace
Watch the timeline as steps execute
See stream updates appear in real-time in the timeline
You'll observe:
Pet creation completes immediately
Feeding reminder job streams quarantine updates
AI enrichment streams progress updates
All updates visible in the trace timeline
Test 3: Create Pet with Symptoms
Test the conditional streaming logic by creating a pet with symptoms:
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Luna","species": "cat","ageMonths": 18,"symptoms": ["sneezing", "watery eyes"]}'
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Luna","species": "cat","ageMonths": 18,"symptoms": ["sneezing", "watery eyes"]}'
Watch the logs to see different stream messages based on the symptoms detected.
Test 4: Create Pet Without Symptoms
Compare the streaming behavior with a healthy pet:
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Buddy","species": "dog","ageMonths": 12}'
curl-XPOSThttp://localhost:3000/ts/pets\-H"Content-Type: application/json"\-d'{"name": "Buddy","species": "dog","ageMonths": 12}'
The stream will show health check passed messages instead of treatment needed messages.
Observing Stream Updates
Watch the Workbench console logs to see the real-time stream updates as they're pushed:
🐾 Pet created { petId: '1', name: 'Max', species: 'dog', status: 'new' }📋 Setting next feeding reminder { petId: '1' }🤖 AI Profile Enrichment started { petId: '1', name: 'Max' }✅ Next feeding reminder set { petId: '1' }✅ AI Profile Enrichment completed { petId: '1' }
🐾 Pet created { petId: '1', name: 'Max', species: 'dog', status: 'new' }📋 Setting next feeding reminder { petId: '1' }🤖 AI Profile Enrichment started { petId: '1', name: 'Max' }✅ Next feeding reminder set { petId: '1' }✅ AI Profile Enrichment completed { petId: '1' }
Each emoji-prefixed log corresponds to a stream update being pushed to connected clients.
🎉Congratulations!You've built a complete real-time streaming system with Motia. Your pet management system now provides live feedback to users while complex workflows execute in the background.
What's Next?
You've now mastered the complete Motia stack:
API Endpoints- Build RESTful APIs with validation
Background Jobs- Process async tasks efficiently
Workflows- Orchestrate complex business logic
Agentic Workflows- Make intelligent decisions with AI
Real-Time Streaming- Provide live updates using streams in any step handler
This is thecomplete progressionfrom simple APIs to intelligent, real-time systems!
Key Takeaway:Streams are just another tool in your step handler's context - use them wherever you need real-time updates!
Here are some ideas to extend your streaming implementation:
Add stream analytics- Track how many clients are connected, message delivery rates
Implement stream persistence- Use Redis adapter for stream storage across restarts
Create stream multiplexing- Multiple streams per workflow for different update types
Build progress bars- Use structured progress data (0-100%) instead of just messages
Add stream authentication- Ensure only authorized clients can access streams
Explore more examples in theMotia Examples Repository.
Agentic Workflows
Learn how to build intelligent agentic workflows that make decisions and automate workflows with Motia
Overview
One primitive, any language, event-driven by default - that's Motia
On this page



===== https://www.motia.dev/docs/concepts/overview =====

Overview
One primitive, any language, event-driven by default - that's Motia
Motia is a backend framework built around a single core primitive:everything is a Step.
Want an API? That's a Step.Need a background job? That's a Step.Scheduled task? Also a Step.
Write each Step in whatever language makes sense - TypeScript, Python, or JavaScript. They all run together, share the same state, and talk through events.
How It Works
Every Step is just a file with two parts:
1. Config→ When and how it runs2. Handler→ What it does
import{ ApiRouteConfig, Handlers }from'motia'// Config - when it runsexportconstconfig:ApiRouteConfig={name:'MyStep',type:'api',path:'/endpoint',method:'POST',emits: ['task.done']}// Handler - what it doesexportconsthandler:Handlers['MyStep']=async(req, {emit,logger})=>{logger.info('Processing request')awaitemit({topic:'task.done',data: { result:'success'}})return{ status:200, body: { success:true} }}
import{ ApiRouteConfig, Handlers }from'motia'// Config - when it runsexportconstconfig:ApiRouteConfig={name:'MyStep',type:'api',path:'/endpoint',method:'POST',emits: ['task.done']}// Handler - what it doesexportconsthandler:Handlers['MyStep']=async(req, {emit,logger})=>{logger.info('Processing request')awaitemit({topic:'task.done',data: { result:'success'}})return{ status:200, body: { success:true} }}
👉 Drop this file in yoursteps/folder and Motia finds it automatically. No registration, no imports, no setup.
steps/
Learn more about Steps →
Event-Driven Architecture
Steps don't call each other. Theyemitandsubscribeto events.
This means:
Your API can trigger a background job without waiting for it
Steps run independently and retry on failure
You can add new Steps without touching existing ones
Everything is traceable from start to finish
Example:An API emits an event, a background Step picks it up:
// API Step emitsawaitemit({ topic:'user.created', data: { email } })// Event Step subscribes and processesconfig={type:'event',subscribes: ['user.created']}
// API Step emitsawaitemit({ topic:'user.created', data: { email } })// Event Step subscribes and processesconfig={type:'event',subscribes: ['user.created']}
That's it. No coupling, no dependencies.
Project Structure & Auto-Discovery
Motia automatically discovers Steps - no manual registration required.
Basic Structure
Thesteps/directory is the heart of your Motia application. All your workflow logic lives here, and Motia automatically discovers any file following the naming pattern.
steps/
Auto-Discovery Rules
Motia scans thesteps/directory and automatically registers files that:
steps/
✅Match naming pattern:TypeScript:.step.tsJavaScript:.step.jsPython:_step.py(note: underscore beforestep)
✅Match naming pattern:
TypeScript:.step.ts
.step.ts
JavaScript:.step.js
.step.js
Python:_step.py(note: underscore beforestep)
_step.py
step
✅Export aconfigobjectwith Step configuration
✅Export aconfigobjectwith Step configuration
config
✅Export ahandlerfunctionwith business logic
✅Export ahandlerfunctionwith business logic
handler
No imports. No registration. Just create the file and Motia finds it.
Multi-Language Support
Every Step can be in a different language. They all run in the same process and share everything.
Currently Supported:
TypeScript→.step.ts
.step.ts
Python→_step.py
_step.py
JavaScript→.step.js
.step.js
Coming Soon:
Ruby →.step.rb
.step.rb
C# →.step.cs
.step.cs
Go →.step.go
.step.go
And many more...
Example project:
All three Steps work together. TypeScript API emits an event → Python processes with ML → JavaScript sends the result.
Core Concepts
State Management
Persistent key-value storage that works across all Steps and languages.
awaitstate.set('users','user-123', { name:'John'})constuser=awaitstate.get('users','user-123')
awaitstate.set('users','user-123', { name:'John'})constuser=awaitstate.get('users','user-123')
Learn about State →
Real-Time Streams
Push live updates to connected clients (browsers, mobile apps).
awaitstreams.notifications.set('user-123','notif-1', {message:'Order shipped!',timestamp:newDate().toISOString()})
awaitstreams.notifications.set('user-123','notif-1', {message:'Order shipped!',timestamp:newDate().toISOString()})
Clients receive updates instantly.
Learn about Streams →
Context Object
Every handler gets a context object with everything you need:
logger
emit
state
streams
traceId
Development Tool - Workbench
Visual interface for testing APIs, building and debugging flows:
See your entire flow as a beautiful diagram
Test API endpoints in the browser
Watch logs in real-time
Inspect state as it changes
Learn about Workbench →
What's Next?
📦 Steps
Deep dive into Steps - the only primitive you need
🚀 Quick Start
Build your first app in 5 minutes
Real-Time Streaming
Learn how to add real-time streaming updates to your Motia workflows
Steps
One primitive to build any backend. Simple, composable, and multi-language.
On this page



===== https://www.motia.dev/docs/concepts/steps =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/workbench =====

Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
Motia Workbench
Motia Workbench is a development platform that helps you build and debug your Motia flows. It serves as your control center where you can:
Visualize flows as interactive diagrams
Test steps directly in the UI
Monitor real-time logs
Debug issues
Getting Started
Start workbench by running:
npm run dev
Running the dev command starts:
Motia Server: Backend services and API endpoints
Motia Workbench: Web interface athttp://localhost:3000
Development Mode: Auto-reloads when changes are made
Key Features
Flow Visualization
See your entire flow as an interactive diagram:
Steps appear as connected nodes
API endpoints are highlighted as entry points
Event connections show data flow
Click any step to see its details
Real-time Testing
Test your flows directly in the interface:
Send test requests to API endpoints
Monitor how events flow through steps
Visualize step sequence execution
Inspect data at each stage
Live Logs
Monitor your flow execution in real-time with structured logging and trace information.
Development Tools
Hot Reload: Changes reflect immediately in the UI
Error Handling: Detailed error messages with contextual debugging information
State Inspector: Real-time monitoring of state management
Steps
One primitive to build any backend. Simple, composable, and multi-language.
Product Showcase
Next Page
On this page



===== https://www.motia.dev/docs/product-showcase =====

Product Showcase
Explore full-scale production applications built with Motia that demonstrate the framework's capabilities in real-world scenarios.
ChessArena AI
Production-grade chess platform with real-time AI battles, move evaluation, and live leaderboards
💻 Live Applications
These are not just examples or tutorials - they are fully functional, production-ready applications that handle real user traffic and demonstrate Motia's capabilities at scale.
Production-Ready Applications
These applications demonstrate Motia's enterprise capabilities with real user traffic, production deployments, and battle-tested architectures.
🏆 Live Chess Platform
📚 Source Code →
Contribute
Have you built something amazing with Motia? We'd love to feature your production application! Pleasereach out to uswith details about your project.
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
ChessArena AI
Next Page
On this page



===== https://www.motia.dev/docs/product-showcase/chessarena-ai =====

ChessArena AI
In the world of AI development, chess serves as the perfect benchmark for intelligence and strategic thinking. But how do you measure which AI models truly "understand" chess beyond simple win/loss statistics? ChessArena.AI solves this challenge by focusing on move quality and game insight rather than just outcomes.
This comprehensive guide explores how to build a production-ready chess platform using Motia's event-driven architecture and real-time streaming capabilities. We'll cover:
Real-Time Chess Streaming: How Motia Streams enable live game updates across all connected players
Multi-Language Architecture: Combining TypeScript orchestration with Python chess engine integration
AI Model Integration: Supporting multiple LLM providers (OpenAI, Anthropic Claude, Google Gemini, xAI Grok) for chess gameplay
Move Evaluation System: Using Stockfish engine for real-time move analysis and scoring
Production Deployment: How this exact platform powers the live ChessArena.AI website
Let's build a chess platform that measures AI intelligence through gameplay quality.
🏭 Production-Grade Chess Platform
This is not a tutorial project- this is battle-tested, production-ready code that handles real traffic at scale. Every aspect has been designed for enterprise use:
🎮 Live Chess Platform: Real-time games with multiple AI models competing simultaneously
📊 Move Quality Analysis: Every move evaluated by Stockfish engine for strategic insight
⚡ Real-Time Updates: Live game state synchronization across all connected clients
🤖 Multi-AI Support: OpenAI GPT, Anthropic Claude, XAI Grok, Google Gemini integration
🏆 Dynamic Leaderboards: Real-time scoring based on move quality, not just wins
🌍 Global Scale: Production deployment on Motia Cloud with worldwide accessibility
💰 Cost Efficient: Event-driven architecture that scales efficiently
Live Proof: Powering ChessArena.AI
This isn't just a demo- this exact code powers the live chess platform atChessArena.AI!
Visit the platform and you'll see:
🏆 Live AI Leaderboardranking models by move quality
⚡ Real-Time Gameswith instant move updates and evaluations
📊 Move Analysisshowing centipawn scores and blunder detection
🎮 Multi-Model Battleswith GPT-5, Claude Opus 4, Gemini 2.5 Flash, and Grok 4 competing
That live chess platform with real-time AI battles? That's this exact implementation in production, processing thousands of moves and providing instant feedback to chess enthusiasts worldwide!
The Power of Strategic AI Evaluation
At its core, ChessArena.AI solves a fundamental challenge: how do you measure AI intelligence in chess beyond simple win/loss statistics? Traditional chess platforms focus on game outcomes, but most LLM games end in draws, making it difficult to distinguish between models.
Our Motia-powered solution revolutionizes AI chess evaluation through:
Stockfish Integration: World's strongest open-source chess engine for move analysis
Centipawn Scoring: Precise move quality measurement in hundredths of a pawn
Real-Time Streaming: Live game updates and move evaluations
Multi-LLM Support: Support for OpenAI, Anthropic, and Google AI models
Instead of focusing on who wins, we measure how well each AI model understands chess strategy and tactics.
The Anatomy of Our Chess Platform
Our application consists of specialized components handling different aspects of chess gameplay, from game creation to move evaluation. Let's explore the complete architecture.
The entry point that exposes available AI models from different providers (OpenAI, Anthropic, Google, xAI) for chess gameplay. The platform supports cutting-edge models and allows easy extension for new providers.
import{ AiModelsSchema }from'@chessarena/types/ai-models'import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ supportedModelsByProvider }from'../../services/ai/models'// Current supported models (as of 2025)exportconstsupportedModelsByProvider:AiModels={openai: ['gpt-5-2025-08-07',// Latest GPT-5'o4-mini-2025-04-16',// O4 Mini'gpt-4.1-nano-2025-04-14',// GPT-4.1 Nano'o3-mini-2025-01-31',// O3 Mini'gpt-4o-mini-2024-07-18',// GPT-4o Mini],gemini: ['gemini-2.5-flash',// Latest Gemini 2.5 Flash'gemini-2.0-flash-001',// Gemini 2.0 Flash],claude: ['claude-opus-4-1-20250805',// Claude Opus 4.1'claude-opus-4-20250514',// Claude Opus 4'claude-sonnet-4-20250514',// Claude Sonnet 4'claude-3-7-sonnet-20250219',// Claude 3.7 Sonnet'claude-3-5-sonnet-20241022',// Claude 3.5 Sonnet'claude-3-5-haiku-20241022',// Claude 3.5 Haiku],grok: ['grok-4',// Latest Grok 4'grok-3',// Grok 3],}exportconstconfig:ApiRouteConfig={type:'api',name:'AvailableModels',description:'Expose all available AI models for supported providers',path:'/chess/models',method:'GET',emits: [],flows: ['chess'],responseSchema: {200: z.object({ models:AiModelsSchema() }),404: z.object({ message: z.string() }),400: z.object({ message: z.string() }),},}exportconsthandler:Handlers['AvailableModels']=async(_, {logger})=>{logger.info('Received available models request')return{status:200,body: {models: supportedModelsByProvider,},}}
import{ AiModelsSchema }from'@chessarena/types/ai-models'import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'import{ supportedModelsByProvider }from'../../services/ai/models'// Current supported models (as of 2025)exportconstsupportedModelsByProvider:AiModels={openai: ['gpt-5-2025-08-07',// Latest GPT-5'o4-mini-2025-04-16',// O4 Mini'gpt-4.1-nano-2025-04-14',// GPT-4.1 Nano'o3-mini-2025-01-31',// O3 Mini'gpt-4o-mini-2024-07-18',// GPT-4o Mini],gemini: ['gemini-2.5-flash',// Latest Gemini 2.5 Flash'gemini-2.0-flash-001',// Gemini 2.0 Flash],claude: ['claude-opus-4-1-20250805',// Claude Opus 4.1'claude-opus-4-20250514',// Claude Opus 4'claude-sonnet-4-20250514',// Claude Sonnet 4'claude-3-7-sonnet-20250219',// Claude 3.7 Sonnet'claude-3-5-sonnet-20241022',// Claude 3.5 Sonnet'claude-3-5-haiku-20241022',// Claude 3.5 Haiku],grok: ['grok-4',// Latest Grok 4'grok-3',// Grok 3],}exportconstconfig:ApiRouteConfig={type:'api',name:'AvailableModels',description:'Expose all available AI models for supported providers',path:'/chess/models',method:'GET',emits: [],flows: ['chess'],responseSchema: {200: z.object({ models:AiModelsSchema() }),404: z.object({ message: z.string() }),400: z.object({ message: z.string() }),},}exportconsthandler:Handlers['AvailableModels']=async(_, {logger})=>{logger.info('Received available models request')return{status:200,body: {models: supportedModelsByProvider,},}}
Extensible AI Provider System
ChessArena.AI features a plugin-based architecture that makes adding new AI providers incredibly simple. The unifiedmakePromptsystem handles all provider differences behind a clean interface.
makePrompt
Adding New AI Providers
To add a new AI provider (like Anthropic's upcoming models or other LLM providers), you only need to:
Create a provider handlerinservices/ai/your-provider.ts:
services/ai/your-provider.ts
import{ Handler }from'./types'exportconstyourProvider:Handler=async({prompt,zod,logger,model})=>{// Initialize your AI clientconstclient=newYourAIClient({ apiKey: process.env.YOUR_API_KEY})// Make the API call with structured outputconstresponse=awaitclient.chat({model: model??'your-default-model',messages: [{ role:'user', content: prompt }],responseFormat: { type:'json_schema', schema:zodToJsonSchema(zod) },})logger.info('Your provider response received', { model })returnJSON.parse(response.content)}
import{ Handler }from'./types'exportconstyourProvider:Handler=async({prompt,zod,logger,model})=>{// Initialize your AI clientconstclient=newYourAIClient({ apiKey: process.env.YOUR_API_KEY})// Make the API call with structured outputconstresponse=awaitclient.chat({model: model??'your-default-model',messages: [{ role:'user', content: prompt }],responseFormat: { type:'json_schema', schema:zodToJsonSchema(zod) },})logger.info('Your provider response received', { model })returnJSON.parse(response.content)}
Register the providerinservices/ai/make-prompt.ts:
services/ai/make-prompt.ts
import{ yourProvider }from'./your-provider'constproviders:Record<AiModelProvider,Handler>={openai,gemini,claude,grok,yourProvider,// Add your provider here}
import{ yourProvider }from'./your-provider'constproviders:Record<AiModelProvider,Handler>={openai,gemini,claude,grok,yourProvider,// Add your provider here}
Update the type definitionsintypes/ai-models.ts:
types/ai-models.ts
exportconstAiModelProviderSchema=()=>z.enum(['openai','gemini','claude','grok','yourProvider'])
exportconstAiModelProviderSchema=()=>z.enum(['openai','gemini','claude','grok','yourProvider'])
Add supported modelsinservices/ai/models.ts:
services/ai/models.ts
exportconstsupportedModelsByProvider:AiModels={// ... existing providersyourProvider: ['your-model-v1','your-model-v2-turbo','your-model-reasoning',],}
exportconstsupportedModelsByProvider:AiModels={// ... existing providersyourProvider: ['your-model-v1','your-model-v2-turbo','your-model-reasoning',],}
That's it! Your new AI provider is now fully integrated and can compete in chess battles alongside GPT, Claude, Gemini, and Grok.
Current Provider Implementations
The platform currently supports four major AI providers with their latest models:
OpenAI: GPT-5, O4 Mini, GPT-4.1 series, O3 Mini
Anthropic: Claude Opus 4.1, Claude Sonnet 4, Claude 3.7 series
Google: Gemini 2.5 Flash, Gemini 2.0 Flash
xAI: Grok 4, Grok 3
Each provider uses optimized API calls with structured JSON output and proper error handling.
Real-Time Chess Architecture
The beauty of this chess platform lies in its event-driven, real-time architecture. Here's how live chess games flow through the system:
Game Creation→ User selects AI models and creates a new game
Move Generation→ AI models generate moves using LLM APIs
Move Validation→ Chess rules validation and board state updates
Stockfish Analysis→ Real-time move evaluation and scoring
Stream Updates→ Live game state propagated to all connected clients
Leaderboard Updates→ AI model rankings updated based on move quality
No manual state management, no complex WebSocket handling, no synchronization code required!
Key Features & Benefits
🎮Real-Time Chess Gameplay
Live games with instant move updates across all connected clients - watch AI models battle in real-time.
🏆Intelligent Scoring System
Move quality evaluation using Stockfish engine with centipawn precision and blunder detection.
🤖Multi-AI Integration
Support for OpenAI GPT, Anthropic Claude, and Google Gemini models with unified API interface.
⚡Event-Driven Architecture
Scalable, maintainable system where each component handles specific chess functionality.
📊Live Leaderboards
Real-time AI model rankings based on move quality, strategic insight, and game performance.
🌐Production-Ready
Battle-tested code powering the live ChessArena.AI platform with global accessibility.
Trying It Out
Ready to build your own AI chess platform? Let's get it running.
Clone and Install
Start by getting the project locally and installing dependencies.
gitclonehttps://github.com/MotiaDev/chessarena-ai.gitcdchessarena-aipnpminstall
gitclonehttps://github.com/MotiaDev/chessarena-ai.gitcdchessarena-aipnpminstall
Install Stockfish Engine
The platform requires Stockfish for move evaluation. Choose your installation method:
Option A: Using Homebrew (macOS - Recommended)
brewinstallstockfish
brewinstallstockfish
Option B: Using the project installer
pnpminstall-stockfish<platform># Supported: linux-x86, mac-m1
pnpminstall-stockfish<platform># Supported: linux-x86, mac-m1
Option C: Manual InstallationDownload fromstockfishchess.org
Configure Environment Variables
Create a.envfile with your AI provider API keys:
.env
# Required: AI Model API KeysOPENAI_API_KEY="sk-..."ANTHROPIC_API_KEY="sk-ant-..."GOOGLE_AI_API_KEY="..."# Required: Stockfish Engine PathSTOCKFISH_BIN_PATH="/opt/homebrew/bin/stockfish"# Optional: Authentication (for user management)JWT_SECRET="your-jwt-secret"
# Required: AI Model API KeysOPENAI_API_KEY="sk-..."ANTHROPIC_API_KEY="sk-ant-..."GOOGLE_AI_API_KEY="..."# Required: Stockfish Engine PathSTOCKFISH_BIN_PATH="/opt/homebrew/bin/stockfish"# Optional: Authentication (for user management)JWT_SECRET="your-jwt-secret"
Start the Chess Platform
Launch both the API backend and React frontend:
pnpmdev
pnpmdev
This starts:
API Backend:http://localhost:3000(Motia API with chess logic)
http://localhost:3000
React Frontend:http://localhost:5173(Chess game interface)
http://localhost:5173
Create Your First AI Battle
Open the Chess Platform: Navigate tohttp://localhost:5173
http://localhost:5173
Select AI Models: Choose different models for white and black players
Start the Game: Watch AI models battle with real-time move evaluation
View Analysis: See centipawn scores, best moves, and blunder detection
Check Leaderboards: Monitor AI model performance rankings
Access Real-Time Data
Your chess games are available via the Motia streams API:
# Get all active gamescurlhttp://localhost:3000/api/streams/chessGame# Get specific game statecurlhttp://localhost:3000/api/streams/chessGame/{gameId}# Get move history with evaluationscurlhttp://localhost:3000/api/streams/chessGameMove/{gameId}# Get AI model leaderboardcurlhttp://localhost:3000/api/streams/chessLeaderboard
# Get all active gamescurlhttp://localhost:3000/api/streams/chessGame# Get specific game statecurlhttp://localhost:3000/api/streams/chessGame/{gameId}# Get move history with evaluationscurlhttp://localhost:3000/api/streams/chessGameMove/{gameId}# Get AI model leaderboardcurlhttp://localhost:3000/api/streams/chessLeaderboard
Deploy to Production
Once your chess platform is working locally, deploy it to production with Motia Cloud:
Option 1: CLI Deployment
# Deploy with version and API keymotiaclouddeploy--api-keyyour-api-key--version-name1.0.0# Deploy with environment variablesmotiaclouddeploy--api-keyyour-api-key\--version-name1.0.0\--env-file.env.production\--environment-idyour-env-id
# Deploy with version and API keymotiaclouddeploy--api-keyyour-api-key--version-name1.0.0# Deploy with environment variablesmotiaclouddeploy--api-keyyour-api-key\--version-name1.0.0\--env-file.env.production\--environment-idyour-env-id
Option 2: One-Click Web Deployment
Ensure your local project is running (pnpm dev)
pnpm dev
Go toMotia Cloud -> Import from Workbench
Select your local project port
Choose project and environment name
Upload environment variables (optional)
ClickDeployand watch the magic happen! ✨
🚀 Production Deployment Guide
Environment Variables
Configure these environment variables for production security and functionality:
# Required: AI Model API KeysOPENAI_API_KEY="sk-your-openai-key"# For GPT-5, O4 Mini, GPT-4.1 seriesANTHROPIC_API_KEY="sk-ant-your-anthropic-key"# For Claude Opus 4.1, Sonnet 4GEMINI_API_KEY="your-google-gemini-key"# For Gemini 2.5 Flash, 2.0 FlashXAI_API_KEY="your-xai-grok-key"# For Grok 4, Grok 3# Required: Stockfish Engine PathSTOCKFISH_BIN_PATH="/opt/homebrew/bin/stockfish"# Optional: Authentication for user managementJWT_SECRET="your-secure-jwt-secret"# Optional: Database configuration for user dataDATABASE_URL="postgresql://user:password@host:port/database"
# Required: AI Model API KeysOPENAI_API_KEY="sk-your-openai-key"# For GPT-5, O4 Mini, GPT-4.1 seriesANTHROPIC_API_KEY="sk-ant-your-anthropic-key"# For Claude Opus 4.1, Sonnet 4GEMINI_API_KEY="your-google-gemini-key"# For Gemini 2.5 Flash, 2.0 FlashXAI_API_KEY="your-xai-grok-key"# For Grok 4, Grok 3# Required: Stockfish Engine PathSTOCKFISH_BIN_PATH="/opt/homebrew/bin/stockfish"# Optional: Authentication for user managementJWT_SECRET="your-secure-jwt-secret"# Optional: Database configuration for user dataDATABASE_URL="postgresql://user:password@host:port/database"
Security Best Practices
For production deployments, ensure you:
Secure API keys:# Generate a cryptographically secure JWT secretopensslrand-hex32
Secure API keys:
# Generate a cryptographically secure JWT secretopensslrand-hex32
# Generate a cryptographically secure JWT secretopensslrand-hex32
Store secrets securely: Use environment variables, never commit API keys to code
Store secrets securely: Use environment variables, never commit API keys to code
Monitor AI usage: Track API usage and costs across different model providers
Monitor AI usage: Track API usage and costs across different model providers
Enable rate limiting: Implement request limits to prevent abuse
Enable rate limiting: Implement request limits to prevent abuse
Scaling Considerations
This architecture scales automatically with your chess platform traffic:
Multiple games: Each game gets its own stream for real-time updates
High concurrency: Motia streams handle thousands of concurrent chess games
Global distribution: Deploy to multiple regions for worldwide performance
AI model optimization: Load balance across different model providers
Cost optimization: Pay only for actual usage with serverless scaling
💻 Dive into the Code
Want to explore the complete chess platform implementation? Check out the full source code with AI integration, real-time streams, and production deployment:
Live ChessArena.AI Platform
Access the complete implementation powering the live chess platform. See exactly how AI models battle with real-time evaluation and scoring!
View ChessArena.AI Code
Play Live Chess →
Conclusion: Intelligence Through Strategic Play
This ChessArena.AI platform demonstrates how to build sophisticated AI evaluation systems using event-driven architecture. By focusing on move quality rather than simple win/loss statistics, we've created a platform that truly measures AI strategic understanding.
The beauty of this approach is its extensibility:
Add new AI models: Integrate any LLM provider with the unified interface
Enhanced analysis: Implement opening book analysis, endgame evaluation
Tournament modes: Multi-round competitions with advanced scoring
Educational features: Move explanations, tactical puzzles, learning modes
Key architectural benefits:
Real-time synchronization: All clients see live game updates automatically
Scalable evaluation: Stockfish analysis runs independently of game flow
Multi-language power: TypeScript orchestration with Python chess engine integration
Production reliability: Battle-tested code handling real user traffic
This exact implementation powers the live chess platform atChessArena.AI- that real-time AI battle system with move-by-move evaluation? It's this code in action, proven at scale with thousands of chess enthusiasts worldwide.
Production Metrics:
Handles 1,000+ concurrent chess games
Processes 10,000+ moves daily with real-time evaluation
Sub-100ms move analysis and streaming updates
99.9% uptime with automatic scaling
Ready to build AI evaluation platforms that measure true intelligence? Deploy production-ready chess systems with Motia today!
Product Showcase
Previous Page
Examples
Next Page
On this page



===== https://www.motia.dev/docs/examples =====

Examples
We have curated examples to help you learn Motia, organized by complexity from basic concepts to production-ready implementations.
📚 Basic Examples
Start here to learn core Motia concepts with straightforward implementations.
Sentiment Analysis
Learn dynamic workflows with LLM-driven decision making and event routing
Multi-Language Processing
Combine TypeScript, Python, and JavaScript in unified data pipelines
🔧 Intermediate Examples
Build more complex workflows with integrations and advanced patterns.
AI Content Moderation
Human-in-the-loop content moderation with AI analysis and Slack integration
RAG PDF Analyzer
Intelligent document processing with Docling and Weaviate vector database
Trello Automation
Automated card progression system with AI-powered summaries and notifications
🏭 Production Examples
Enterprise-ready implementations handling real traffic at scale.
Uptime Monitor
Complete monitoring system with smart alerting and Discord integration
GitHub Stars Counter
Real-time stars counter with secure webhooks and live streaming
GitHub Integration
Automated issue and PR management with AI-powered classification and routing
Gmail Automation
Smart email classification, auto-responses, and AI-powered filtering with OAuth2
Finance Agent
Event-driven financial analysis with web search and real-time market data
AI Research Agent
Comprehensive web research assistant with iterative depth and parallel processing
💻 Explore the Source Code
All examples include complete, runnable source code with configuration files, setup instructions, and production-ready implementations:
Motia Examples Repository
Access complete implementations, step-by-step tutorials, and production-ready configurations for all our examples. Perfect for learning, experimentation, and building your own applications.
Repository
RAG Example →
Monitor Example →
Contribute
We welcome contributions to the examples. Please submit a PR to theexamples repository.
ChessArena AI
Previous Page
Sentiment Analysis
Dynamic Workflows: Building a Sentiment Analyzer with Motia
On this page



===== https://www.motia.dev/docs/examples/sentiment-analysis =====

Sentiment Analysis
Dynamic Workflows: Building a Sentiment Analyzer with Motia
In modern application development, workflows are rarely linear. Whether you're building a simple "prompt => response" system or a complex, multi-stage data processing pipeline, you often need your application to make decisions and route data dynamically. This is where the power of event-driven architecture shines, and where the Motia framework provides a clear path forward.
This guide explores how to build a dynamic sentiment analysis application that uses an LLM to determine how to proceed. We'll cover:
The Motia Philosophy: Howstepsas a core primitive simplify complex architectures.
steps
Building the Workflow: A step-by-step guide to creating the four key components of our application.
Visualizing the Flow: How events chain together to create a cohesive, dynamic system.
Hands-On with the API: How to run and test your new sentiment analyzer.
Let's dive in.
A Step at a Time
At the heart of the Motia framework is a simple but powerful idea: thestep. A step is a self-contained, independent unit of logic that listens for an event, performs a task, and, optionally, emits a new event. This concept is the core primitive that allows you to break down even the most complex architectures into a series of simple, manageable components.
step
Instead of a monolithic application where business logic is tightly coupled, Motia encourages a decoupled, event-driven approach. This has several key advantages:
Clarity: Each step has a single responsibility, making the application easier to understand and reason about.
Scalability: Steps can be scaled independently, so you can allocate resources where they're needed most.
Extensibility: Adding new functionality is as simple as creating a new step and subscribing it to an existing event.
Resilience: The decoupled nature of steps means that a failure in one part of the system doesn't necessarily bring down the entire application.
In this project, we'll see this philosophy in action as we build a sentiment analyzer with four distinct steps, each with its own clear purpose.
The Anatomy of Our Sentiment Analyzer
Our application will be composed of four steps. Let's explore each one.
This is the entry point to our workflow. It's an API step that listens forPOSTrequests, validates the incoming data, and emits anopenai.analyzeSentimentRequestevent.
POST
openai.analyzeSentimentRequest
// Receives user text, emits "openai.analyzeSentimentRequest".import{ Handlers }from'motia'import{ z }from'zod'exportconstconfig={type:'api',name:'analyzeSentimentApi',description:'Receives user text and emits an event to trigger sentiment analysis.',path:'/api/analyze-sentiment',method:'POST',emits: ['openai.analyzeSentimentRequest'],bodySchema: z.object({text: z.string().min(1,'text is required'),}),flows: ['sentiment-demo'],}asconstexportconsthandler:Handlers['analyzeSentimentApi']=async(req, {emit,logger})=>{const{text}=req.bodylogger.info('[AnalyzeSentimentAPI] Received text', { text })// Emit an event to call OpenAIawaitemit({topic:'openai.analyzeSentimentRequest',data: { text },})// Return right awayreturn{status:200,body: { status:'Accepted', message:'Your text is being analyzed'},}}
// Receives user text, emits "openai.analyzeSentimentRequest".import{ Handlers }from'motia'import{ z }from'zod'exportconstconfig={type:'api',name:'analyzeSentimentApi',description:'Receives user text and emits an event to trigger sentiment analysis.',path:'/api/analyze-sentiment',method:'POST',emits: ['openai.analyzeSentimentRequest'],bodySchema: z.object({text: z.string().min(1,'text is required'),}),flows: ['sentiment-demo'],}asconstexportconsthandler:Handlers['analyzeSentimentApi']=async(req, {emit,logger})=>{const{text}=req.bodylogger.info('[AnalyzeSentimentAPI] Received text', { text })// Emit an event to call OpenAIawaitemit({topic:'openai.analyzeSentimentRequest',data: { text },})// Return right awayreturn{status:200,body: { status:'Accepted', message:'Your text is being analyzed'},}}
Explore the Workbench
You can explore the workflow in the Workbench.
You can also read your files and watch logs, traces, debug your architecture directly in the Workbench.
Trying It Out
Ready to see it in action? Let's get the project running.
Install Dependencies
First, install the necessary npm packages.
npminstall
npminstall
Set Your Environment Variables
You'll need an OpenAI API key for this project. Export it as an environment variable.
exportOPENAI_API_KEY="sk-..."
exportOPENAI_API_KEY="sk-..."
Run the Project
Start the Motia development server.
npmrundev
npmrundev
Test the API
Now you can send requests to your API and see the workflow in action.
curl-XPOSThttp://localhost:3000/api/analyze-sentiment\-H"Content-Type: application/json"\-d'{"text":"I absolutely love this new device! It is amazing and works perfectly."}'
curl-XPOSThttp://localhost:3000/api/analyze-sentiment\-H"Content-Type: application/json"\-d'{"text":"I absolutely love this new device! It is amazing and works perfectly."}'
Check your logs, and you should see the[Positive Responder]has been triggered.
[Positive Responder]
curl-XPOSThttp://localhost:3000/api/analyze-sentiment\-H"Content-Type: application/json"\-d'{"text":"This is the worst product I have ever used. It broke after one day."}'
curl-XPOSThttp://localhost:3000/api/analyze-sentiment\-H"Content-Type: application/json"\-d'{"text":"This is the worst product I have ever used. It broke after one day."}'
This time, the[Negative Responder]will fire.
[Negative Responder]
💻 Dive into the Code
Want to explore the complete implementation? Check out the full source code and additional examples in our GitHub repository:
Explore More Examples
Get hands-on with the complete source code, configuration files, and additional examples to accelerate your learning.
View Sentiment Example
More Examples →
Conclusion: The Power of a Simple Primitive
This sentiment analysis application is a powerful demonstration of the Motia philosophy. By embracing thestepas a core primitive, we've turned a potentially complex, branching workflow into a series of simple, understandable, and scalable components.
step
This is just the beginning. From here, you can extend the application by adding new steps to handle neutral sentiment, send notifications, or store results in a database. The event-driven architecture of Motia makes it easy to add new functionality without disrupting the existing flow.
We encourage you to explore, experiment, and see for yourself how Motia can simplify your most complex backend challenges. Happy coding!
Examples
Previous Page
Multi-Language Processing
Multi-Language Data Processing: Building a Unified Pipeline with Motia
On this page



===== https://www.motia.dev/docs/examples/multi-language-data-processing =====

Multi-Language Processing
Multi-Language Data Processing: Building a Unified Pipeline with Motia
Modern backend development often requires combining the strengths of different programming languages. TypeScript for APIs, Python for data processing and AI, JavaScript for rapid prototyping. Traditional approaches involve complex microservices architectures with intricate communication patterns.
This comprehensive guide explores how to build a unified multi-language data processing pipeline using Motia'sstepprimitive. We'll cover:
Steps as Core Primitive: How steps unify different languages under a single abstraction.
Building the Pipeline: A step-by-step guide to creating a cohesive multi-language data processing workflow.
Unified Execution Model: How steps enable seamless communication between different runtime environments.
Hands-On Development: How to build, run, and observe your unified multi-language pipeline.
Let's build a production-ready data processing system where steps unify TypeScript, Python, and JavaScript into a single cohesive workflow.
The Power of Steps: A Unified Multi-Language Primitive
At its core, our data processing pipeline demonstrates howstepssolve the fundamental challenge of multi-language systems: unifying different programming languages under a single, coherent abstraction. Traditional polyglot architectures require complex inter-process communication and deployment coordination. Motia'sstepprimitive unifies everything.
Steps enable true language unification:
TypeScriptsteps: Strong typing and excellent tooling for APIs and orchestration
Pythonsteps: Rich ecosystem for data processing, ML, and scientific computing
JavaScriptsteps: Dynamic processing and rapid development
Motia's Step Primitive: The unifying abstraction that makes all languages work as a single system
Instead of managing multiple services,stepsprovide a single programming model. Whether written in TypeScript, Python, or JavaScript, every step follows the same pattern: receive data, process it, emit events. This unification is what makes multi-language development straightforward.
The Anatomy of Our Multi-Language Pipeline
Our application consists of six specialized steps, each leveraging the optimal language for its specific task. Let's explore the complete architecture.
The entry point for our multi-language workflow. This TypeScript API endpoint receives data, validates it with Zod schemas, and kicks off the processing pipeline.
import{ z }from'zod'constbodySchema=z.object({data: z.record(z.unknown()).optional(),message: z.string().optional()})// API endpoint to start the multi-language pipelineexportconstconfig={type:'api',name:'AppStarter',description:'Start the multi-language app pipeline',method:'POST',path:'/start-app',bodySchema,responseSchema: {200: z.object({message: z.string(),appId: z.number(),traceId: z.string()})},emits: ['app.started'],flows: ['data-processing']}asconstexportconsthandler=async(req:any, {logger,emit,traceId}:any)=>{logger.info('🚀 Starting multi-language app', { body: req.body, traceId })constappData={id: Date.now(),input: req.body.data||{},started_at:newDate().toISOString(),traceId}// Emit to next stepawaitemit({topic:'app.started',data: appData})logger.info('✅ App started successfully', {appId: appData.id,traceId})return{status:200,body: {message:'Multi-language app started successfully',appId: appData.id,traceId}}}
import{ z }from'zod'constbodySchema=z.object({data: z.record(z.unknown()).optional(),message: z.string().optional()})// API endpoint to start the multi-language pipelineexportconstconfig={type:'api',name:'AppStarter',description:'Start the multi-language app pipeline',method:'POST',path:'/start-app',bodySchema,responseSchema: {200: z.object({message: z.string(),appId: z.number(),traceId: z.string()})},emits: ['app.started'],flows: ['data-processing']}asconstexportconsthandler=async(req:any, {logger,emit,traceId}:any)=>{logger.info('🚀 Starting multi-language app', { body: req.body, traceId })constappData={id: Date.now(),input: req.body.data||{},started_at:newDate().toISOString(),traceId}// Emit to next stepawaitemit({topic:'app.started',data: appData})logger.info('✅ App started successfully', {appId: appData.id,traceId})return{status:200,body: {message:'Multi-language app started successfully',appId: appData.id,traceId}}}
Type Definitions
Our unified system uses shared TypeScript types to ensure type safety across the multi-language pipeline:
// types/index.tsexportinterfaceAppData{id:numberinput:Record<string,unknown>started_at:stringtraceId:string}exportinterfaceProcessedResult{original_id:numberprocessed_at:stringresult:stringconfidence:numbermodel_version:string}exportinterfacePythonResult{id:numberpython_message:stringprocessed_by:string[]processing_time:number}exportinterfaceNotificationData{id:numbermessage:stringprocessed_by:string[]sent_at:string}exportinterfaceAppSummary{appId:numberstatus:stringcompleted_at:stringsteps_executed:string[]result:string}
// types/index.tsexportinterfaceAppData{id:numberinput:Record<string,unknown>started_at:stringtraceId:string}exportinterfaceProcessedResult{original_id:numberprocessed_at:stringresult:stringconfidence:numbermodel_version:string}exportinterfacePythonResult{id:numberpython_message:stringprocessed_by:string[]processing_time:number}exportinterfaceNotificationData{id:numbermessage:stringprocessed_by:string[]sent_at:string}exportinterfaceAppSummary{appId:numberstatus:stringcompleted_at:stringsteps_executed:string[]result:string}
Explore the Workbench
The Motia Workbench provides a visual representation of your multi-language pipeline, making it easy to trace data flow between TypeScript, Python, and JavaScript steps.
You can monitor real-time execution, view logs from all languages in a unified interface, and trace the complete data flow from the TypeScript API through Python processing to JavaScript summary generation.
Event Flow Architecture
The pipeline follows a clear event-driven flow that connects all languages seamlessly:
app.started- TypeScript API → TypeScript Bridge
app.started
data.processed- TypeScript Bridge → Python Processor
data.processed
python.done- Python Processor → TypeScript Notification Handler
python.done
notification.sent- TypeScript Notification → TypeScript Finalizer
notification.sent
app.completed- TypeScript Finalizer → JavaScript Summary Generator
app.completed
Each step only needs to know the events it subscribes to and emits, creating loose coupling while maintaining strong data flow guarantees.
Key Features & Benefits
🧩Step as Universal Primitive
Every piece of logic—whether TypeScript, Python, or JavaScript—follows the same step pattern, creating true unification.
🌐Seamless Language Integration
Steps eliminate the complexity of multi-language systems by providing a unified programming model.
📊Unified Development Experience
Write, debug, and monitor all languages through a single interface and shared execution model.
⚡Hot Reload Across Languages
Edit any step in any language and see changes instantly across the entire pipeline.
🔄Event-Driven Communication
Steps communicate through events, enabling loose coupling and independent scaling.
🎯Single Deployment Model
Deploy all languages together as a cohesive system, not as separate microservices.
🐍Python Step Naming
Python steps use the_step.pysuffix convention for proper module resolution (e.g.,simple-python_step.py).
_step.py
simple-python_step.py
Trying It Out
Ready to build your first multi-language Motia application? Let's get it running.
Create Your Motia App
Start by creating a new Motia project with the interactive setup.
npxmotia@latestcreate
npxmotia@latestcreate
Navigate and Start Development
Move into your project directory and start the development server.
cdmy-app# Replace with your project namenpmrundev
cdmy-app# Replace with your project namenpmrundev
Open the Workbench
Navigate tohttp://localhost:3000to access the Workbench and run your workflow.
http://localhost:3000
Test the Multi-Language Pipeline
Send a request to your API endpoint to see the multi-language workflow in action:
curl-XPOSThttp://localhost:3000/start-app\-H"Content-Type: application/json"\-d'{"data": {"test": "value"}, "message": "Hello!"}'
curl-XPOSThttp://localhost:3000/start-app\-H"Content-Type: application/json"\-d'{"data": {"test": "value"}, "message": "Hello!"}'
Watch in the Workbench as your data flows through:
TypeScriptvalidation and event emission
TypeScriptbridge processing and forwarding
Pythondata processing with rich logging
TypeScriptnotification handling
TypeScriptfinalization and aggregation
JavaScriptsummary generation and metrics
💻 Dive into the Code
Want to explore multi-language workflows further? Check out additional examples and the complete source code:
Multi-Language Examples
Access complete multi-language implementations, configuration examples, and learn how to integrate TypeScript, Python, and JavaScript in production applications.
Explore Examples
Quick Start →
Conclusion: The Power of Unification Through Steps
This multi-language data processing pipeline demonstrates howstepsfundamentally change multi-language development. By providing a single primitive that works across TypeScript, Python, and JavaScript, we've eliminated the traditional complexity of polyglot architectures.
The step primitive enables true unification:
Universal Pattern- Every step, regardless of language, follows the same receive-process-emit pattern
Seamless Integration- Add Ruby, Go, Rust, or any language using the same step abstraction
Unified Deployment- All languages deploy together as a single, coherent system
Shared Development Model- Write, debug, and monitor everything through the same interface
Key benefits of step-based unification:
Single Mental Model- Learn the step pattern once, apply it to any language
Cohesive System- All components work together as parts of one application, not separate services
Consistent Experience- Development, debugging, and monitoring work the same way across all languages
Natural Scaling- Each step can scale independently while maintaining system coherence
Extend your pipeline with more steps:
Add specialized processing steps for different data types and business logic
Integrate machine learning workflows with Python steps for AI processing
Build real-time analytics with streaming steps for live data processing
Connect to enterprise systems through database and API integration steps
Implement scheduled processing with cron steps for batch operations
Thestep primitivemakes all extensions natural and straightforward—every new capability follows the same unified pattern.
Ready to unify your multi-language systems? Start building with steps today!
Sentiment Analysis
Dynamic Workflows: Building a Sentiment Analyzer with Motia
AI Content Moderation
Intelligent Content Moderation: Building Human-in-the-Loop Systems with Motia
On this page



===== https://www.motia.dev/docs/examples/ai-content-moderation =====

AI Content Moderation
Intelligent Content Moderation: Building Human-in-the-Loop Systems with Motia
In today's digital landscape, content moderation is crucial for maintaining safe and appropriate user experiences. Whether you're building a social platform, forum, or any user-generated content system, you need intelligent moderation that can scale with your user base while maintaining human oversight for complex decisions.
This comprehensive guide explores how to build a production-ready content moderation system using Motia's event-driven architecture. We'll cover:
AI-Powered Analysis: Using OpenAI for text toxicity detection and image safety analysis
Confidence-Based Routing: Automatically handling clear cases while flagging uncertain content for human review
Slack Integration: Creating interactive moderation workflows within existing team communication tools
Human-in-the-Loop: Seamlessly integrating human decision-making into automated processes
Let's build a content moderation system that scales intelligently.
The Power of Intelligent Content Moderation
At its core, our content moderation system solves a fundamental challenge: how do you efficiently moderate user-generated content at scale while maintaining human oversight for complex decisions? Traditional approaches often involve either fully manual processes that don't scale or fully automated systems that lack nuance.
Our Motia-powered solution combines the best of both worlds through intelligent routing:
OpenAI Integration: Advanced AI analysis for text toxicity and image safety detection
Confidence-Based Routing: Automatic handling of clear cases, human review for uncertain content
Slack Integration: Interactive moderation workflows within existing team communication tools
Motia Framework: Event-driven orchestration with built-in state management and error handling
Instead of a monolithic moderation system, we get a flexible architecture where each component can be scaled, modified, or replaced independently.
The Anatomy of Our Content Moderation System
Our application consists of six specialized steps, each handling a specific part of the moderation workflow. Let's explore the complete architecture.
The entry point for content moderation. This API endpoint receives user-generated content (text and/or images) and initiates the moderation workflow.
import{ z }from"zod";import{ ApiRouteConfig, Handlers }from"motia";constContentSubmitInputSchema=z.object({text: z.string().optional(),imageUrl: z.string().optional(),userId: z.string(),platform: z.string(),});exportconstconfig:ApiRouteConfig={type:"api",name:"ContentSubmitAPI",description:"Receives user-generated content for moderation",path:"/content/submit",method:"POST",bodySchema: ContentSubmitInputSchema,emits: ["content.submitted"],flows: ["content-moderation"],};exportconsthandler:Handlers["ContentSubmitAPI"]=async(req,{logger,emit})=>{const{text,imageUrl,userId,platform}=req.body;constsubmissionId=`sub_${Date.now()}_${Math.random().toString(36).slice(2,11)}`;logger.info(`Content submitted for moderation`, {submissionId,hasText:!!text,hasImage:!!imageUrl,userId,platform,});awaitemit({topic:"content.submitted",data: {submissionId,text,imageUrl,userId,platform,timestamp:newDate().toISOString(),},});return{status:200,body: {message:"Content submitted for moderation",submissionId,},};};
import{ z }from"zod";import{ ApiRouteConfig, Handlers }from"motia";constContentSubmitInputSchema=z.object({text: z.string().optional(),imageUrl: z.string().optional(),userId: z.string(),platform: z.string(),});exportconstconfig:ApiRouteConfig={type:"api",name:"ContentSubmitAPI",description:"Receives user-generated content for moderation",path:"/content/submit",method:"POST",bodySchema: ContentSubmitInputSchema,emits: ["content.submitted"],flows: ["content-moderation"],};exportconsthandler:Handlers["ContentSubmitAPI"]=async(req,{logger,emit})=>{const{text,imageUrl,userId,platform}=req.body;constsubmissionId=`sub_${Date.now()}_${Math.random().toString(36).slice(2,11)}`;logger.info(`Content submitted for moderation`, {submissionId,hasText:!!text,hasImage:!!imageUrl,userId,platform,});awaitemit({topic:"content.submitted",data: {submissionId,text,imageUrl,userId,platform,timestamp:newDate().toISOString(),},});return{status:200,body: {message:"Content submitted for moderation",submissionId,},};};
Explore the Workbench
The Motia Workbench provides a visual representation of your content moderation pipeline, making it easy to understand the flow and monitor moderation decisions in real-time.
You can monitor real-time content analysis, view Slack notifications, and trace the execution of each moderation decision directly in the Workbench interface. This makes development and debugging significantly easier compared to traditional monolithic moderation systems.
Human-in-the-Loop Workflow Demo
Let's see the complete human-in-the-loop process in action using a real example. We'll submit problematic content and watch it flow through the moderation pipeline.
Step 1: Submit Content for Moderation
Submit the sample content that should trigger human review:
curl-XPOSThttp://localhost:3000/content/submit\-H"Content-Type: application/json"\-d'{"text": "I hate this stupid garbage, it\'scompletetrashandmakesmewanttohurtsomeone","userId": "user456","platform": "web"}'
curl-XPOSThttp://localhost:3000/content/submit\-H"Content-Type: application/json"\-d'{"text": "I hate this stupid garbage, it\'scompletetrashandmakesmewanttohurtsomeone","userId": "user456","platform": "web"}'
Step 2: AI Analysis & Routing
The system will:
Analyze the contentusing OpenAI's GPT-4 for toxicity detection
Calculate risk scoresbased on detected harmful content
Route for human reviewsince the content contains hate speech and violence references
You'll see logs like:
Content submitted for moderation: submissionId=sub_123, hasText=true, userId=user456Starting content analysis: submissionId=sub_123, hasText=trueContent analysis completed: submissionId=sub_123, overallScore=0.87, textScore=0.87Content needs human review: submissionId=sub_123, overallScore=0.87
Content submitted for moderation: submissionId=sub_123, hasText=true, userId=user456Starting content analysis: submissionId=sub_123, hasText=trueContent analysis completed: submissionId=sub_123, overallScore=0.87, textScore=0.87Content needs human review: submissionId=sub_123, overallScore=0.87
Step 3: Slack Notification for Human Review
The system automatically sends an interactive message to your moderation team in Slack:
The Slack message includes:
Risk score: 87% confidence of harmful content
Priority level: HIGH (since score ≥ 70%)
AI analysis: Detailed breakdown of detected issues
Interactive buttons: Approve, Reject, or Escalate options
Step 4: Human Decision & Execution
When a moderator clicks a button in Slack:
Decision is recordedwith moderator attribution
Content is processedaccording to the decision
User is notifiedof the moderation outcome
Audit trail is maintainedfor compliance
The complete workflow demonstrates how AI handles the initial analysis while humans provide the final judgment for nuanced decisions.
Key Features & Benefits
🤖AI-Powered Analysis
Advanced OpenAI integration for both text toxicity detection and image safety analysis with confidence scoring.
🎯Intelligent Routing
Confidence-based decision making that automatically handles clear cases while flagging uncertain content for human review.
💬Slack Integration
Interactive moderation workflows within existing team communication tools - no custom dashboard required.
👥Human-in-the-Loop
Seamless integration of human decision-making with approve/reject/escalate buttons and contextual information.
📊Priority-Based Routing
Content is routed to different Slack channels based on risk level and urgency.
🔒Security & Compliance
Built-in signature verification, audit trails, and comprehensive logging for compliance requirements.
Getting Started
Ready to build your own intelligent content moderation system? Here's how to set it up and run it.
1. Install Dependencies
Install the necessary npm packages and set up the development environment.
npminstall
npminstall
2. Configure Environment Variables
Create a.envfile with your API keys and Slack configuration:
.env
# Required: OpenAI API key for content analysisOPENAI_API_KEY="sk-..."# Required: Slack bot configurationSLACK_BOT_TOKEN="xoxb-your-bot-token"SLACK_SIGNING_SECRET="your-signing-secret"# Required: Slack channels for different priority levelsSLACK_CHANNEL_MODERATION="C1234567890"# Normal prioritySLACK_CHANNEL_URGENT="C0987654321"# High prioritySLACK_CHANNEL_ESCALATED="C1122334455"# Escalated content
# Required: OpenAI API key for content analysisOPENAI_API_KEY="sk-..."# Required: Slack bot configurationSLACK_BOT_TOKEN="xoxb-your-bot-token"SLACK_SIGNING_SECRET="your-signing-secret"# Required: Slack channels for different priority levelsSLACK_CHANNEL_MODERATION="C1234567890"# Normal prioritySLACK_CHANNEL_URGENT="C0987654321"# High prioritySLACK_CHANNEL_ESCALATED="C1122334455"# Escalated content
3. Set Up Slack Integration
Create a Slack app with the following permissions:chat:write- Send messages to channelschannels:read- Access channel information
chat:write- Send messages to channels
chat:write
channels:read- Access channel information
channels:read
Enable Interactive Components and set webhook URL to:https://your-domain.com/slack/webhook
https://your-domain.com/slack/webhook
Install the app to your workspace
Copy the bot token and signing secret to your.envfile
.env
4. Run the Moderation System
Start the Motia development server to begin processing content.
npmrundev
npmrundev
Advanced Configuration
Adjusting Confidence Thresholds
Modify the decision thresholds in the content router step:
// In 03-content-router.step.tsif(overallScore<=0.05) {decision="approved";// Auto-approve threshold (5%)}elseif(overallScore>=0.95) {decision="rejected";// Auto-reject threshold (95%)}else{decision="review";// Human review range (5-95%)}
// In 03-content-router.step.tsif(overallScore<=0.05) {decision="approved";// Auto-approve threshold (5%)}elseif(overallScore>=0.95) {decision="rejected";// Auto-reject threshold (95%)}else{decision="review";// Human review range (5-95%)}
Custom Channel Routing
Implement custom routing logic based on content type or user behavior:
// Route based on user history or content typeconstchannel=getChannelForContent(contentType, userHistory, riskScore);
// Route based on user history or content typeconstchannel=getChannelForContent(contentType, userHistory, riskScore);
Integration with External Systems
Extend the action executor to integrate with your existing systems:
// In 06-action-executor.step.tscase"approved":awaitpublishContent(submissionId);awaitnotifyUser(userId,"Your content has been approved");break;
// In 06-action-executor.step.tscase"approved":awaitpublishContent(submissionId);awaitnotifyUser(userId,"Your content has been approved");break;
💻 Dive into the Code
Want to explore the complete content moderation implementation? Check out the full source code, including all steps, Slack integration, and production-ready configuration:
Complete Content Moderation System
Access the full implementation with AI analysis, Slack integration, and human-in-the-loop workflows.
View Content Moderation Example
More Examples →
Conclusion: Intelligent Content Moderation at Scale
This content moderation system demonstrates the power of combining AI analysis with human oversight in an event-driven architecture. By breaking down moderation into discrete, specialized components, we've created a system that's not only intelligent but also flexible and maintainable.
The human-in-the-loop approach means you can:
Scale efficiently: Automatically handle 80-90% of content while maintaining quality
Adapt quickly: Adjust thresholds and routing logic without system changes
Maintain oversight: Human moderators focus on complex cases that require judgment
Integrate seamlessly: Use existing team communication tools like Slack
Key architectural benefits:
Intelligent routing: Confidence-based decisions reduce human workload
Flexible integration: Works with any team communication platform
Audit compliance: Complete decision trails and moderator attribution
Scalable architecture: Each component can be scaled independently
From here, you can extend the system by:
Adding support for video content moderation
Implementing custom AI models for specific content types
Building analytics dashboards for moderation insights
Integrating with user management and content management systems
Adding escalation policies and moderator workflows
The event-driven architecture makes all of these extensions straightforward to implement without disrupting the existing moderation pipeline.
Ready to build content moderation that scales with your platform? Start building with Motia today!
Multi-Language Processing
Multi-Language Data Processing: Building a Unified Pipeline with Motia
RAG PDF Analyzer
Intelligent Document Processing: Building a RAG System with Motia
On this page



===== https://www.motia.dev/docs/examples/rag-docling-weaviate =====

RAG PDF Analyzer
Intelligent Document Processing: Building a RAG System with Motia
In the era of AI-powered applications, the ability to extract insights from documents is crucial. Whether you're building a knowledge base, a research assistant, or a customer support system, you need to transform static PDFs into queryable, intelligent systems. This is where Retrieval-Augmented Generation (RAG) architecture shines, and where the Motia framework provides an elegant solution.
This comprehensive guide explores how to build a production-ready RAG system that intelligently processes PDFs and answers questions about their content. We'll cover:
The RAG Architecture: Understanding how document processing, vector storage, and AI generation work together.
Motia's Event-Driven Approach: Howstepscreate a scalable, maintainable RAG pipeline.
steps
Building the Workflow: A detailed walkthrough of our polyglot processing pipeline.
Advanced Features: Real-time progress tracking, error handling, and production considerations.
Hands-On Testing: How to ingest documents and query your knowledge base.
Let's transform your documents into an intelligent AI assistant.
The Power of Intelligent Document Processing
At its core, our RAG agent solves a fundamental challenge: how do you make unstructured documents searchable and queryable by AI? Traditional approaches often involve complex, monolithic systems that are difficult to scale and maintain. Our Motia-powered solution breaks this down into discrete, event-driven steps that each handle a specific aspect of the pipeline.
The magic happens through the integration of three powerful technologies:
Docling: Advanced PDF parsing with intelligent chunking that preserves document structure
Weaviate: Cloud-native vector database with built-in OpenAI integration
Motia: Event-driven framework that orchestrates the entire pipeline
Instead of a brittle, tightly-coupled system, we get a resilient architecture where each component can be scaled, modified, or replaced independently.
The Anatomy of Our RAG Pipeline
Our application consists of seven specialized steps, each handling a specific part of the document processing and querying workflow. Let's explore the complete architecture.
The entry point for document ingestion. This API endpoint receives a folder path, kicks off the processing pipeline, and returns immediately with a tracking ID for real-time progress monitoring.
import{ Handlers }from'motia'import{ z }from'zod'import{ v4asuuidv4 }from'uuid'exportconstconfig={type:'api',name:'api-process-pdfs',description:'API endpoint to start PDF processing pipeline',path:'/api/rag/process-pdfs',method:'POST',emits: ['rag.read.pdfs'],bodySchema: z.object({folderPath: z.string().min(1,'folderPath is required'),}),flows: ['rag-workflow'],}asconstexportconsthandler:Handlers['api-process-pdfs']=async(req, {emit,logger})=>{const{folderPath}=req.bodyconststreamId=uuidv4()logger.info('Starting PDF processing pipeline', { folderPath, streamId })// Emit event to start the processing chainawaitemit({topic:'rag.read.pdfs',data: { folderPath, streamId },})return{status:200,body: {message:'PDF processing started',streamId,status:'processing'},}}
import{ Handlers }from'motia'import{ z }from'zod'import{ v4asuuidv4 }from'uuid'exportconstconfig={type:'api',name:'api-process-pdfs',description:'API endpoint to start PDF processing pipeline',path:'/api/rag/process-pdfs',method:'POST',emits: ['rag.read.pdfs'],bodySchema: z.object({folderPath: z.string().min(1,'folderPath is required'),}),flows: ['rag-workflow'],}asconstexportconsthandler:Handlers['api-process-pdfs']=async(req, {emit,logger})=>{const{folderPath}=req.bodyconststreamId=uuidv4()logger.info('Starting PDF processing pipeline', { folderPath, streamId })// Emit event to start the processing chainawaitemit({topic:'rag.read.pdfs',data: { folderPath, streamId },})return{status:200,body: {message:'PDF processing started',streamId,status:'processing'},}}
Explore the Workbench
The Motia Workbench provides a visual representation of your RAG pipeline, making it easy to understand the flow and debug any issues.
You can monitor real-time processing, view logs, and trace the execution of each step directly in the Workbench interface. This makes development and debugging significantly easier compared to traditional monolithic approaches.
Key Features & Benefits
🚀Event-Driven Architecture
Each step is independent and communicates through events, making the system highly scalable and maintainable.
🧠Intelligent Document Processing
Docling's hybrid chunking preserves document structure while creating optimal chunks for embedding.
⚡High-Performance Vector Search
Weaviate's cloud-native architecture provides fast, scalable similarity search with built-in OpenAI integration.
🔄Real-Time Progress Tracking
Monitor document processing progress with detailed logging and status updates.
🌐Polyglot Support
Seamlessly combine Python (Docling) and TypeScript (orchestration) in a single workflow.
🛡️Production-Ready
Built-in error handling, batch processing, and resource cleanup ensure reliability.
Trying It Out
Ready to build your own intelligent document assistant? Let's get the system running.
Install Dependencies
Install both Node.js and Python dependencies. The prepare script automatically sets up the Python virtual environment.
npminstall
npminstall
Set Your Environment Variables
You'll need API keys for OpenAI and Weaviate Cloud. Create a.envfile:
.env
OPENAI_API_KEY="sk-..."WEAVIATE_URL="https://your-cluster.weaviate.network"WEAVIATE_API_KEY="your-weaviate-api-key"
OPENAI_API_KEY="sk-..."WEAVIATE_URL="https://your-cluster.weaviate.network"WEAVIATE_API_KEY="your-weaviate-api-key"
Run the Project
Start the Motia development server to begin processing documents.
npmrundev
npmrundev
Process Your First Documents
Add some PDF files to thedocs/pdfs/folder, then start the ingestion pipeline:
docs/pdfs/
curl-XPOSThttp://localhost:3000/api/rag/process-pdfs\-H"Content-Type: application/json"\-d'{"folderPath":"docs/pdfs"}'
curl-XPOSThttp://localhost:3000/api/rag/process-pdfs\-H"Content-Type: application/json"\-d'{"folderPath":"docs/pdfs"}'
Watch the logs as your documents are processed through the pipeline:
PDF Reading: Files are discovered and queued
Docling Processing: Intelligent chunking with structure preservation
Weaviate Loading: Chunks are embedded and stored
Query Your Knowledge Base
Once processing is complete, you can ask questions about your documents:
curl-XPOSThttp://localhost:3000/api/rag/query\-H"Content-Type: application/json"\-d'{"query":"What are the main topics covered in these documents?","limit":3}'
curl-XPOSThttp://localhost:3000/api/rag/query\-H"Content-Type: application/json"\-d'{"query":"What are the main topics covered in these documents?","limit":3}'
curl-XPOSThttp://localhost:3000/api/rag/query\-H"Content-Type: application/json"\-d'{"query":"What methodology was used in the research?","limit":5}'
curl-XPOSThttp://localhost:3000/api/rag/query\-H"Content-Type: application/json"\-d'{"query":"What methodology was used in the research?","limit":5}'
The response includes both a generated answer and the source chunks with page numbers for verification.
Advanced Usage
Custom Chunking Strategies
Modify the Python processing step to implement custom chunking logic:
# In process-pdfs.step.pychunker=HybridChunker(tokenizer="cl100k_base",max_tokens=1024,# Larger chunks for more contextoverlap_tokens=100,# More overlap for better continuityheading_hierarchies=True,split_by_page=True# Preserve page boundaries)
# In process-pdfs.step.pychunker=HybridChunker(tokenizer="cl100k_base",max_tokens=1024,# Larger chunks for more contextoverlap_tokens=100,# More overlap for better continuityheading_hierarchies=True,split_by_page=True# Preserve page boundaries)
Batch Processing Optimization
Adjust batch sizes in the Weaviate loading step for optimal performance:
// In load-weaviate.step.tsconstBATCH_SIZE=50// Smaller batches for large documents
// In load-weaviate.step.tsconstBATCH_SIZE=50// Smaller batches for large documents
Multi-Collection Support
Extend the system to handle different document types by creating separate Weaviate collections:
constCOLLECTIONS={research:'ResearchPapers',manuals:'TechnicalManuals',reports:'BusinessReports'}
constCOLLECTIONS={research:'ResearchPapers',manuals:'TechnicalManuals',reports:'BusinessReports'}
Troubleshooting
Common Issues
ENOENT Path Errors: The system automatically handles path normalization, but ensure yourfolderPathis relative to the project root.
folderPath
Empty Answers: Check that documents were successfully processed by examining the logs. Verify your OpenAI API key is valid.
Weaviate Connection Issues: Ensure yourWEAVIATE_URLandWEAVIATE_API_KEYare correct and your cluster is running.
WEAVIATE_URL
WEAVIATE_API_KEY
Performance Tips
Document Size: For large PDFs, consider preprocessing to split them into smaller files
Batch Size: Adjust the Weaviate batch size based on your cluster's capacity
Chunking Strategy: Experiment with different chunk sizes and overlap for your specific use case
💻 Dive into the Code
Want to explore the complete RAG implementation? Check out the full source code, including all steps, configuration files, and setup instructions:
Complete RAG Implementation
Access the full source code for this RAG agent, including Python processing scripts, TypeScript orchestration, and production configuration.
View RAG Example
More Examples →
Conclusion: The Future of Document Intelligence
This RAG system demonstrates the power of combining best-in-class technologies with Motia's event-driven architecture. By breaking down complex document processing into discrete, manageable steps, we've created a system that's not only powerful but also maintainable and scalable.
The polyglot nature of the solution: Python for document processing, TypeScript for orchestration, shows how Motia enables you to use the right tool for each job without sacrificing integration or maintainability.
From here, you can extend the system by:
Adding support for other document formats (Word, PowerPoint, etc.)
Implementing document classification and routing
Adding real-time document updates and synchronization
Building a web interface for document management
Integrating with existing business systems
The event-driven architecture makes all of these extensions straightforward to implement without disrupting the existing pipeline.
Ready to transform your documents into intelligent, queryable knowledge bases? Start building with Motia today!
AI Content Moderation
Intelligent Content Moderation: Building Human-in-the-Loop Systems with Motia
Trello Automation
Build an automated card progression system for Trello boards with AI-powered summaries
On this page



===== https://www.motia.dev/docs/examples/trello-automation =====

Trello Automation
Build an automated card progression system for Trello boards with AI-powered summaries
Let's build a Trello automation system that:
Automatically progresses cards across board lists
Validates card completeness
Generates AI-powered summaries for code review
Integrates with Slack for notifications
Monitors due dates and sends overdue alerts
Board Structure
The Trello board is organized into four main lists:
New Cards: Entry point for all new cards
In Progress: Active development stage
Needs Review: Code review stage with AI summaries
Completed: Successfully reviewed and approved cards
The Steps
Visual Overview
Here's how the automation flow works:
Card Validation→ Checks for required information
Progress Tracking→ Moves cards between lists
Review Process→ Generates AI summaries and notifies reviewers
Completion Handling→ Processes approved cards
Try It Out
Prerequisites
Make sure you have:
Trello account with API access
Node.js installed
Slack workspace (for notifications)
OpenAI API key (for AI summaries)
Clone the Repository
gitclonegit@github.com:MotiaDev/motia-examples.gitcdexamples/trello-flow
gitclonegit@github.com:MotiaDev/motia-examples.gitcdexamples/trello-flow
Install Dependencies
pnpminstall
pnpminstall
Configure Environment Variables
Create a.envfile by copying the example:
.env
cp.env.example.env
cp.env.example.env
Update your.envwith the following credentials:
.env
TRELLO_API_KEY=your_trello_api_keyTRELLO_TOKEN=your_trello_tokenOPENAI_API_KEY=your_openai_api_keyOPENAI_MODEL=your_openai_modelSLACK_WEBHOOK_URL=your_slack_webhook_urlTRELLO_NEW_TASKS_LIST_ID=your_new_tasks_list_idTRELLO_IN_PROGRESS_LIST_ID=your_in_progress_list_idTRELLO_NEEDS_REVIEW_LIST_ID=your_needs_review_list_idTRELLO_COMPLETED_LIST_ID=your_completed_list_id
TRELLO_API_KEY=your_trello_api_keyTRELLO_TOKEN=your_trello_tokenOPENAI_API_KEY=your_openai_api_keyOPENAI_MODEL=your_openai_modelSLACK_WEBHOOK_URL=your_slack_webhook_urlTRELLO_NEW_TASKS_LIST_ID=your_new_tasks_list_idTRELLO_IN_PROGRESS_LIST_ID=your_in_progress_list_idTRELLO_NEEDS_REVIEW_LIST_ID=your_needs_review_list_idTRELLO_COMPLETED_LIST_ID=your_completed_list_id
Set Up Trello Board
Create a new Trello board with these lists:New TasksIn ProgressNeeds ReviewCompleted
Create a new Trello board with these lists:
New Tasks
In Progress
Needs Review
Completed
Add a custom field:Status (dropdown: Todo, In Progress, Done)
Add a custom field:
Status (dropdown: Todo, In Progress, Done)
Run the Application
pnpmdev
pnpmdev
Test the Flow
Create a new card in the "New Tasks" list
Assign a member to see it move to "In Progress"
Add an "approved" comment to see it move to "Completed"
Check Slack for notifications
For more detailed setup instructions and configuration options, check out thefull
documentation.
RAG PDF Analyzer
Intelligent Document Processing: Building a RAG System with Motia
Uptime Monitor
Real-Time Uptime Monitoring: Building a Resilient Website Monitor with Motia
On this page



===== https://www.motia.dev/docs/examples/uptime-discord-monitor =====

Uptime Monitor
Real-Time Uptime Monitoring: Building a Resilient Website Monitor with Motia
In today's modern era, website uptime is critical for business success. Whether you're monitoring a personal blog or enterprise applications, you need a reliable system that can detect outages, send alerts, and provide visibility into your site's health. Traditional monitoring solutions often involve complex infrastructure and vendor lock-in, but there's a better way.
This comprehensive guide explores how to build a production-ready uptime monitoring system using Motia's event-driven architecture. We'll cover:
Event-Driven Monitoring: How Motia'sstepscreate a scalable, maintainable monitoring pipeline.
steps
Building the Architecture: A detailed walkthrough of our five-component monitoring system.
Smart Alerting: Implementing rate limiting and status change detection to prevent spam.
Let's build a monitoring system that actually works for you.
The Power of Event-Driven Monitoring
At its core, our uptime monitoring system solves a fundamental challenge: how do you continuously monitor multiple websites without creating a brittle, monolithic application? Traditional monitoring tools often suffer from tight coupling, making them difficult to scale and customize. Our Motia-powered solution breaks this down into discrete, event-driven components that each handle a specific aspect of monitoring.
The magic happens through the integration of proven technologies and patterns:
Cron-Based Scheduling: Configurable check intervals using familiar cron expressions
Discord Webhooks: Instant notifications with rich formatting
Token Bucket Rate Limiting: Intelligent alert throttling to prevent spam
Motia Framework: Event-driven orchestration with built-in observability
Instead of a monolithic monitoring daemon, we get a resilient architecture where each component can be scaled, modified, or replaced independently.
The Anatomy of Our Monitoring System
Our application consists of five specialized steps, each handling a specific part of the monitoring workflow. Let's explore the complete architecture.
The heartbeat of our monitoring system. This cron-triggered step periodically emits check requests for all configured websites, acting as the central scheduler.
import{ configasenvConfig }from'../lib/env.js';exportconstconfig={type:'cron',name:'UptimeCronTrigger',cron: envConfig.cron,emits: ['check.requested'],flows: ['uptime-monitoring']};exportasyncfunctionhandler(context) {context.logger.info(`Starting uptime checks for ${envConfig.sites.length} sites`);context.logger.info(`Sites configured: ${JSON.stringify(envConfig.sites)}`);try{// Emit one check.requested event per configured site URLfor(consturlofenvConfig.sites) {context.logger.info(`Scheduling check for: ${url}`);awaitcontext.emit({topic:'check.requested',data: { url: url }});context.logger.info(`Successfully emitted for: ${url}`);}context.logger.info(`Successfully scheduled checks for all ${envConfig.sites.length} sites`);}catch(error) {context.logger.error('Error during cron execution:', error);throwerror;}}
import{ configasenvConfig }from'../lib/env.js';exportconstconfig={type:'cron',name:'UptimeCronTrigger',cron: envConfig.cron,emits: ['check.requested'],flows: ['uptime-monitoring']};exportasyncfunctionhandler(context) {context.logger.info(`Starting uptime checks for ${envConfig.sites.length} sites`);context.logger.info(`Sites configured: ${JSON.stringify(envConfig.sites)}`);try{// Emit one check.requested event per configured site URLfor(consturlofenvConfig.sites) {context.logger.info(`Scheduling check for: ${url}`);awaitcontext.emit({topic:'check.requested',data: { url: url }});context.logger.info(`Successfully emitted for: ${url}`);}context.logger.info(`Successfully scheduled checks for all ${envConfig.sites.length} sites`);}catch(error) {context.logger.error('Error during cron execution:', error);throwerror;}}
Explore the Workbench
The Motia Workbench provides a visual representation of your monitoring pipeline, making it easy to understand the event flow and debug issues in real-time.
You can monitor real-time status checks, view Discord alert logs, and trace the execution of each step directly in the Workbench interface. This makes development and debugging significantly easier compared to traditional monitoring solutions.
Key Features & Benefits
⚡Event-Driven Architecture
Each component is independent and communicates through events, making the system highly scalable and maintainable.
🎯Smart Status Detection
Only triggers alerts when status actually changes (UP ↔ DOWN), eliminating noise from temporary fluctuations.
🚨Intelligent Rate Limiting
Token bucket algorithm prevents alert spam during site flapping while ensuring critical alerts get through.
📊Built-in Observability
Comprehensive logging, health checks, and real-time status tracking with persistent storage.
🔧Production-Ready
Robust error handling, timeout management, and configurable check intervals ensure reliability.
🎨Rich Discord Alerts
Beautiful embedded messages with response times, error details, and status transitions.
Data Flow & Event Architecture
Event Flow
Cron Trigger→ Emitscheck.requestedevents for each configured site
check.requested
Website Checker→ Receivescheck.requested, performs HTTP check
check.requested
Status Update→ Checker emitscheck.resultwith result
check.result
Alert Processing→ Alerter receivescheck.result, detects status changes
check.result
Discord Notification→ Alerter sends webhook if status changed and rate limit allows
Status Storage→ Status is persisted for health endpoint and future comparisons
Trying It Out
Ready to build your own production-ready monitoring system? Let's get it running.
Install Dependencies
Install the necessary npm packages and set up the development environment.
npminstall
npminstall
Configure Environment Variables
Create a.envfile with your monitoring configuration. You'll need a Discord webhook URL and the sites you want to monitor.
.env
# Required: Discord webhook for alertsDISCORD_WEBHOOK="https://discord.com/api/webhooks/123456789/your-webhook-token"# Required: JSON array of URLs to monitorSITES='["https://example.com", "https://api.yourdomain.com", "https://blog.yoursite.org"]'# Optional: Check frequency (default: every minute)CHECK_INTERVAL_CRON="*/1 * * * *"# Optional: Rate limiting (default: 3 alerts per 5 minutes)ALERT_BURST="3"ALERT_WINDOW_SEC="300"
# Required: Discord webhook for alertsDISCORD_WEBHOOK="https://discord.com/api/webhooks/123456789/your-webhook-token"# Required: JSON array of URLs to monitorSITES='["https://example.com", "https://api.yourdomain.com", "https://blog.yoursite.org"]'# Optional: Check frequency (default: every minute)CHECK_INTERVAL_CRON="*/1 * * * *"# Optional: Rate limiting (default: 3 alerts per 5 minutes)ALERT_BURST="3"ALERT_WINDOW_SEC="300"
Set Up Discord Webhook
Create a Discord webhook to receive alerts:
Go to your Discord server settings
Navigate toIntegrations→Webhooks
ClickNew Webhook
Copy the webhook URL and add it to your.envfile
.env
Run the Monitoring System
Start the Motia development server to begin monitoring your websites.
npmrundev
npmrundev
Check System Health
Verify your monitoring system is working correctly:
curlhttp://localhost:3000/healthz
curlhttp://localhost:3000/healthz
You should see a response with your configured sites and their current status:
{"status":"ok","sitesConfigured":3,"lastKnown": {"https://example.com": {"url":"https://example.com","status":"UP","code":200,"responseTime":245,"checkedAt":"2024-01-15T10:30:00.000Z","error":null}},"now":"2024-01-15T10:35:00.000Z"}
{"status":"ok","sitesConfigured":3,"lastKnown": {"https://example.com": {"url":"https://example.com","status":"UP","code":200,"responseTime":245,"checkedAt":"2024-01-15T10:30:00.000Z","error":null}},"now":"2024-01-15T10:35:00.000Z"}
Monitor the Logs
Watch the logs to see your monitoring system in action:
Cron triggers: Check scheduling for all configured sites
Website checks: HTTP requests and response analysis
Status changes: UP/DOWN transitions and Discord alerts
Rate limiting: Alert suppression during site flapping
Advanced Configuration
Custom Check Intervals
Modify the cron expression to change monitoring frequency:
# Every 5 minutesCHECK_INTERVAL_CRON="*/5 * * * *"# Every hourCHECK_INTERVAL_CRON="0 * * * *"# Every 6 hoursCHECK_INTERVAL_CRON="0 */6 * * *"# Business hours only (9 AM - 5 PM, Mon-Fri)CHECK_INTERVAL_CRON="* 9-17 * * 1-5"
# Every 5 minutesCHECK_INTERVAL_CRON="*/5 * * * *"# Every hourCHECK_INTERVAL_CRON="0 * * * *"# Every 6 hoursCHECK_INTERVAL_CRON="0 */6 * * *"# Business hours only (9 AM - 5 PM, Mon-Fri)CHECK_INTERVAL_CRON="* 9-17 * * 1-5"
Alert Rate Limiting
Fine-tune the rate limiting to match your needs:
# Very strict: 1 alert per 10 minutesALERT_BURST="1"ALERT_WINDOW_SEC="600"# More permissive: 5 alerts per 2 minutesALERT_BURST="5"ALERT_WINDOW_SEC="120"
# Very strict: 1 alert per 10 minutesALERT_BURST="1"ALERT_WINDOW_SEC="600"# More permissive: 5 alerts per 2 minutesALERT_BURST="5"ALERT_WINDOW_SEC="120"
Multi-Environment Monitoring
Set up different monitoring configurations for different environments:
# Production sitesSITES='["https://app.production.com", "https://api.production.com"]'# Staging sitesSITES='["https://app.staging.com", "https://api.staging.com"]'# Development sitesSITES='["https://app.dev.com", "http://localhost:8080"]'
# Production sitesSITES='["https://app.production.com", "https://api.production.com"]'# Staging sitesSITES='["https://app.staging.com", "https://api.staging.com"]'# Development sitesSITES='["https://app.dev.com", "http://localhost:8080"]'
Custom Discord Alert Formatting
Modify thecreateDiscordMessagefunction inalerter.step.jsto customize alert appearance:
createDiscordMessage
alerter.step.js
functioncreateDiscordMessage(result,previousStatus) {const{url,status,code,responseTime}=result// Custom colors for your brandconstcolor=status==='UP'?0x2ecc71:0xe74c3c// Custom emoji and formattingconstemoji=status==='UP'?'✅':'❌'consturgency=responseTime>5000?'🐌 SLOW':'⚡ FAST'return{content:`${emoji} **${url}** is ${status}`,embeds: [{title:`${urgency} Website ${status}`,description:`**${url}** changed from ${previousStatus} to ${status}`,color,timestamp: result.checkedAt,fields: [{name:'⏱️ Response Time',value:`${responseTime}ms`,inline:true},{name:'📊 Status Code',value: code?.toString()||'N/A',inline:true}]}]}}
functioncreateDiscordMessage(result,previousStatus) {const{url,status,code,responseTime}=result// Custom colors for your brandconstcolor=status==='UP'?0x2ecc71:0xe74c3c// Custom emoji and formattingconstemoji=status==='UP'?'✅':'❌'consturgency=responseTime>5000?'🐌 SLOW':'⚡ FAST'return{content:`${emoji} **${url}** is ${status}`,embeds: [{title:`${urgency} Website ${status}`,description:`**${url}** changed from ${previousStatus} to ${status}`,color,timestamp: result.checkedAt,fields: [{name:'⏱️ Response Time',value:`${responseTime}ms`,inline:true},{name:'📊 Status Code',value: code?.toString()||'N/A',inline:true}]}]}}
Troubleshooting
Common Issues
Sites not being checked:
VerifySITESenvironment variable is valid JSON
SITES
Check cron expression syntax usingcrontab.guru
Review logs for parsing errors
Discord alerts not working:
VerifyDISCORD_WEBHOOKURL is correct
DISCORD_WEBHOOK
Test webhook manually:curl -X POST $DISCORD_WEBHOOK -H "Content-Type: application/json" -d '{"content":"Test message"}'
curl -X POST $DISCORD_WEBHOOK -H "Content-Type: application/json" -d '{"content":"Test message"}'
Check Discord webhook permissions
High memory usage:
Monitor status store size with health endpoint
Consider implementing status history cleanup
Reduce check frequency for many sites
False positive alerts:
Increase timeout values in checker step
Implement retry logic before marking as DOWN
Adjust rate limiting to reduce noise
Performance Tips
Large Site Lists: Consider sharding across multiple instances
Slow Sites: Implement custom timeout values per site
High Frequency: Use Redis for status storage instead of file system
Alert Fatigue: Implement escalation policies and alert grouping
Monitoring the Monitor
Set up monitoring for your monitoring system:
# Monitor the health endpoint itselfcurl-fhttp://localhost:3000/healthz||echo"Monitor is down!"# Check for recent status updatescurlhttp://localhost:3000/healthz|jq'.lastKnown | to_entries | map(select(.value.checkedAt > (now - 300)))'# Verify all sites are being checkedcurlhttp://localhost:3000/healthz|jq'.sitesConfigured == (.lastKnown | length)'
# Monitor the health endpoint itselfcurl-fhttp://localhost:3000/healthz||echo"Monitor is down!"# Check for recent status updatescurlhttp://localhost:3000/healthz|jq'.lastKnown | to_entries | map(select(.value.checkedAt > (now - 300)))'# Verify all sites are being checkedcurlhttp://localhost:3000/healthz|jq'.sitesConfigured == (.lastKnown | length)'
💻 Dive into the Code
Want to explore the complete monitoring implementation? Check out the full source code, including all steps, utilities, and configuration examples:
Complete Uptime Monitor
Access the full implementation with event steps, utility libraries, Discord integration, and production-ready configuration.
View Monitor Example
More Examples →
Conclusion: Monitoring That Actually Works
This uptime monitoring system demonstrates the power of event-driven architecture for infrastructure monitoring. By breaking down monitoring into discrete, specialized components, we've created a system that's not only reliable but also extensible and maintainable.
The event-driven approach means you can easily:
Add new notification channels(Slack, PagerDuty, email) by creating new steps
Implement custom health checks(database connectivity, API endpoints, SSL certificates)
Scale monitoringacross multiple regions or environments
Integrate with existing systemswithout disrupting the core monitoring loop
Key architectural benefits:
Resilience: Component failures don't bring down the entire system
Observability: Built-in logging and tracing at every step
Flexibility: Easy to modify check intervals, alert logic, or add new features
Testing: Each component can be tested in isolation
From here, you can extend the system by:
Adding support for different check types (TCP, database, custom health endpoints)
Implementing escalation policies and on-call rotations
Building a web dashboard for historical data and trends
Adding integration with incident management systems
Implementing multi-region monitoring with failover
The event-driven architecture makes all of these extensions straightforward to implement without disrupting the existing monitoring pipeline.
Ready to build monitoring infrastructure that scales with your business? Start building with Motia today!
Trello Automation
Build an automated card progression system for Trello boards with AI-powered summaries
GitHub Stars Counter
Real-Time GitHub Stars Counter: Building Live Updates with Motia Streams
On this page



===== https://www.motia.dev/docs/examples/github-stars-counter =====

GitHub Stars Counter
Real-Time GitHub Stars Counter: Building Live Updates with Motia Streams
In today's social-driven development world, real-time metrics and live updates are essential for building engaging applications. Whether you're creating a portfolio site, an open-source project showcase, or a developer dashboard, you need systems that can display live data without complex infrastructure.
This comprehensive guide explores how to build a production-ready, real-time GitHub stars counter using Motia's event-driven architecture and streaming capabilities. We'll cover:
Real-Time Streams: How Motia's streams enable effortless live data synchronization
Secure Webhooks: Production-ready webhook signature verification and event handling
Minimal Architecture: Building powerful real-time features with just two components
Live Integration: How this exact counter powers the live star count on the Motia website
Let's build a stars counter that updates in real-time across all connected clients.
🏭 Production-Grade Example
This is not a tutorial project- this is battle-tested, production-ready code that handles real traffic at scale. Every aspect has been designed for enterprise use:
🔐 Enterprise Security: HMAC webhook verification, timing-safe comparisons, comprehensive input validation
⚡ High Performance: Handles thousands of concurrent connections with automatic scaling
📊 Full Observability: Structured logging, error tracking, and comprehensive monitoring
🛡️ Error Resilience: Graceful degradation, retry logic, and fault tolerance
🌍 Global Scale: Production deployment on Motia Cloud with worldwide CDN
💰 Cost Efficient: Serverless architecture that scales to zero when not in use
Live Proof: Powering Motia.dev Header
This isn't just a demo- this exact code powers the live GitHub star counter you can see right now in the header ofMotia.dev!
Look at the top-right corner of the Motia website and you'll see:
🏠 Motialogo on the left
📑 Blog, Docs, Manifestonavigation
⭐ GitHubicon with alive star count(currently showing 7953+ stars)
🚀 Vercel OSS 2025badge
That live-updating number next to the GitHub icon? That's this exact implementation in production, processing real webhook events and streaming updates to thousands of visitors in real-time!
The Power of Real-Time Simplicity
At its core, our GitHub stars counter solves a fundamental challenge: how do you display live, real-time metrics without complex WebSocket infrastructure or manual state management? Traditional approaches often involve intricate server-side event handling, client connection management, and complex state synchronization.
Our Motia-powered solution breaks this down into just two simple components:
GitHub Webhooks: Instant notifications when repository stars change
Motia Streams: Real-time data synchronization with automatic state management
Production Security: Built-in webhook signature verification
🎯Live in Action: This exact implementation powers the real-time star counter visible in the header ofMotia.dev(look for the GitHub icon with live count), updating instantly whenever developers star the repository!
Instead of complex infrastructure, we get a resilient real-time system where data flows effortlessly from GitHub events to live client updates.
The Anatomy of Our Real-Time Counter
Our application consists of just two specialized components, each handling a specific part of the real-time data flow. Let's explore the complete architecture.
The real-time data stream that holds our repository star counts. This stream automatically synchronizes data to all connected clients with zero configuration.
import{ StreamConfig }from'motia'import{ z }from'zod'constRepositoryStarsSchema=z.object({stars: z.number(),name: z.string(),fullName: z.string(),organization: z.string(),lastUpdated: z.string(),})exporttypeRepositoryStars=z.infer<typeofRepositoryStarsSchema>exportconstconfig:StreamConfig={name:'stars',schema: RepositoryStarsSchema,baseConfig: { storageType:'default'},}
import{ StreamConfig }from'motia'import{ z }from'zod'constRepositoryStarsSchema=z.object({stars: z.number(),name: z.string(),fullName: z.string(),organization: z.string(),lastUpdated: z.string(),})exporttypeRepositoryStars=z.infer<typeofRepositoryStarsSchema>exportconstconfig:StreamConfig={name:'stars',schema: RepositoryStarsSchema,baseConfig: { storageType:'default'},}
Real-Time Data Flow
The beauty of this architecture lies in its simplicity. Here's how real-time updates flow through the system:
GitHub Event→ User stars/unstars your repository
Webhook Delivery→ GitHub sends POST request to your endpoint
Security Validation→ Signature verification ensures request authenticity
Stream Update→ Data is written to Motia stream withstreams.stars.set()
streams.stars.set()
Live Propagation→ All connected clients automatically receive the update
UI Updates→ Client applications re-render with new star count
No manual WebSocket management, no connection handling, no state synchronization code required!
Key Features & Benefits
⚡Instant Real-Time Updates
Stars update across all connected clients the moment GitHub sends the webhook - no polling, no delays.
🔐Production-Ready Security
HMAC signature verification with timing-safe comparison prevents unauthorized webhook requests.
🧩Minimal Architecture
Just two components handle the complete real-time functionality - no complex infrastructure required.
📊Automatic State Management
Motia streams handle data persistence, synchronization, and client updates automatically.
🎯Type-Safe Development
Full TypeScript integration with Zod validation ensures zero runtime surprises.
🌐Live Production Usage
This exact implementation powers the real-time counter visible in the Motia website header - go check it out now!
🚀Production-Grade Architecture
Built for enterprise scale with proper error handling, security, monitoring, and deployment automation.
Trying It Out
Ready to build your own real-time GitHub stars counter? Let's get it running.
Clone and Install
Start by getting the project locally and installing dependencies.
gitclonehttps://github.com/MotiaDev/github-stars-counter.gitcdgithub-stars-counternpminstall
gitclonehttps://github.com/MotiaDev/github-stars-counter.gitcdgithub-stars-counternpminstall
Configure GitHub Webhook (Optional)
Set up webhook security with a secret for production use. This is optional for testing but essential for production deployments.
# Generate a secure random secretexportGITHUB_WEBHOOK_SECRET=$(opensslrand-hex32)echo"GITHUB_WEBHOOK_SECRET=$GITHUB_WEBHOOK_SECRET">>.env
# Generate a secure random secretexportGITHUB_WEBHOOK_SECRET=$(opensslrand-hex32)echo"GITHUB_WEBHOOK_SECRET=$GITHUB_WEBHOOK_SECRET">>.env
Start Development Server
Launch the Motia development server to begin receiving webhook events.
npmrundev
npmrundev
Your webhook endpoint will be available at:http://localhost:3000/webhooks/github/star
http://localhost:3000/webhooks/github/star
Set Up GitHub Webhook
Configure GitHub to send star events to your endpoint:
Go to your GitHub repository settings
Navigate toSettings→Webhooks
ClickAdd webhook
SetPayload URLto your endpoint (use ngrok for local testing)
SetContent typetoapplication/json
application/json
Add your webhook secret if configured
SelectIndividual events→Stars
ClickAdd webhook
Test the Real-Time Updates
Test your webhook by starring/unstarring your repository:
Star your repositoryon GitHub
Check the logs- you should see webhook processing
Access the stream- query/api/streams/starsto see current data
/api/streams/stars
Watch real-time updatesin the Motia Workbench
Access Real-Time Data
Your star data is now available via the Motia streams API:
# Get all repository star countscurlhttp://localhost:3000/api/streams/stars# Get specific repository star countcurlhttp://localhost:3000/api/streams/stars/{org}/{repo}
# Get all repository star countscurlhttp://localhost:3000/api/streams/stars# Get specific repository star countcurlhttp://localhost:3000/api/streams/stars/{org}/{repo}
The response includes live star counts that update automatically whenever GitHub sends webhook events.
Deploy to Production
Once your counter is working locally, deploy it to production with Motia Cloud:
Option 1: CLI Deployment
# Deploy with version and API keymotiaclouddeploy--api-keyyour-api-key--version-name1.0.0# Deploy with environment variablesmotiaclouddeploy--api-keyyour-api-key\--version-name1.0.0\--env-file.env.production\--environment-idyour-env-id
# Deploy with version and API keymotiaclouddeploy--api-keyyour-api-key--version-name1.0.0# Deploy with environment variablesmotiaclouddeploy--api-keyyour-api-key\--version-name1.0.0\--env-file.env.production\--environment-idyour-env-id
Option 2: One-Click Web Deployment
Ensure your local project is running (npm run dev)
npm run dev
Go toMotia Cloud -> Import from Workbench
Select your local project port
Choose project and environment name
Upload environment variables (optional)
ClickDeployand watch the magic happen! ✨
🚀 Production Deployment Guide
Environment Variables
Configure these environment variables for production security and functionality:
# Required: GitHub webhook secret for securityGITHUB_WEBHOOK_SECRET="your-secure-random-secret"# Optional: GitHub personal access token for enhanced API limitsGITHUB_TOKEN="ghp_your_github_token"
# Required: GitHub webhook secret for securityGITHUB_WEBHOOK_SECRET="your-secure-random-secret"# Optional: GitHub personal access token for enhanced API limitsGITHUB_TOKEN="ghp_your_github_token"
Security Best Practices
For production deployments, ensure you:
Generate secure webhook secrets:# Generate a cryptographically secure secretopensslrand-hex32
Generate secure webhook secrets:
# Generate a cryptographically secure secretopensslrand-hex32
# Generate a cryptographically secure secretopensslrand-hex32
Store secrets securely: Use environment variables, never commit to code
Store secrets securely: Use environment variables, never commit to code
Monitor webhook signatures: The handler automatically verifies signatures whenGITHUB_WEBHOOK_SECRETis set
Monitor webhook signatures: The handler automatically verifies signatures whenGITHUB_WEBHOOK_SECRETis set
GITHUB_WEBHOOK_SECRET
Enable logging: Monitor for signature verification failures and unauthorized requests
Enable logging: Monitor for signature verification failures and unauthorized requests
Scaling Considerations
This architecture scales automatically with your traffic:
Multiple repositories: Each repo gets its own stream key (org/repo)
org/repo
High concurrency: Motia streams handle thousands of concurrent connections
Global distribution: Deploy to multiple regions for worldwide performance
Cost optimization: Pay only for actual usage with serverless scaling
💻 Dive into the Code
Want to explore the complete real-time implementation? Check out the full source code and see how simple real-time features can be with Motia:
Live GitHub Stars Counter
Access the complete implementation with webhook security, real-time streams, and production deployment configurations. See exactly how the Motia website's live counter works!
View Stars Counter Code
See It Live in Header →
Conclusion: Real-Time Made Simple
This GitHub stars counter demonstrates how Motia transforms complex real-time development into simple, manageable components. With just two files and minimal configuration, we've built a production-ready system that handles webhook security, real-time synchronization, and live client updates.
The beauty of this approach is its scalability and extensibility:
Add more repositories: Each gets its own stream automatically
Enhance with analytics: Track starring patterns and user insights
Multiple notification channels: Slack, Discord, email alerts for milestones
Rich frontend integrations: React, Vue, vanilla JS - all work seamlessly
Key architectural benefits:
No WebSocket complexity: Streams handle all real-time synchronization automatically
Built-in security: Production-ready webhook verification out of the box
Type safety: Full TypeScript support prevents runtime errors
Zero configuration: Real-time features work with no additional setup
This exact implementation powers the live star counter you see in the header ofMotia.dev- that 7953+ count updating in real-time? It's this code in action, proven at enterprise scale with thousands of daily visitors.
Production Metrics:
Handles 10,000+ webhook events per day
Sub-50ms response times globally
99.9% uptime with automatic failover
Zero maintenance serverless architecture
Ready to add enterprise-grade real-time features to your applications? Deploy production-ready code with Motia today!
Uptime Monitor
Real-Time Uptime Monitoring: Building a Resilient Website Monitor with Motia
GitHub Integration
Build an automated GitHub issue and PR management system with AI-powered classification and routing
On this page



===== https://www.motia.dev/docs/examples/github-integration-workflow =====

GitHub Integration
Build an automated GitHub issue and PR management system with AI-powered classification and routing
Let's build a GitHub automation system that:
Automatically triages and classifies new issues
Intelligently assigns labels based on content
Suggests appropriate assignees and reviewers
Monitors PR test status
Generates contextual comments
Workflow Structure
The GitHub integration workflow is organized into two main components:
Issue Triage: Handles the management of GitHub issues
PR Classifier: Manages pull request workflows
The Steps
Visual Overview
Here's how the automation flow works:
Webhook Reception→ Captures GitHub events
Issue/PR Classification→ Analyzes content with AI
Automated Labeling→ Applies appropriate labels
Smart Assignment→ Suggests reviewers and assignees
Status Monitoring→ Tracks PR test status
Try It Out
Prerequisites
Make sure you have:
GitHub account with personal access token
Node.js installed
OpenAI API key (for AI classification)
Clone the Repository
gitclonegit@github.com:MotiaDev/motia-examples.gitcdexamples/github-integration-workflow
gitclonegit@github.com:MotiaDev/motia-examples.gitcdexamples/github-integration-workflow
Install Dependencies
npminstall
npminstall
Configure Environment Variables
Create a.envfile by copying the example:
.env
cp.env.example.env
cp.env.example.env
Update your.envwith the following credentials:
.env
GITHUB_TOKEN=your_github_token_hereOPENAI_API_KEY=your_openai_api_key
GITHUB_TOKEN=your_github_token_hereOPENAI_API_KEY=your_openai_api_key
Set Up GitHub Webhook
Go to your GitHub repository settings
Navigate to Webhooks and add a new webhook
Set the Payload URL to your Motia server endpoint
Select content type asapplication/json
application/json
Choose which events to trigger the webhook (Issues, Pull requests)
Save the webhook
Run the Application
npmrundev
npmrundev
Test the Flow
Create a new issue in your GitHub repository
Watch as it gets automatically classified and labeled
Create a new PR to see the reviewer assignment in action
Check the PR comments for test status updates
For more detailed setup instructions and configuration options, check out thefull
documentation.
GitHub Stars Counter
Real-Time GitHub Stars Counter: Building Live Updates with Motia Streams
Gmail Automation
Build an automated email system with smart labeling, auto-responses, and AI-powered filtering
On this page



===== https://www.motia.dev/docs/examples/gmail-automation =====

Gmail Automation
Build an automated email system with smart labeling, auto-responses, and AI-powered filtering
Let's build a Gmail automation system that:
📊 Smart email classification by category (work, personal, social, promotion, spam, update)
🚨 Urgency detection (high, medium, low) with prioritization
💬 Intelligent automated responses based on email context
🏷️ Automatic email organization (labeling, archiving)
📈 Daily summary reports via Discord
🔒 Secure Gmail API integration with OAuth2 authentication flow
⚡ Real-time email monitoring with webhook notifications
The Steps
Visual Overview
Here's how the automation flow works:
🌊 Workflow Architecture
The Gmail Account Manager workflow consists of the following steps:
1. Gmail Authentication (Multi-Step Flow)
Files:steps/gmail-get-auth-url.step.ts: Generates OAuth2 authorization URLsteps/gmail-auth.step.ts: Handles authorization code exchangesteps/gmail-token-status.step.ts: Checks token validity and refreshes if needed
steps/gmail-get-auth-url.step.ts: Generates OAuth2 authorization URL
steps/gmail-get-auth-url.step.ts
steps/gmail-auth.step.ts: Handles authorization code exchange
steps/gmail-auth.step.ts
steps/gmail-token-status.step.ts: Checks token validity and refreshes if needed
steps/gmail-token-status.step.ts
2. Gmail Webhook (API Step)
File:steps/gmail-webhook.step.ts
steps/gmail-webhook.step.ts
Purpose: Receives notifications from Gmail when new emails arrive
Emits:gmail.new_emailevent with message details
gmail.new_email
Endpoint:POST /api/gmail-webhook
POST /api/gmail-webhook
3. Gmail Watch (API Step)
File:steps/gmail-watch.step.ts
steps/gmail-watch.step.ts
Purpose: Sets up push notifications for the Gmail account
Endpoint:GET /api/watch
GET /api/watch
4. Fetch Email (Event Step)
File:steps/fetch-email.step.ts
steps/fetch-email.step.ts
Purpose: Retrieves the full email content from Gmail API
Subscribes to:gmail.email.received
gmail.email.received
Emits:gmail.email.fetchedwith complete email data
gmail.email.fetched
Key Functions: Authenticates with Gmail API, fetches message content, parses attachments
5. Analyze Email (Event Step)
File:steps/analyze-email.step.py
steps/analyze-email.step.py
Purpose: Uses Hugging Face models to analyze email content
Subscribes to:gmail.email.fetched
gmail.email.fetched
Emits:gmail.email.analyzedwith analysis results
gmail.email.analyzed
Analysis Performed:Category classificationUrgency detectionSentiment analysisKey information extraction
Category classification
Urgency detection
Sentiment analysis
Key information extraction
6. Organize Email (Event Step)
File:steps/organize-email.step.ts
steps/organize-email.step.ts
Purpose: Applies labels and organization based on analysis
Subscribes to:gmail.email.analyzed
gmail.email.analyzed
Emits:[gmail.email.organized, gmail.email.archived]
[gmail.email.organized, gmail.email.archived]
Actions: Creates/applies labels, archives certain emails, marks importance
7. Auto-Respond to Email (Event Step)
File:steps/auto-responder.step.ts
steps/auto-responder.step.ts
Purpose: Generates and sends appropriate responses for certain emails
Subscribes to:gmail.email.analyzed
gmail.email.analyzed
Emits:gmail.email.responded
gmail.email.responded
Features:Template selection based on email contextPersonalization of responsesAuto-reply for urgent messagesFollow-up scheduling
Template selection based on email context
Personalization of responses
Auto-reply for urgent messages
Follow-up scheduling
8. Daily Summary (Cron Step)
File:steps/daily-summary.step.ts
steps/daily-summary.step.ts
Purpose: Compiles and sends daily email activity summary
Schedule: Runs daily at 6:00 PM
Emits:gmail.summary.sent
gmail.summary.sent
Delivery: Sends report to Discord via webhook
Try It Out
📋 Prerequisites
Node.js(v18+)
Python(v3.8+)
Gmail API credentials(client_id and client_secret)
Google Cloud projectwith Pub/Sub API enabled
Hugging Face API token
Discord webhook URL(for daily summaries)
🚀 Quick Start
Clone this repositorygitclonehttps://github.com/yourusername/gmail-flow.gitcdgmail-flow
Clone this repository
gitclonehttps://github.com/yourusername/gmail-flow.gitcdgmail-flow
gitclonehttps://github.com/yourusername/gmail-flow.gitcdgmail-flow
Install Node.js dependenciespnpminstall
Install Node.js dependencies
pnpminstall
pnpminstall
Install Python dependenciespipinstall-rrequirements.txt
Install Python dependencies
pipinstall-rrequirements.txt
pipinstall-rrequirements.txt
Configure environment variablescp.env.example.envThen edit the.envfile with your credentials (see setup sections below).
Configure environment variables
cp.env.example.env
cp.env.example.env
Then edit the.envfile with your credentials (see setup sections below).
.env
Start the development serverpnpmdev
Start the development server
pnpmdev
pnpmdev
Open the Motia WorkbenchNavigate tohttp://localhost:3000to access the workflow UI.
Open the Motia Workbench
Navigate tohttp://localhost:3000to access the workflow UI.
🔧 Detailed Setup
Setting up Google Cloud Project and Gmail API
Before you can use the Gmail Account Manager, you need to set up a Google Cloud project with the Gmail API and Pub/Sub:
Create a Google Cloud Project:Go toGoogle Cloud ConsoleClick on "New Project" and follow the steps to create a new projectNote your project ID for later use
Create a Google Cloud Project:
Go toGoogle Cloud Console
Click on "New Project" and follow the steps to create a new project
Note your project ID for later use
Enable the Gmail API:In your project, go to "APIs & Services" > "Library"Search for "Gmail API" and click on itClick "Enable"
Enable the Gmail API:
In your project, go to "APIs & Services" > "Library"
Search for "Gmail API" and click on it
Click "Enable"
Enable the Pub/Sub API:In your project, go to "APIs & Services" > "Library"Search for "Cloud Pub/Sub API" and click on itClick "Enable"
Enable the Pub/Sub API:
In your project, go to "APIs & Services" > "Library"
Search for "Cloud Pub/Sub API" and click on it
Click "Enable"
Create OAuth Credentials:Go to "APIs & Services" > "Credentials"Click "Create Credentials" > "OAuth client ID"Set the application type to "Desktop app"Click "Create"Note your Client ID and Client Secret for your.envfile:GOOGLE_CLIENT_ID=your_client_idGOOGLE_CLIENT_SECRET=your_client_secret
Create OAuth Credentials:
Go to "APIs & Services" > "Credentials"
Click "Create Credentials" > "OAuth client ID"
Set the application type to "Desktop app"
Click "Create"
Note your Client ID and Client Secret for your.envfile:GOOGLE_CLIENT_ID=your_client_idGOOGLE_CLIENT_SECRET=your_client_secret
.env
GOOGLE_CLIENT_ID=your_client_idGOOGLE_CLIENT_SECRET=your_client_secret
GOOGLE_CLIENT_ID=your_client_idGOOGLE_CLIENT_SECRET=your_client_secret
Setting up Google Pub/Sub for Gmail Notifications
To enable real-time email notifications, you need to set up a Google Cloud Pub/Sub topic and subscription:
Create a Pub/Sub Topic:In your Google Cloud Console, go to "Pub/Sub" > "Topics"Click "Create Topic"Name your topic (e.g.,gmail-notifications)Add the service accountgmail-api-push@system.gserviceaccount.comas a Topic Publisher to allow Gmail to publish notificationsClick "Create"Note the full topic name (usuallyprojects/your-project-id/topics/gmail-notifications) for your.envfile:GOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications
Create a Pub/Sub Topic:
In your Google Cloud Console, go to "Pub/Sub" > "Topics"
Click "Create Topic"
Name your topic (e.g.,gmail-notifications)
gmail-notifications
Add the service accountgmail-api-push@system.gserviceaccount.comas a Topic Publisher to allow Gmail to publish notifications
gmail-api-push@system.gserviceaccount.com
Click "Create"
Note the full topic name (usuallyprojects/your-project-id/topics/gmail-notifications) for your.envfile:GOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications
projects/your-project-id/topics/gmail-notifications
.env
GOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications
GOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications
Create a Pub/Sub Subscription:Once your topic is created, click "Create Subscription"Name your subscription (e.g.,gmail-notifications-push)Set the Delivery Type to "Push"Set the Endpoint URL to your webhook URL (e.g.,https://your-domain.com/api/gmail-webhook)For local development, you'll need to use a tool like ngrok to expose your local serverClick "Create"
Create a Pub/Sub Subscription:
Once your topic is created, click "Create Subscription"
Name your subscription (e.g.,gmail-notifications-push)
gmail-notifications-push
Set the Delivery Type to "Push"
Set the Endpoint URL to your webhook URL (e.g.,https://your-domain.com/api/gmail-webhook)For local development, you'll need to use a tool like ngrok to expose your local server
https://your-domain.com/api/gmail-webhook
For local development, you'll need to use a tool like ngrok to expose your local server
Click "Create"
Set up Domain Verification(if needed):If you're using a custom domain for your webhook endpoint, you may need to verify domain ownershipFollow the instructions in Google Cloud Console for domain verification
Set up Domain Verification(if needed):
If you're using a custom domain for your webhook endpoint, you may need to verify domain ownership
Follow the instructions in Google Cloud Console for domain verification
Gmail API Authentication
This project includes a complete OAuth2 authentication flow for the Gmail API:
Start the development server:pnpm dev
pnpm dev
Navigate to the authentication workflow in the Motia Workbench
The workflow will generate an authorization URL
Open the URL in your browser and authorize the application
The application will receive and store your authentication tokens
Discord Webhook Configuration
To receive daily email summaries in Discord, follow these steps to set up a webhook:
Create a Discord Server(skip if you already have one):Open Discord and click the "+" icon on the left sidebarSelect "Create My Own" and follow the setup wizard
Create a Discord Server(skip if you already have one):
Open Discord and click the "+" icon on the left sidebar
Select "Create My Own" and follow the setup wizard
Create a Channel for Notifications:Right-click on your server name and select "Server Settings"Go to "Channels" and click "Create Channel"Name it (e.g., "email-summaries") and click "Create"
Create a Channel for Notifications:
Right-click on your server name and select "Server Settings"
Go to "Channels" and click "Create Channel"
Name it (e.g., "email-summaries") and click "Create"
Create a Webhook:Right-click on your new channel and select "Edit Channel"Go to "Integrations" tabClick "Create Webhook"Give it a name (e.g., "Gmail Summary Bot")Optionally, customize the avatarClick "Copy Webhook URL"
Create a Webhook:
Right-click on your new channel and select "Edit Channel"
Go to "Integrations" tab
Click "Create Webhook"
Give it a name (e.g., "Gmail Summary Bot")
Optionally, customize the avatar
Click "Copy Webhook URL"
Add Webhook URL to Environment Variables:Open your.envfileAdd or update the Discord webhook URL:DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url
Add Webhook URL to Environment Variables:
Open your.envfile
.env
Add or update the Discord webhook URL:DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url
DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url
DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url
Test the Webhook:You can test if your webhook is working correctly with this curl command:curl-XPOST-H"Content-Type: application/json"\-d'{"content": "Testing Gmail Account Manager webhook"}'\https://discord.com/api/webhooks/your-webhook-urlYou should see the message appear in your Discord channel
Test the Webhook:
You can test if your webhook is working correctly with this curl command:curl-XPOST-H"Content-Type: application/json"\-d'{"content": "Testing Gmail Account Manager webhook"}'\https://discord.com/api/webhooks/your-webhook-url
curl-XPOST-H"Content-Type: application/json"\-d'{"content": "Testing Gmail Account Manager webhook"}'\https://discord.com/api/webhooks/your-webhook-url
curl-XPOST-H"Content-Type: application/json"\-d'{"content": "Testing Gmail Account Manager webhook"}'\https://discord.com/api/webhooks/your-webhook-url
You should see the message appear in your Discord channel
Hugging Face Setup
Create a Hugging Face Account:Sign up atHugging Face
Create a Hugging Face Account:
Sign up atHugging Face
Generate an API Token:Go to yourHugging Face account settingsCreate a new API tokenCopy the token to your.envfile:HUGGINGFACE_API_TOKEN=your_api_token
Generate an API Token:
Go to yourHugging Face account settings
Create a new API token
Copy the token to your.envfile:HUGGINGFACE_API_TOKEN=your_api_token
.env
HUGGINGFACE_API_TOKEN=your_api_token
HUGGINGFACE_API_TOKEN=your_api_token
📁 Project Structure
steps/- Contains all workflow stepsgmail-get-auth-url.step.ts- Generates OAuth2 URLgmail-auth.step.ts- Handles OAuth2 flowgmail-token-status.step.ts- Manages token refreshgmail-webhook.step.ts- Webhook endpoint for Gmail notificationsgmail-watch.step.ts- Sets up Gmail push notificationsfetch-email.step.ts- Fetches email content from Gmail APIanalyze-email.step.py- Python step for email analysis using Hugging Faceorganize-email.step.ts- Organizes emails (labels, archives)auto-responder.step.ts- Generates appropriate responsesdaily-summary.step.ts- Sends daily summary to Discord
steps/
gmail-get-auth-url.step.ts- Generates OAuth2 URL
gmail-get-auth-url.step.ts
gmail-auth.step.ts- Handles OAuth2 flow
gmail-auth.step.ts
gmail-token-status.step.ts- Manages token refresh
gmail-token-status.step.ts
gmail-webhook.step.ts- Webhook endpoint for Gmail notifications
gmail-webhook.step.ts
gmail-watch.step.ts- Sets up Gmail push notifications
gmail-watch.step.ts
fetch-email.step.ts- Fetches email content from Gmail API
fetch-email.step.ts
analyze-email.step.py- Python step for email analysis using Hugging Face
analyze-email.step.py
organize-email.step.ts- Organizes emails (labels, archives)
organize-email.step.ts
auto-responder.step.ts- Generates appropriate responses
auto-responder.step.ts
daily-summary.step.ts- Sends daily summary to Discord
daily-summary.step.ts
services/- Shared service modules
services/
config/- Configuration files
config/
.motia/- Motia framework configuration
.motia/
📦 Dependencies
Node.js Dependencies
@motiadev/core,@motiadev/workbench,motia: Motia framework
googleapis,google-auth-library: Google API integration
gmail-api-parse-message-ts: Gmail message parsing
axios: HTTP client
zod: Schema validation
react: UI components
Python Dependencies
transformers,torch: Machine learning models
scikit-learn,numpy,pandas: Data processing
huggingface_hub: Access to Hugging Face models
python-dotenv: Environment variable loading
🛠️ Troubleshooting
Python Module Errors: Ensure you've installed all required Python packages withpip install -r requirements.txt
pip install -r requirements.txt
Authentication Errors: Verify your API credentials and follow the authentication flow
Webhook Issues: Make sure the webhook endpoint is publicly accessible or properly configured for testing
Token Refresh Errors: Check that your OAuth tokens are valid and that the refresh flow is working properly
Pub/Sub Not Working: Verify that your Pub/Sub topic and subscription are properly configured and that your service account has the necessary permissions
📝 Environment Variables
Create a.envfile with the following variables:
.env
# Google API ConfigurationGOOGLE_CLIENT_ID=your_client_idGOOGLE_CLIENT_SECRET=your_client_secretGOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications# HuggingFace ConfigurationHUGGINGFACE_API_TOKEN=your_huggingface_token# Discord IntegrationDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url# Auto-Responder ConfigurationAUTO_RESPONDER_NAME=Your NameAUTO_RESPONDER_EMAIL=your-email@example.com
# Google API ConfigurationGOOGLE_CLIENT_ID=your_client_idGOOGLE_CLIENT_SECRET=your_client_secretGOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications# HuggingFace ConfigurationHUGGINGFACE_API_TOKEN=your_huggingface_token# Discord IntegrationDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url# Auto-Responder ConfigurationAUTO_RESPONDER_NAME=Your NameAUTO_RESPONDER_EMAIL=your-email@example.com
GitHub Integration
Build an automated GitHub issue and PR management system with AI-powered classification and routing
Finance Agent
A powerful event-driven financial analysis workflow that combines web search, financial data, and AI analysis to provide comprehensive investment insights.
On this page



===== https://www.motia.dev/docs/examples/finance-agent =====

Finance Agent
A powerful event-driven financial analysis workflow that combines web search, financial data, and AI analysis to provide comprehensive investment insights.
Let's build a finance agent that:
Real-time Financial Analysis: Combines multiple data sources for comprehensive insights
AI-Powered Insights: Leverages OpenAI GPT-4 for intelligent market analysis
Web Search Integration: Aggregates latest market news and analysis
Financial Data Integration: Real-time stock and company information
The Steps
🚀 Features
Real-time Financial Analysis: Combines multiple data sources for comprehensive insights
AI-Powered Insights: Leverages OpenAI GPT-4 for intelligent market analysis
Event-Driven Architecture: Built on Motia's robust event system for reliable processing
Web Search Integration: Aggregates latest market news and analysis
Financial Data Integration: Real-time stock and company information
Persistent Storage: Stores analysis results for future reference
RESTful API: Easy integration with existing systems
📋 Prerequisites
Node.js v16+
npm or pnpm
API keys for:Alpha Vantage(financial data)SerperDev(web search)OpenAI(AI analysis)
Alpha Vantage(financial data)
SerperDev(web search)
OpenAI(AI analysis)
🛠️ Installation
Clone the repository:gitclonehttps://github.com/MotiaDev/motia-examplescdexamples/finance-agent
Clone the repository:
gitclonehttps://github.com/MotiaDev/motia-examplescdexamples/finance-agent
gitclonehttps://github.com/MotiaDev/motia-examplescdexamples/finance-agent
Install dependencies:pnpminstall# ornpminstall
Install dependencies:
pnpminstall# ornpminstall
pnpminstall# ornpminstall
Configure environment variables:cp.env.example.envUpdate.envwith your API keys:ALPHA_VANTAGE_API_KEY=your_alpha_vantage_api_key_hereSERPER_API_KEY=your_serper_api_key_hereOPENAI_API_KEY=your_openai_api_key_here
Configure environment variables:
cp.env.example.env
cp.env.example.env
Update.envwith your API keys:
.env
ALPHA_VANTAGE_API_KEY=your_alpha_vantage_api_key_hereSERPER_API_KEY=your_serper_api_key_hereOPENAI_API_KEY=your_openai_api_key_here
ALPHA_VANTAGE_API_KEY=your_alpha_vantage_api_key_hereSERPER_API_KEY=your_serper_api_key_hereOPENAI_API_KEY=your_openai_api_key_here
🏗️ Architecture
The workflow consists of several specialized steps that work together to provide comprehensive financial analysis:
🚦 API Endpoints
Query Endpoint
POST/finance-queryContent-Type:application/json{"query":"Latest information about AAPL and MSFT"}
POST/finance-queryContent-Type:application/json{"query":"Latest information about AAPL and MSFT"}
Response:
{"message":"Query received and processing started","traceId":"abc123def456"}
{"message":"Query received and processing started","traceId":"abc123def456"}
Results Endpoint
GET/finance-result/:traceId
GET/finance-result/:traceId
Response:
{"query":"Latest information about AAPL and MSFT","timestamp":"2023-06-15T12:34:56.789Z","response": {"summary":"Results for\"Latest information about AAPL and MSFT\"","webResources": [...],"financialData": [...],"aiAnalysis": {...}},"status":"success"}
{"query":"Latest information about AAPL and MSFT","timestamp":"2023-06-15T12:34:56.789Z","response": {"summary":"Results for\"Latest information about AAPL and MSFT\"","webResources": [...],"financialData": [...],"aiAnalysis": {...}},"status":"success"}
🏃‍♂️ Running the Application
Start the development server:pnpmdev
Start the development server:
pnpmdev
pnpmdev
Access the Motia Workbench:http://localhost:3000
Access the Motia Workbench:
http://localhost:3000
http://localhost:3000
Make a test request:curl-XPOSThttp://localhost:3000/finance-query\-H"Content-Type: application/json"\-d'{"query": "Latest information about AAPL and MSFT"}'
Make a test request:
curl-XPOSThttp://localhost:3000/finance-query\-H"Content-Type: application/json"\-d'{"query": "Latest information about AAPL and MSFT"}'
curl-XPOSThttp://localhost:3000/finance-query\-H"Content-Type: application/json"\-d'{"query": "Latest information about AAPL and MSFT"}'
🙏 Acknowledgments
Motia Frameworkfor the event-driven workflow engine
Alpha Vantagefor financial data
SerperDevfor web search capabilities
OpenAIfor AI analysis
Gmail Automation
Build an automated email system with smart labeling, auto-responses, and AI-powered filtering
AI Research Agent
A powerful research assistant that leverages the Motia Framework to perform comprehensive web research on any topic and any question.
On this page



===== https://www.motia.dev/docs/examples/ai-deep-research-agent =====

AI Research Agent
A powerful research assistant that leverages the Motia Framework to perform comprehensive web research on any topic and any question.
Let's build a AI Deep Research Agent that:
Deep Web Research: Automatically searches the web, extracts content, and synthesizes findings
Iterative Research Process: Supports multiple layers of research depth for comprehensive exploration
Event-Driven Architecture: Built using Motia Framework's event system for robust workflow management
Parallel Processing: Efficiently processes search results and content extraction
API Endpoints: REST API access for initiating research and retrieving reports
Stateful Processing: Maintains research state throughout the entire process
The Steps
🚀 Features
Deep Web Research: Automatically searches the web, extracts content, and synthesizes findings
Iterative Research Process: Supports multiple layers of research depth for comprehensive exploration
Event-Driven Architecture: Built using Motia Framework's event system for robust workflow management
Parallel Processing: Efficiently processes search results and content extraction
API Endpoints: REST API access for initiating research and retrieving reports
Stateful Processing: Maintains research state throughout the entire process
📋 Prerequisites
Node.js v18 or later
npm or pnpm
API keys for:OpenAI(AI analysis)Firecrawl(Web Crawler)
OpenAI(AI analysis)
Firecrawl(Web Crawler)
🛠️ Installation
Clone the repository:gitclonehttps://github.com/MotiaDev/motia-examplescdexamples/ai-deep-research-agent
Clone the repository:
gitclonehttps://github.com/MotiaDev/motia-examplescdexamples/ai-deep-research-agent
gitclonehttps://github.com/MotiaDev/motia-examplescdexamples/ai-deep-research-agent
Install dependencies:pnpminstall# ornpminstall
Install dependencies:
pnpminstall# ornpminstall
pnpminstall# ornpminstall
Configure environment variables:cp.env.example.envUpdate.envwith your API keys:# RequiredOPENAI_API_KEY=your-openai-api-key-hereFIRECRAWL_API_KEY=your-firecrawl-api-key-here# Optional# OPENAI_MODEL=gpt-4o# FIRECRAWL_BASE_URL=http://your-firecrawl-instance-url
Configure environment variables:
cp.env.example.env
cp.env.example.env
Update.envwith your API keys:
.env
# RequiredOPENAI_API_KEY=your-openai-api-key-hereFIRECRAWL_API_KEY=your-firecrawl-api-key-here# Optional# OPENAI_MODEL=gpt-4o# FIRECRAWL_BASE_URL=http://your-firecrawl-instance-url
# RequiredOPENAI_API_KEY=your-openai-api-key-hereFIRECRAWL_API_KEY=your-firecrawl-api-key-here# Optional# OPENAI_MODEL=gpt-4o# FIRECRAWL_BASE_URL=http://your-firecrawl-instance-url
🏗️ Architecture
🚦 API Endpoints
Start Research
POST /researchContent-Type: application/json{"query": "The research topic or question","breadth": 4,// Number of search queries to generate (1-10)"depth": 2// Depth of research iterations (1-5)}
POST /researchContent-Type: application/json{"query": "The research topic or question","breadth": 4,// Number of search queries to generate (1-10)"depth": 2// Depth of research iterations (1-5)}
Response:
{"message":"Research process started","requestId":"unique-trace-id"}
{"message":"Research process started","requestId":"unique-trace-id"}
Check Research Status
GET /research/status?requestId=unique-trace-id
GET /research/status?requestId=unique-trace-id
Response:
{"message":"Research status retrieved successfully","requestId":"unique-trace-id","originalQuery":"The research topic or question","status":"in-progress","progress": {"currentDepth":1,"totalDepth":2,"percentComplete":50},"reportAvailable":false}
{"message":"Research status retrieved successfully","requestId":"unique-trace-id","originalQuery":"The research topic or question","status":"in-progress","progress": {"currentDepth":1,"totalDepth":2,"percentComplete":50},"reportAvailable":false}
Get Research Report
GET /research/report?requestId=unique-trace-id
GET /research/report?requestId=unique-trace-id
Response:
{"message":"Research report retrieved successfully","report": {"title":"Research Report Title","overview":"Executive summary...","sections": [{"title":"Section Title","content":"Section content..."}],"keyTakeaways": ["Key takeaway 1","Key takeaway 2"],"sources": [{"title":"Source Title","url":"Source URL"}],"originalQuery":"The research topic or question","metadata": {"depthUsed":2,"completedAt":"2025-03-18T16:45:30Z"}},"requestId":"unique-trace-id"}
{"message":"Research report retrieved successfully","report": {"title":"Research Report Title","overview":"Executive summary...","sections": [{"title":"Section Title","content":"Section content..."}],"keyTakeaways": ["Key takeaway 1","Key takeaway 2"],"sources": [{"title":"Source Title","url":"Source URL"}],"originalQuery":"The research topic or question","metadata": {"depthUsed":2,"completedAt":"2025-03-18T16:45:30Z"}},"requestId":"unique-trace-id"}
🏃‍♂️ Running the Application
Start the development server:pnpmdev
Start the development server:
pnpmdev
pnpmdev
Access the Motia Workbench:http://localhost:3000
Access the Motia Workbench:
http://localhost:3000
http://localhost:3000
Make a test request:curl--requestPOST\--urlhttp://localhost:3000/research\--header'Content-Type: application/json'\--data'{"query": "Advancements in renewable energy storage","depth": 1,"breadth": 1}'
Make a test request:
curl--requestPOST\--urlhttp://localhost:3000/research\--header'Content-Type: application/json'\--data'{"query": "Advancements in renewable energy storage","depth": 1,"breadth": 1}'
curl--requestPOST\--urlhttp://localhost:3000/research\--header'Content-Type: application/json'\--data'{"query": "Advancements in renewable energy storage","depth": 1,"breadth": 1}'
🙏 Acknowledgments
Motia Frameworkfor the event-driven workflow engine
OpenAIfor AI analysis
Firecrawlfor Web search and content extraction API
Finance Agent
A powerful event-driven financial analysis workflow that combines web search, financial data, and AI analysis to provide comprehensive investment insights.
Project Structure
Learn about Motia's project structure, file organization, and automatic step discovery system for building scalable workflow applications.
On this page



===== https://www.motia.dev/docs/ai-development-guide =====

AI Development Guide
Guide for building Motia applications with AI coding tools
Quick Setup
When you create a new Motia project, the AI development guides are automatically included:
npxmotia@latestcreatecd<your-project>
npxmotia@latestcreatecd<your-project>
Your project now has AI development guides in.cursor/rules/that work with all major AI coding tools.
.cursor/rules/
What's Included
Complete guides withTypeScript, JavaScript, and Pythonexamples for:
API Steps, Event Steps, Cron Steps
State Management, Middleware, Real-time Streaming
Virtual Steps, UI Steps
Architecture & Error Handling
Supported AI Tools
Works Out of the Box
Cursor IDE- Reads.cursor/rules/directly
.cursor/rules/
Claude Code- Uses pre-configured subagents in.claude/agents/
.claude/agents/
OpenCode, Codex- ViaAGENTS.md
AGENTS.md
Aider, Jules, Factory, Amp, GitHub Copilot, Gemini CLI- ViaAGENTS.mdstandard
Coming Soon
Windsurf, Cline
Usage
Just start coding - your AI tool will automatically read the guides and follow Motia patterns.
For Claude Code:Use/agentsto see available subagents, or invoke them directly:
/agents
Use the motia-developer subagent to create a email marketing backend system
Use the motia-developer subagent to create a email marketing backend system
Update Guides
npxmotiarulespull# Update to latestnpxmotiarulespull--force# Overwrite existing
npxmotiarulespull# Update to latestnpxmotiarulespull--force# Overwrite existing
Best Practices
Commit.cursor/,AGENTS.md, and config files to Git
.cursor/
AGENTS.md
Runnpx motia rules pullafter upgrading Motia
npx motia rules pull
Customize guides for project-specific needs
View source:/cursor-rules
Continuous Deployment
Move faster with continuous deployment
Video Showcase
Watch Motia in action through our video demonstrations and tutorials
On this page



===== https://www.motia.dev/docs/video-showcase =====

Video Showcase
Watch Motia in action through our video demonstrations and tutorials
Video Showcase
Explore Motia's capabilities through our collection of demonstration videos and tutorials. These videos showcase real-world examples, feature walkthroughs, and development workflows.
Featured Videos
Watch Motia in action with these curated video demonstrations
A challenge to traditional backend development flow
A challenge to traditional backend
Vercel but for backend
Motia Overview
Next.js Background Jobs Are Easy Now
Next.js Background Jobs with Motia
You have never seen a DX (Developer Experience) like this
Motia's Interactive tutorial Demo
The only AI framework you’ll ever need
Motia's tutorial for LinkedIn and Twitter Automation on Typefully
Adding More Videos
To add more videos to this showcase, simply edit this file and add new video objects to thevideosarray. Each video should have:
videos
id: A unique identifier for the video
id
title: The display title for the video
title
description: A brief description of what the video covers
description
url: The YouTube URL (supports various formats)
url
{id:"your-video-id",title:"Your Video Title",description:"Brief description of the video content",url:"https://youtu.be/YOUR_VIDEO_ID"}
{id:"your-video-id",title:"Your Video Title",description:"Brief description of the video content",url:"https://youtu.be/YOUR_VIDEO_ID"}
AI Development Guide
Guide for building Motia applications with AI coding tools
How to Contribute
Guide for developers who want to contribute to Motia
On this page



===== https://www.motia.dev/docs/contribution =====

How to Contribute
Guide for developers who want to contribute to Motia
How to Contribute
Thank you for your interest in contributing to Motia! We welcome contributions from the community to help make Motia better. Here are some ways you can contribute:
Reporting Issues
If you encounter any bugs, have feature requests, or want to discuss improvements, pleaseopen an issueon our GitHub repository. When reporting bugs, please provide detailed information about your environment and steps to reproduce the issue.
Submitting Pull Requests
We appreciate pull requests for bug fixes, enhancements, or new features. To submit a pull request:
Fork theMotia repositoryon GitHub.
Create a new branch from themainbranch for your changes.
main
Make your modifications and ensure that the code follows our coding conventions.
Write tests to cover your changes, if applicable.
Commit your changes and push them to your forked repository.
Open a pull request against themainbranch of the Motia repository.
main
Please provide a clear description of your changes in the pull request, along with any relevant information or context.
Documentation Improvements
Improving the documentation is a great way to contribute to Motia. If you find any errors, typos, or areas that need clarification, please submit a pull request with the necessary changes. The documentation source files are located in thepackages/docs/contentdirectory.
packages/docs/content
Sharing Examples and Use Cases
If you have built something interesting with Motia or have a real-world use case to share, we would love to showcase it in ourExamplessection. You can contribute your examples by submitting a pull request to theMotia Examples repository.
Spreading the Word
Help spread the word about Motia by sharing it with your friends, colleagues, and the developer community. You can also star ourGitHub repository, follow us onTwitter, and join ourDiscord communityto stay updated with the latest news and engage with other Motia developers.
We appreciate all forms of contributions and look forward to collaborating with you to make Motia even better!
Video Showcase
Watch Motia in action through our video demonstrations and tutorials
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/community-resources =====

Community Resources
Join the Motia community and get help with questions, examples, and discussions.
Community Resources
Welcome to the Motia community! Whether you're just getting started or building production applications, our community is here to help you succeed with Motia.
💬 Get Help & Support
Discord Community
Best for: Real-time help, discussions, and community support
Join Discord Community
Connect with the Motia team and fellow developers, ask questions, share ideas, and get real-time help from the community.
GitHub Issues
Best for: Bug reports, feature requests, technical issues
Report Issues on GitHub
Found a bug or have a feature request? Open an issue on our GitHub repository with detailed information about your environment and steps to reproduce.
🚀 Development & Contribution
Main Repository
The heart of Motia development
⭐ Star on GitHub
Star our repository, contribute to the project, submit pull requests, and help shape the future of Motia.
Examples Repository
Learn from real-world implementations
Browse Examples
Explore complete implementations, step-by-step tutorials, and production-ready configurations. Perfect for learning and building your own applications.
Roadmap
See what's coming next
View Roadmap
Check out our public roadmap to see upcoming features, improvements, and community requests.
📱 Stay Connected
Social Media
Follow us for the latest news, updates, and community highlights:
YouTube Channel
Video tutorials, demos, and deep dives
Subscribe to YouTube
Watch video tutorials, live streams, and learn from the Motia team and community.
🎯 Quick Links
Documentation
Getting Started- Learn the basics of Motia
API Endpoints Tutorial- Hands-on REST API tutorial
Examples- Real-world use cases and implementations
API Reference- Complete API documentation
Community Guidelines
How to Contribute- Guidelines for contributing to Motia
Be respectful- Treat everyone with kindness and respect
Help others- Share your knowledge and help fellow developers
Stay on topic- Keep discussions relevant to Motia and development
💝 Ways to Support Motia
⭐Star our repositoryon GitHub
🐦Share on social media- Help spread the word about Motia
📝Write about your experience- Blog posts, tutorials, case studies
🐛Report bugs- Help us improve by reporting issues
💡Suggest features- Share your ideas for new features
🤝Contribute code- Submit pull requests and improvements
📖Improve documentation- Help make our docs better
🆘 Getting Help
Before Asking for Help
Check the documentation- Most questions are answered in our docs
Search existing issues- Your question might already be answered
Try the examples- See if our examples solve your problem
When Asking for Help
Be specific- Include code snippets, error messages, and steps to reproduce
Share your environment- OS, Node.js version, Motia version
Explain your goal- Help us understand what you're trying to achieve
Response Times
Discord: Real-time community support (fastest)
GitHub Issues: Official team response within 1-3 business days
Social Media: Community engagement and announcements
Welcome to the Motia community!🎉
We're excited to have you here and can't wait to see what amazing things you'll build with Motia. Whether you're just getting started or you're a seasoned developer, our community is here to support your journey.
How to Contribute
Guide for developers who want to contribute to Motia
API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
On this page



===== https://www.motia.dev/docs/api-reference =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#api-reference =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#core-types =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#step-configuration-types =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#apirouteconfig =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#eventconfig =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#cronconfig =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#noopconfig =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#context-api =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#flowcontext =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#logger =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#statemanager =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#streamsmanager =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#handler-types =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#api-handler =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#event-handler =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#cron-handler =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#middleware =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#request--response-types =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#apirequest =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#apiresponse =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#emitevent =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#stream-configuration =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#streamconfig =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#utility-types =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#emit =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#queryparam =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#streamitem =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/api-reference#whats-next =====

API Reference
Complete API reference for Motia framework - types, interfaces, and utilities
API Reference
Complete reference documentation for Motia's TypeScript/JavaScript and Python APIs.
Core Types
Step Configuration Types
Configuration for API Steps (HTTP endpoints).
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
interfaceApiRouteConfig{type:'api'name:stringdescription?:stringpath:stringmethod:'GET'|'POST'|'PUT'|'DELETE'|'PATCH'|'OPTIONS'|'HEAD'emits:Emit[]virtualEmits?:Emit[]virtualSubscribes?:string[]flows?:string[]middleware?:ApiMiddleware[]bodySchema?:ZodInputresponseSchema?:Record<number,ZodInput>queryParams?:QueryParam[]includeFiles?:string[]}
Configuration for Event Steps (background tasks).
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
interfaceEventConfig{type:'event'name:stringdescription?:stringsubscribes:string[]emits:Emit[]virtualEmits?:Emit[]input:ZodInputflows?:string[]includeFiles?:string[]}
Configuration for Cron Steps (scheduled tasks).
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
interfaceCronConfig{type:'cron'name:stringdescription?:stringcron:stringemits:Emit[]virtualEmits?:Emit[]flows?:string[]includeFiles?:string[]}
Configuration for NOOP Steps (visual connectors).
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
interfaceNoopConfig{type:'noop'name:stringdescription?:stringvirtualEmits:Emit[]virtualSubscribes:string[]flows?:string[]}
Context API
The context object available in all Step handlers.
FlowContext
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
interfaceFlowContext<TEmitData=never> {// Event emissionemit:(event:EmitEvent<TEmitData>)=>Promise<void>// Structured logginglogger:Logger// State managementstate:StateManager// Real-time streamsstreams:StreamsManager// Request tracingtraceId:string}
Logger
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
interfaceLogger{info(message:string,metadata?:Record<string,any>):voiderror(message:string,metadata?:Record<string,any>):voidwarn(message:string,metadata?:Record<string,any>):voiddebug(message:string,metadata?:Record<string,any>):void}
StateManager
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
interfaceStateManager{get<T>(groupId:string,key:string):Promise<T|null>set<T>(groupId:string,key:string,value:T):Promise<T>delete<T>(groupId:string,key:string):Promise<T|null>getGroup<T>(groupId:string):Promise<T[]>clear(groupId:string):Promise<void>}
StreamsManager
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
interfaceMotiaStream<TData> {get(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>set(groupId:string,id:string,data:TData):Promise<BaseStreamItem<TData>>delete(groupId:string,id:string):Promise<BaseStreamItem<TData>|null>getGroup(groupId:string):Promise<BaseStreamItem<TData>[]>send<T>(channel:StateStreamEventChannel,event:StateStreamEvent<T>):Promise<void>}
Handler Types
API Handler
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
typeApiRouteHandler<TRequestBody=unknown,TResponseBodyextendsApiResponse<number,unknown>=ApiResponse<number,unknown>,TEmitData=never>=(req:ApiRequest<TRequestBody>,ctx:FlowContext<TEmitData>)=>Promise<TResponseBody>
Event Handler
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
typeEventHandler<TInput=unknown,TEmitData=never>=(input:TInput,ctx:FlowContext<TEmitData>)=>Promise<void>
Cron Handler
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
typeCronHandler<TEmitData=never>=(ctx:FlowContext<TEmitData>)=>Promise<void>
Middleware
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
typeApiMiddleware=(req:ApiRequest,ctx:FlowContext,next:()=>Promise<ApiResponse>)=>Promise<ApiResponse>
Request & Response Types
ApiRequest
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
interfaceApiRequest<TBody=unknown> {pathParams:Record<string,string>queryParams:Record<string,string|string[]>body:TBodyheaders:Record<string,string|string[]>}
ApiResponse
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
interfaceApiResponse<TStatusextendsnumber=number,TBody=unknown> {status:TStatusbody:TBodyheaders?:Record<string,string|string[]>}
EmitEvent
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
interfaceEmitEvent<TData=unknown> {topic:stringdata:TData}
Stream Configuration
StreamConfig
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
interfaceStreamConfig{name:stringschema:ZodInputbaseConfig:{storageType:'default'}}
Utility Types
Emit
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
typeEmit=string|{topic:stringlabel?:stringconditional?:boolean}
QueryParam
interfaceQueryParam{name:stringdescription:string}
interfaceQueryParam{name:stringdescription:string}
StreamItem
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
interfaceBaseStreamItem<TData> {groupId:stringid:stringdata:TDatacreatedAt:stringupdatedAt:string}
What's Next?
📝 Defining Steps
Learn how to use these types in your Steps
🔄 State Management
Deep dive into the State API
📡 Streams
Learn about real-time streaming
💡 Examples
See these APIs in action
Community Resources
Join the Motia community and get help with questions, examples, and discussions.
On this page



===== https://www.motia.dev/docs/development-guide/state-management =====

State Management
Learn how to manage state within your Motia.dev workflows for persistent data and cross-step communication.
State management is fundamental to building robust and dynamic workflows in Motia.dev. Our system is designed to be powerful yet simple, providing you with everything you need to maintain state across your flows and steps:
✨Zero Configuration (Default):In-memory storage out of the box for quick setup.🔌Flexible Storage Options:Choose from Memory, File, and Redis adapters to suit your persistence needs.🧹Automatic State Cleanup:Optional Time-To-Live (TTL) support for automatic state expiration (Redis).🔒Built-in Isolation:Each flow execution can use its own isolated state, ensuring data separation and security.
Core Concepts: State Manager Methods
Thestateobject, accessible within your step handlers via thectxcontext, provides the following methods for state management:
state
ctx
get
scope: string, key: string
Promise<T | null>
key
scope
null
T
set
scope: string, key: string, value: T
Promise<void>
value
key
scope
T
delete
scope: string, key: string
Promise<void>
key
scope
clear
scope: string
Promise<void>
scope
cleanup
Promise<void>
Important:State manager methods (get,set,delete,clear)require ascopestring as the first parameter.While in most cases, you will use thetraceId(automatically provided inctx.traceId) as the scope to ensure flow-level isolation,you can technically use any string value as the scopeto group and manage state data as needed. UsingtraceIdis the recommended and most common practice for flow-isolated state.
get
set
delete
clear
scope
traceId
ctx.traceId
traceId
State Scope and Isolation
Each flow execution in Motia.dev is assigned a uniquetraceId(a UUID). Using thistraceIdas thescopefor state management provides automatic isolation, ensuring:(Revised to clarifytraceIdas scope)
traceId
traceId
traceId
traceId
traceId
traceId
state.clear(traceId)
State Structure Example
State data is stored as key-value pairs, namespaced under a scope string. When usingtraceIdas the scope, the internal structure might look like this:
traceId
// Example state structure (internal representation) - using traceId as scope{"motia:state:{traceId-123}": {// State for flow execution with traceId 'traceId-123' (scope)"booking": {// Namespaced key 'booking'"customer": {...},"venue": {...}},"payment": {// Namespaced key 'payment'"status":"pending","amount":100}},"motia:state:{traceId-456}": {// State for another flow execution with traceId 'traceId-456' (different scope)// ... different state data for this flow ...}}
// Example state structure (internal representation) - using traceId as scope{"motia:state:{traceId-123}": {// State for flow execution with traceId 'traceId-123' (scope)"booking": {// Namespaced key 'booking'"customer": {...},"venue": {...}},"payment": {// Namespaced key 'payment'"status":"pending","amount":100}},"motia:state:{traceId-456}": {// State for another flow execution with traceId 'traceId-456' (different scope)// ... different state data for this flow ...}}
Info:You can access thestatemanager within any step through thectx(context) argument, which is automatically injected into yourstep handler. WhiletraceIdfromctx.traceIdis the recommended scope for flow isolation, remember thatyou can use any string as the scopeparameter instatemethods for more advanced state management scenarios.
state
ctx
traceId
ctx.traceId
state
Using State in Steps
import{ Handlers }from'motia'interfaceBookingData{customer:{name:string;email:string};venue:{id:string;name:string};}exportconsthandler:Handlers['StepName']=async(input, {state,traceId})=>{// Get traceId from context// Store state (using traceId as scope)awaitstate.set<BookingData>(traceId,'booking', {customer: input.customer,venue: input.venue,});// Retrieve state (using traceId as scope)constbooking=awaitstate.get<BookingData>(traceId,'booking');// Delete specific state (using traceId as scope)awaitstate.delete(traceId,'booking');// Clear all state for this flow (using traceId as scope)awaitstate.clear(traceId);}
import{ Handlers }from'motia'interfaceBookingData{customer:{name:string;email:string};venue:{id:string;name:string};}exportconsthandler:Handlers['StepName']=async(input, {state,traceId})=>{// Get traceId from context// Store state (using traceId as scope)awaitstate.set<BookingData>(traceId,'booking', {customer: input.customer,venue: input.venue,});// Retrieve state (using traceId as scope)constbooking=awaitstate.get<BookingData>(traceId,'booking');// Delete specific state (using traceId as scope)awaitstate.delete(traceId,'booking');// Clear all state for this flow (using traceId as scope)awaitstate.clear(traceId);}
Debugging
Inspecting State
State is only available during runtime in the Node.js process memory. You cannot inspect memory state directly outside of a running step execution. Use logging within your steps to output state values for debugging purposes.
Best Practices
Namespacing
Use dot notation to organize related state data hierarchically:
// Good - Organized hierarchically (using traceId scope)awaitstate.set(traceId,'booking.customer', customerData)awaitstate.set(traceId,'booking.venue', venueData)awaitstate.set(traceId,'payment.status','pending')// Avoid - Flat structure (using traceId scope)awaitstate.set(traceId,'customer', customerData)awaitstate.set(traceId,'venue', venueData)awaitstate.set(traceId,'paymentStatus','pending')
// Good - Organized hierarchically (using traceId scope)awaitstate.set(traceId,'booking.customer', customerData)awaitstate.set(traceId,'booking.venue', venueData)awaitstate.set(traceId,'payment.status','pending')// Avoid - Flat structure (using traceId scope)awaitstate.set(traceId,'customer', customerData)awaitstate.set(traceId,'venue', venueData)awaitstate.set(traceId,'paymentStatus','pending')
Type Safety
Define types for your state data to ensure consistency:
interfaceCustomerData{name:string;email:string;}interfaceVenueData{id:string;capacity:number;}typeBookingState={customer:CustomerData;venue:VenueData;status:'pending'|'confirmed';}constbooking=awaitstate.get<BookingState>(traceId,'booking')
interfaceCustomerData{name:string;email:string;}interfaceVenueData{id:string;capacity:number;}typeBookingState={customer:CustomerData;venue:VenueData;status:'pending'|'confirmed';}constbooking=awaitstate.get<BookingState>(traceId,'booking')
Cleanup
Always clean up state when you're done with it:
exportconsthandler:Handlers['StepName']=async(input, {state,traceId})=>{try{awaitprocessBooking(input)// Clean up specific keysawaitstate.delete(traceId,'booking.customer')// Or clean everythingawaitstate.clear(traceId)}catch(error) {// Handle errors}}
exportconsthandler:Handlers['StepName']=async(input, {state,traceId})=>{try{awaitprocessBooking(input)// Clean up specific keysawaitstate.delete(traceId,'booking.customer')// Or clean everythingawaitstate.clear(traceId)}catch(error) {// Handle errors}}
Performance Considerations
Custom State Adapters
import{ StateAdapter }from'motia'classCustomStateAdapterextendsStateAdapter{asyncget<T>(traceId:string,key:string):Promise<T|null> {// Implementationreturnnull}asyncset<T>(traceId:string,key:string,value:T):Promise<void> {// Implementation}asyncdelete(traceId:string,key:string):Promise<void> {// Implementation}asyncclear(traceId:string):Promise<void> {// Implementation}asynccleanup():Promise<void> {// Implementation}}
import{ StateAdapter }from'motia'classCustomStateAdapterextendsStateAdapter{asyncget<T>(traceId:string,key:string):Promise<T|null> {// Implementationreturnnull}asyncset<T>(traceId:string,key:string,value:T):Promise<void> {// Implementation}asyncdelete(traceId:string,key:string):Promise<void> {// Implementation}asyncclear(traceId:string):Promise<void> {// Implementation}asynccleanup():Promise<void> {// Implementation}}
Storage Adapters
Motia.dev offers three built-in storage adapters:
📁File (Default):Persists state to a JSON file in your project (.motia/motia.state.json). No configuration needed for basic use.
.motia/motia.state.json
💾Memory:Stores state in-memory. Fastest option, but state is not persistent across server restarts. Useful for development and non-critical data.
⚡Redis:Leverages Redis for persistent and scalable state storage. Ideal for production environments and flows requiring high availability and data durability.
To configure a different state adapter, modify theconfig.ymlfile in your project root:
config.yml
my-project/├── config.yml└── steps/├── step-1.ts└── step-2.ts
my-project/├── config.yml└── steps/├── step-1.ts└── step-2.ts
File Adapter (Default)
Default, no configuration required, state is stored into .motia/motia.state.json in your project root
Memory Adapter
state:adapter:memory
state:adapter:memory
Warning: Memory AdapterState is stored in-memory and will be lost when the Motia.dev server restarts. Suitable for development and testing.
Redis Adapter
state:adapter:redishost:localhost# Redis server host (e.g., 'localhost' or IP address)port:6379# Redis server port (default: 6379)password:optional# Redis password (if required)ttl:3600# Optional: State Time-To-Live in seconds (e.g., 3600 seconds = 1 hour)
state:adapter:redishost:localhost# Redis server host (e.g., 'localhost' or IP address)port:6379# Redis server port (default: 6379)password:optional# Redis password (if required)ttl:3600# Optional: State Time-To-Live in seconds (e.g., 3600 seconds = 1 hour)
Info: Redis AdapterRecommended for production environments. Requires a running Redis server. Thettl(Time-To-Live) option is available to automatically expire state data after a specified number of seconds, helping to manage Redis storage.
ttl
Common Issues
traceId
state.get(traceId, key)
Project Structure
Learn about Motia's project structure, file organization, and automatic step discovery system for building scalable workflow applications.
Real-time Streams
Motia Streams are a way to quickly push updates from your asynchronous workflows to the client without having to implement any sort of polling processes.
On this page



===== https://www.motia.dev/docs/development-guide/project-structure =====

Project Structure
Learn about Motia's project structure, file organization, and automatic step discovery system for building scalable workflow applications.
Project Structure
Understanding how to organize your Motia project is crucial for building maintainable and scalable workflow applications. This guide covers the directory structure, file naming conventions, and Motia's automatic step discovery system.
Basic Project Structure
Here's what a typical Motia project looks like:
File Descriptions
01-api-gateway.step.ts
02-data-processor_step.py
03-send-notification.step.js
send-notification.tsx
package.json
requirements.txt
tsconfig.json
types.d.ts
motia-workbench.json
config.yml
Thesteps/directory is the heart of your Motia application - this is where all your workflow logic lives. Motia automatically discovers and registers any file following the naming pattern.
steps/
Thesteps/directory must live at theproject root(e.g.,my-motia-project/steps).
steps/
my-motia-project/steps
You can freely nest steps in subfolders understeps/(e.g.,steps/aaa/a1.step.ts,steps/bbb/ccc/c1_step.py).
steps/
steps/aaa/a1.step.ts
steps/bbb/ccc/c1_step.py
Discovery is recursive insidesteps/, so deeper folder structures for large apps are supported.
steps/
Automatic Step Discovery
Key Concept: Automatic Discovery
Motia will automatically discover and registerany filethat follows the.step.naming pattern as a workflow step. You don't need to manually register steps - just create a file with the right naming pattern and Motia will find it.
.step.
Discovery Rules
Motia scans yoursteps/directory and automatically registers files as steps based on these rules:
steps/
File must contain.step.or_step.in the filename(e.g.,my-task.step.ts,my_task_step.py)
.step.
_step.
my-task.step.ts
my_task_step.py
File must export aconfigobjectdefining the step configuration
config
File must export ahandlerfunctioncontaining the step logic
handler
File extension determines the runtime(.ts= TypeScript,.py= Python,.js= JavaScript)
.ts
.py
.js
When you runmotia dev, Motia will:
motia dev
Scan thesteps/directory recursively
steps/
Find all files matching*.step.*
*.step.*
Parse theirconfigexports to understand step types and connections
config
Register them in the workflow engine
Make them available in the Workbench
File Naming Convention
Motia uses this specific pattern for automatic step discovery:
[prefix-]descriptive-name.step.[extension]
[prefix-]descriptive-name.step.[extension]
The.step.part in the filename isrequired- this is how Motia identifies which files are workflow steps during automatic discovery.
.step.
Supported Languages & Extensions
.ts
user-registration.step.ts
.py
data-analysis_step.py
.js
send-notification.step.js
Naming Examples by Step Type
01-auth-api.step.ts
01-auth-api_step.py
auth_api_step.py
01-auth-api.step.js
process-order.step.ts
process-order_step.py
process_order_step.py
process-order.step.js
daily-report.step.ts
daily-report_step.py
daily_report_step.py
daily-report.step.js
transform-data.step.ts
ml-analysis_step.py
ml_analysis_step.py
data-cleanup.step.js
Step Organization Patterns
Sequential Flow Organization
Perfect for linear workflows where order matters:
01-api-start.step.ts
02-validate-data_step.py
03-process-payment.step.js
04-send-confirmation.step.ts
05-cleanup_step.py
Language-Specific Configuration
TypeScript/JavaScript Projects
For Node.js-based steps, you'll need:
{"name":"my-motia-app","version":"1.0.0","scripts": {"dev":"motia dev","build":"motia build","start":"motia start"},"dependencies": {"motia":"^0.5.12-beta.121","zod":"^3.24.4"},"devDependencies": {"typescript":"^5.7.3","@types/node":"^20.0.0"}}
{"name":"my-motia-app","version":"1.0.0","scripts": {"dev":"motia dev","build":"motia build","start":"motia start"},"dependencies": {"motia":"^0.5.12-beta.121","zod":"^3.24.4"},"devDependencies": {"typescript":"^5.7.3","@types/node":"^20.0.0"}}
{"compilerOptions": {"target":"ES2020","module":"ESNext","moduleResolution":"Node","esModuleInterop":true,"strict":true,"skipLibCheck":true},"include": ["**/*.ts","**/*.tsx"],"exclude": ["node_modules","dist"]}
{"compilerOptions": {"target":"ES2020","module":"ESNext","moduleResolution":"Node","esModuleInterop":true,"strict":true,"skipLibCheck":true},"include": ["**/*.ts","**/*.tsx"],"exclude": ["node_modules","dist"]}
Python Projects
For Python-based steps:
# Core Motia dependencymotia>=0.5.12# Common dependenciesrequests>=2.28.0pydantic>=1.10.0# Data processing (if needed)pandas>=1.5.0numpy>=1.21.0
# Core Motia dependencymotia>=0.5.12# Common dependenciesrequests>=2.28.0pydantic>=1.10.0# Data processing (if needed)pandas>=1.5.0numpy>=1.21.0
Step Discovery Examples
Let's see how Motia discovers different step types:
Example 1: TypeScript API Step
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'// Motia discovers this file because:// 1. Filename contains '.step.'// 2. Exports 'config' object// 3. Has .ts extension -> uses TypeScript runtimeexportconstconfig:ApiRouteConfig={type:'api',name:'user-api',path:'/users',method:'GET',emits: ['users.fetched'],flows: ['user-management']}exportconsthandler:Handlers['user-api']=async(req, {emit})=>{awaitemit({topic:'users.fetched',data: { users: [] }})return{status:200,body: { message:'Users retrieved'}}}
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'// Motia discovers this file because:// 1. Filename contains '.step.'// 2. Exports 'config' object// 3. Has .ts extension -> uses TypeScript runtimeexportconstconfig:ApiRouteConfig={type:'api',name:'user-api',path:'/users',method:'GET',emits: ['users.fetched'],flows: ['user-management']}exportconsthandler:Handlers['user-api']=async(req, {emit})=>{awaitemit({topic:'users.fetched',data: { users: [] }})return{status:200,body: { message:'Users retrieved'}}}
Example 2: Python Event Step
# Motia discovers this file because:# 1. Filename contains '.step.'# 2. Exports 'config' dict# 3. Has .py extension -> uses Python runtimeconfig={"type":"event","name":"data-processor","description":"Process incoming data with Python","subscribes": ["users.fetched"],"emits": ["data.processed"],"flows": ["user-management"]}asyncdefhandler(input_data, ctx):"""Process the data"""processed_data={"original": input_data,"processed_at": ctx.utils.dates.now().isoformat(),"count":len(input_data.get("users", []))}awaitctx.emit({"topic":"data.processed","data": processed_data})
# Motia discovers this file because:# 1. Filename contains '.step.'# 2. Exports 'config' dict# 3. Has .py extension -> uses Python runtimeconfig={"type":"event","name":"data-processor","description":"Process incoming data with Python","subscribes": ["users.fetched"],"emits": ["data.processed"],"flows": ["user-management"]}asyncdefhandler(input_data, ctx):"""Process the data"""processed_data={"original": input_data,"processed_at": ctx.utils.dates.now().isoformat(),"count":len(input_data.get("users", []))}awaitctx.emit({"topic":"data.processed","data": processed_data})
Example 3: JavaScript Automation Step
// Motia discovers this file because:// 1. Filename contains '.step.'// 2. Exports 'config' object// 3. Has .js extension -> uses Node.js runtimeexportconstconfig={type:'event',name:'send-notifications',description:'Send notifications via multiple channels',subscribes: ['data.processed'],emits: ['notifications.sent'],flows: ['user-management']}exportconsthandler=async(input, {emit,logger})=>{logger.info('Sending notifications', { data: input })// Send email, SMS, push notifications, etc.constresults=awaitPromise.all([sendEmail(input),sendSMS(input),sendPush(input)])awaitemit({topic:'notifications.sent',data: {results,sent_at:newDate().toISOString()}})}asyncfunctionsendEmail(data) {/* implementation */}asyncfunctionsendSMS(data) {/* implementation */}asyncfunctionsendPush(data) {/* implementation */}
// Motia discovers this file because:// 1. Filename contains '.step.'// 2. Exports 'config' object// 3. Has .js extension -> uses Node.js runtimeexportconstconfig={type:'event',name:'send-notifications',description:'Send notifications via multiple channels',subscribes: ['data.processed'],emits: ['notifications.sent'],flows: ['user-management']}exportconsthandler=async(input, {emit,logger})=>{logger.info('Sending notifications', { data: input })// Send email, SMS, push notifications, etc.constresults=awaitPromise.all([sendEmail(input),sendSMS(input),sendPush(input)])awaitemit({topic:'notifications.sent',data: {results,sent_at:newDate().toISOString()}})}asyncfunctionsendEmail(data) {/* implementation */}asyncfunctionsendSMS(data) {/* implementation */}asyncfunctionsendPush(data) {/* implementation */}
Auto-Generated Files
Some files in your Motia project are automatically generated:
types.d.ts- TypeScript generates this for type definitions
types.d.ts
motia-workbench.json- Motia manages visual node positions in the Workbench
motia-workbench.json
Discovery Troubleshooting
If Motia isn't discovering your steps:
Common Issues
Missing.step.(or_stepfor Python) in filename
.step.
_step
❌Won't be discovered:
✅Will be discovered:
Discovery Verification
Check if your steps are discovered:
# Run Motia in development modemotiadev# Look step creation in your console console:➜[CREATED] Step (Cron) steps/petstore/state-audit-cron.step.ts created➜[CREATED] Step (Event) steps/petstore/process-food-order.step.ts created➜[CREATED] Step (Event) steps/petstore/notification.step.ts created➜[CREATED] Step (API) steps/petstore/api.step.ts created
# Run Motia in development modemotiadev# Look step creation in your console console:➜[CREATED] Step (Cron) steps/petstore/state-audit-cron.step.ts created➜[CREATED] Step (Event) steps/petstore/process-food-order.step.ts created➜[CREATED] Step (Event) steps/petstore/notification.step.ts created➜[CREATED] Step (API) steps/petstore/api.step.ts created
Next Steps
Now that you understand how Motia discovers and organizes steps:
Learn aboutCore Conceptsto understand how steps work together
ExploreDefining Stepsfor detailed step creation
Check outTriggersfor API, Event, and Cron steps
AI Research Agent
A powerful research assistant that leverages the Motia Framework to perform comprehensive web research on any topic and any question.
State Management
Learn how to manage state within your Motia.dev workflows for persistent data and cross-step communication.
On this page



===== https://www.motia.dev/docs/development-guide/streams =====

Real-time Streams
Motia Streams are a way to quickly push updates from your asynchronous workflows to the client without having to implement any sort of polling processes.
How it works
You first need to define a stream in your project
Defining a stream
To be able to use Motia Sockets, you need to define a stream
Create a file calledopen-ai.stream.tsundersteps/folder
open-ai.stream.ts
steps/
import{ StreamConfig }from'motia'import{ z }from'zod'exportconstconfig:StreamConfig={/*** This will be converted in the property on the FlowContext:** context.streams.openai*/name:'openai',/*** Schema is important to define the type of the stream, the API* generated to interact with this stream will have the structure defined here*/schema: z.object({ message: z.string() }),/*** Base config is used to configure the stream*/baseConfig: {/*** There are two storage types: default and custom* Default will use the default storage to store the data.** Custom will use a custom storage, you need to implement* the StateStream class.*/storageType:'default',},}
import{ StreamConfig }from'motia'import{ z }from'zod'exportconstconfig:StreamConfig={/*** This will be converted in the property on the FlowContext:** context.streams.openai*/name:'openai',/*** Schema is important to define the type of the stream, the API* generated to interact with this stream will have the structure defined here*/schema: z.object({ message: z.string() }),/*** Base config is used to configure the stream*/baseConfig: {/*** There are two storage types: default and custom* Default will use the default storage to store the data.** Custom will use a custom storage, you need to implement* the StateStream class.*/storageType:'default',},}
Once a stream is created, it should be immediately available in FlowContext (make sure to have motia running on the project)
Then you can simply create records using the streams API in your step
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'exportconstconfig:ApiRouteConfig={type:'api',name:'OpenAiApi',description:'Call OpenAI',path:'/open-ai',method:'POST',emits: ['openai-prompt'],flows: ['open-ai'],bodySchema: z.object({ message: z.string({ description:'The message to send to OpenAI'}) }),responseSchema: {200: z.object({ message: z.string({ description:'The message from OpenAI'}) })},}exportconsthandler:Handlers['OpenAiApi']=async(req, {traceId,logger,emit,streams})=>{logger.info('[Call OpenAI] Received callOpenAi event', { message: req.body.message })/*** This creates a record with empty message string to be populated in the next step*/constresult=awaitstreams.openai.set(traceId,'message', { message:''})awaitemit({topic:'openai-prompt',data: { message: req.body.message },})return{ status:200, body: result }}
import{ ApiRouteConfig, Handlers }from'motia'import{ z }from'zod'exportconstconfig:ApiRouteConfig={type:'api',name:'OpenAiApi',description:'Call OpenAI',path:'/open-ai',method:'POST',emits: ['openai-prompt'],flows: ['open-ai'],bodySchema: z.object({ message: z.string({ description:'The message to send to OpenAI'}) }),responseSchema: {200: z.object({ message: z.string({ description:'The message from OpenAI'}) })},}exportconsthandler:Handlers['OpenAiApi']=async(req, {traceId,logger,emit,streams})=>{logger.info('[Call OpenAI] Received callOpenAi event', { message: req.body.message })/*** This creates a record with empty message string to be populated in the next step*/constresult=awaitstreams.openai.set(traceId,'message', { message:''})awaitemit({topic:'openai-prompt',data: { message: req.body.message },})return{ status:200, body: result }}
The previous step just prepares a message to be created by Open AI via OpenAI SDK stream, which will be populated in the next step
import{ EventConfig, Handlers }from'motia'import{ OpenAI }from'openai'import{ z }from'zod'exportconstconfig:EventConfig={type:'event',name:'CallOpenAi',description:'Call OpenAI',subscribes: ['openai-prompt'],emits: [],input: z.object({message: z.string({ description:'The message to send to OpenAI'}),}),flows: ['open-ai'],}exportconsthandler:Handlers['CallOpenAi']=async(input,context)=>{const{logger,traceId}=contextconstopenai=newOpenAI({ apiKey: process.env.OPENAI_API_KEY})logger.info('[Call OpenAI] Received callOpenAi event', input)constresult=awaitopenai.chat.completions.create({messages: [{ role:'system', content: input.message }],model:'gpt-4o-mini',stream:true,})constmessages:string[]=[]forawait(constchunkofresult) {messages.push(chunk.choices[0].delta.content??'')/*** Now we're populating a previously created message with the streamed data from OpenAI*/awaitcontext.streams.openai.set(traceId,'message', {message: messages.join(''),})}logger.info('[Call OpenAI] OpenAI response', result)}
import{ EventConfig, Handlers }from'motia'import{ OpenAI }from'openai'import{ z }from'zod'exportconstconfig:EventConfig={type:'event',name:'CallOpenAi',description:'Call OpenAI',subscribes: ['openai-prompt'],emits: [],input: z.object({message: z.string({ description:'The message to send to OpenAI'}),}),flows: ['open-ai'],}exportconsthandler:Handlers['CallOpenAi']=async(input,context)=>{const{logger,traceId}=contextconstopenai=newOpenAI({ apiKey: process.env.OPENAI_API_KEY})logger.info('[Call OpenAI] Received callOpenAi event', input)constresult=awaitopenai.chat.completions.create({messages: [{ role:'system', content: input.message }],model:'gpt-4o-mini',stream:true,})constmessages:string[]=[]forawait(constchunkofresult) {messages.push(chunk.choices[0].delta.content??'')/*** Now we're populating a previously created message with the streamed data from OpenAI*/awaitcontext.streams.openai.set(traceId,'message', {message: messages.join(''),})}logger.info('[Call OpenAI] OpenAI response', result)}
Testing Streams in Workbench
We know testing real time events is not easy as a backend developer, so we've added a way to test streams in the Workbench.
Here are the steps to test streams in the Workbench:
The API Step that provides a stream item should return the object
exportconsthandler:Handlers['OpenAiApi']=async(req, {traceId,logger,emit,streams})=>{logger.info('[Call OpenAI] Received callOpenAi event', { message: req.body.message })/*** This creates a record with empty message string to be populated in the next step*/constresult=awaitstreams.openai.set(traceId,'message', { message:''})awaitemit({topic:'openai-prompt',data: { message: req.body.message },})/*** Return the entire object received from the create method*/return{ status:200, body: result }}
exportconsthandler:Handlers['OpenAiApi']=async(req, {traceId,logger,emit,streams})=>{logger.info('[Call OpenAI] Received callOpenAi event', { message: req.body.message })/*** This creates a record with empty message string to be populated in the next step*/constresult=awaitstreams.openai.set(traceId,'message', { message:''})awaitemit({topic:'openai-prompt',data: { message: req.body.message },})/*** Return the entire object received from the create method*/return{ status:200, body: result }}
Navigate tohttp://localhost:3000/endpointsin your Workbench
Open up your endpoint and click on theTestbutton
Test
The result will automatically be streamed from the server to the client streaming it's state real-time.
Consuming stream on the browser
npm install @motiadev/stream-client-react
npm install @motiadev/stream-client-react
Then add the provider to the root of your project
<MotiaStreamProvideraddress="ws://localhost:3000">...</MotiaStreamProvider>
<MotiaStreamProvideraddress="ws://localhost:3000">...</MotiaStreamProvider>
then on your component or hook, just use
constmessageId=''// get the id back from the API call// data below will be updated whenever it's updated in the serverconst{data}=useStreamItem({streamName:'openai',groupId: messageId,id:'message'})
constmessageId=''// get the id back from the API call// data below will be updated whenever it's updated in the serverconst{data}=useStreamItem({streamName:'openai',groupId: messageId,id:'message'})
State Management
Learn how to manage state within your Motia.dev workflows for persistent data and cross-step communication.
Observability
Understanding how to use the logging and debugging system in Motia
On this page



===== https://www.motia.dev/docs/development-guide/observability =====

Observability
Understanding how to use the logging and debugging system in Motia
Overview
Motia provides an out of the box logging and debugging system that works across different runtime environments. The system offers:
Real-time log streaming in both terminal and Motia Workbench
Multiple log levels with contextual information
Local development debugging tools
Integrated flow monitoring
Log Levels and Usage
Motia supports four standard log levels:
Example Usage
exportconsthandler:Handlers['StepName']=async(input, {logger})=>{// Basic logginglogger.info('Starting process')// Logging with contextlogger.info('Operation completed', {operationId: input.id,duration:1500})// Error handlingtry{awaitriskyOperation()}catch(error) {logger.error('Operation failed', {error: error.message,stack: error.stack})}// Debug logginglogger.debug('Operation details', {rawInput: input,timestamp: Date.now()})// Warning loggingif(input.amount>1000) {logger.warn('Large operation detected', {amount: input.amount,threshold:1000})}}
exportconsthandler:Handlers['StepName']=async(input, {logger})=>{// Basic logginglogger.info('Starting process')// Logging with contextlogger.info('Operation completed', {operationId: input.id,duration:1500})// Error handlingtry{awaitriskyOperation()}catch(error) {logger.error('Operation failed', {error: error.message,stack: error.stack})}// Debug logginglogger.debug('Operation details', {rawInput: input,timestamp: Date.now()})// Warning loggingif(input.amount>1000) {logger.warn('Large operation detected', {amount: input.amount,threshold:1000})}}
Running and Debugging
Start the Dev Server
Navigate to your Motia project root folder
Start the development server:
npm run dev
You can monitor logs in two ways:
OpenMotia Workbench, select your flow, and expand the logs container
View logs directly in the terminal where you ran the dev command
Trigger and Monitor Flows
You can trigger flows using either the CLI or anAPI step:
npxmotiaemit--topic<topic>--message'{}'
npxmotiaemit--topic<topic>--message'{}'
Debug Using Logs
Each log entry automatically includes:
timestamp: When the log was generated
timestamp
traceId: Unique identifier for the flow execution
traceId
flows: Array of flow names this step belongs to
flows
file: Source file generating the log
file
level: Log level
level
msg: Log message
msg
Stopping the development server
PressCtrl + C(orCmd + Con macOS) in your terminal. That's it!
Best Practices
Structured Logging
// Good - Structured and searchablelogger.info('Payment processed', {paymentId:'123',amount:100,status:'success',})// Avoid - Harder to parse and searchlogger.info(`Payment ${paymentId} processed: amount=${amount}`)
// Good - Structured and searchablelogger.info('Payment processed', {paymentId:'123',amount:100,status:'success',})// Avoid - Harder to parse and searchlogger.info(`Payment ${paymentId} processed: amount=${amount}`)
Performance Monitoring
exportconsthandler:Handlers['StepName']=async(input, {logger})=>{conststartTime=performance.now()// Process operationconstresult=awaitprocessOperation(input)logger.info('Operation completed', {duration: performance.now()-startTime,memoryUsage: process.memoryUsage().heapUsed,})}
exportconsthandler:Handlers['StepName']=async(input, {logger})=>{conststartTime=performance.now()// Process operationconstresult=awaitprocessOperation(input)logger.info('Operation completed', {duration: performance.now()-startTime,memoryUsage: process.memoryUsage().heapUsed,})}
Debugging Tips
Add detailed context to error logs:
logger.error('Operation failed', {error: error.message,code: error.code,input:JSON.stringify(input),stack: error.stack,})
logger.error('Operation failed', {error: error.message,code: error.code,input:JSON.stringify(input),stack: error.stack,})
Use debug logs for detailed troubleshooting:
logger.debug('Operation details', {rawInput: input,timestamp: Date.now(),state: currentState,})
logger.debug('Operation details', {rawInput: input,timestamp: Date.now(),state: currentState,})
Remember to stop your development server with Ctrl + C (or Cmd + C on macOS) when you're done debugging.
Real-time Streams
Motia Streams are a way to quickly push updates from your asynchronous workflows to the client without having to implement any sort of polling processes.
Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/middleware =====

Middleware
Run code before and after your API handlers
What is Middleware?
Middleware runs before your API handler. Use it for authentication, logging, error handling, or any logic that applies to multiple endpoints.
How It Works
A middleware is a function that receives three arguments:
middleware(req, ctx, next)
middleware(req, ctx, next)
req- The incoming request (same as handler)
ctx- The context object (same as handler)
next()- Call this to continue to the handler
If you don't callnext(), the request stops. The handler never runs.
next()
Simple Example
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
Execution Order
Middleware runs in the order you list them:
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
Modifying Responses
Awaitnext()to get the response, then modify it:
next()
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
Error Handling
Catch errors from handlers:
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
Reusing Middleware
Create middleware files in a shared location:
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
Import and use across steps:
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
What's Next?
Triggers
Learn more about Triggers
Testing
Learn more about testing your Motia Steps
Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Testing
Learn how to write and run tests for your Motia components
On this page



===== https://www.motia.dev/docs/development-guide/testing =====

Testing
Learn how to write and run tests for your Motia components
Testing
Testing is an essential part of building reliable and maintainable Motia applications. Motia provides built-in support for writing and running tests to ensure the correctness of your steps, flows, and event handling logic.
Writing Tests for Motia Components
Motia usesJestas its testing framework. You can write tests for your Motia components using Jest's syntax and assertions.
Step Tests
To test a step, create a test file with the same name as the step file, but with a.test.tsor.test.jsextension. For example, if your step file is namedmy-step.step.ts, create a test file namedmy-step.step.test.ts.
.test.ts
.test.js
my-step.step.ts
my-step.step.test.ts
Here's an example of a step test:
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
In this example, we use thecreateTestContextfunction from@motiadev/testingto create a test context with mockedemitanddonefunctions. We then call the step'shandlerfunction with test input and the mocked context. Finally, we assert that theemitfunction was called with the expected event type and data.
createTestContext
@motiadev/testing
emit
done
handler
emit
Flow Tests
To test a flow, create a test file with the flow name and a.test.tsor.test.jsextension. For example, if your flow is namedmy-flow, create a test file namedmy-flow.test.ts.
.test.ts
.test.js
my-flow
my-flow.test.ts
Here's an example of a flow test:
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
In this example, we use thecreateTestFlowfunction from@motiadev/testingto create a test flow with the specified steps. We then execute the flow with test input and assert that the final result matches the expected output.
createTestFlow
@motiadev/testing
Running Tests Locally
To run tests locally, use the following command:
pnpmtest
pnpmtest
This command will run all the test files in your project and display the test results in the terminal.
You can also run tests in watch mode, which automatically re-runs the tests whenever you make changes to your code:
pnpmtest--watch
pnpmtest--watch
Best Practices
Write tests for each step and flow to ensure comprehensive coverage.
Use meaningful test case descriptions to clarify the purpose of each test.
Test edge cases and error scenarios to ensure your components handle them gracefully.
Keep your tests focused and independent to make them easier to maintain.
Use mocks and stubs to isolate dependencies and improve test reliability.
By following these best practices and regularly running tests, you can catch bugs early, maintain code quality, and ensure the reliability of your Motia application.
Middleware
Run code before and after your API handlers
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
On this page



===== https://www.motia.dev/docs/development-guide/environment-variables =====

Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Environment Variables
Environment variables let you store API keys, database URLs, and other configuration outside your code. This keeps sensitive information secure and makes it easy to use different settings for development and production.
Quick Setup
1. Create a.envFile
.env
Create a.envfile in your project root:
.env
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
2. Add to.gitignore
.gitignore
Make sure you never commit your.envfile:
.env
.env.env.local
.env.env.local
3. Create Template for Your Team
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
Using Environment Variables in Steps
TypeScript/JavaScript
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
Python
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
Deployment
When you deploy your app, set environment variables through your hosting platform:
Motia Cloud
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
Important Security Tips
🔒 Keep Your Keys Safe
Never commit.envfiles to git
.env
Use different API keys for development and production
Don't share API keys in code or messages
That's it! Environment variables are simple - just put them in.envand useprocess.env.VARIABLE_NAMEin your code.
.env
process.env.VARIABLE_NAME
Testing
Learn how to write and run tests for your Motia components
Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
On this page
.env
.gitignore



===== https://www.motia.dev/docs/development-guide/cli =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#command-line-interface-cli =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#installation =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#commands =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#create =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#build =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#deploy =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#dev =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs =====

Welcome to Motia
Motia is a multi-language, event-driven runtime manager built on a core primitive: the Step. It feels like a backend framework, but powers distributed backends for APIs, background jobs, queues, workflows, agents, streaming, state, and observability, all unified in one system.
Welcome to Motia
Why Motia?
Backend development today is fragmented.
APIs live in one framework, background jobs in another, queues and schedulers elsewhere, and now AI agents and streaming systems have their own runtimes. Add observability and state management on top, and you’re stitching together half a dozen tools before writing your first feature.
Motia unifies all of these concerns around one core primitive: the Step.
Just as React made frontend development simple by introducing components, Motia redefines backend development with Steps.
Every backend pattern, API endpoints, background jobs, queues, workflows, AI agents, streaming, observability, and state, is expressed with the same primitive.
To read more about this, check out ourmanifesto.
The Core Primitive: the Step
At the heart of Motia is a single primitive: theStep.
A Step is just a file with aconfigand ahandler. Motia auto-discovers these files from/stepsdirectory and connects them automatically.
config
handler
/steps
Here’s a simple example of two Steps working together: an API Step that emits an event, and an Event Step that processes it.
exportconstconfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
exportconstconfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
exportconstconfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler=async(input, {logger})=>{logger.info('Processing message', input);};
exportconstconfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you’ve built anAPI endpoint, aqueue, and aworker. No extra frameworks required.
Learn more about Steps here:What is a Step?.
Working with multiple Languages
The rapid advancement of AI has reshaped the software industry—many cutting-edge AI tools are available only in specific programming languages, this forces companies to decide if they either change their team's skillset to a different language or not leveraging these technologies at all.
Motia removes this limitation by allowing each Step to be written in any language, while still sharing a common state.
Each rectangle in the diagram above represents a Step, some of them are in TypeScript and others in Python.
Scalability
One of the biggest dilemmas in backend development is choosing between scalability and development velocity. In startup environments, speed often takes priority, resulting in systems that don't scale well and become problematic under increased load.
Motia addresses scalability by leveraging the core primitive ofSteps: Each step can scale independently avoiding the bottlenecks common in monolithic architectures.
Observability
Observability in traditional backends often demands significant engineering effort to implement logging, alerting, and tracing. Typically, these tools are only configured for cloud environments, local development is generally neglected—leading to low productivity and poor dev experience.
Motia offers a complete observability toolkit available in both cloud and local environments, including:
Logs visualization
Tracing tool to quickly visualize the flow of requests through the system
State visualization
Diagram representation of dependencies between steps and how they are connected
The image below shows the Workbench interface available when you runmotia dev. On the top panel you can see a workflow diagram with multiple steps connected.
On the bottom panel you can see the trace view of a single request and what happened in each step.
motia dev
Fault tolerance
With the rise of AI, many backend tasks have become less deterministic and more error-prone. These scenarios require robust error handling and retry mechanisms. In traditional systems, developers often need to set up and maintain queue infrastructures to ensure resilience, especially when dealing with unreliable responses from LLMs.
Motia provides fault tolerance out of the box, eliminating the need to manually spin up queue infrastructure.
Using Event Steps, you get retry mechanisms out of the box
Configuration of queue infrastructure is abstracted away
Building and Shipping
Building and deploying backends is inherently complex—especially in polyglot environments. Shipping production systems requires tight collaboration between developers and operations, and automation often takes weeks to get right.
Beyond that, cloud provider lock-in, complicated deployment strategies (e.g., rollbacks, blue/green deployments), and a lack of deployment tooling increase the risk of failure.
Motia abstracts these concerns by providing:
True cloud-provider agnosticism
Atomic blue/green deployments and one-click rollbacks via Motia Cloud (canary support coming soon)
First-class polyglot backend support (currently Node.js and Python, with more on the way)
The image above shows several Steps being build to a single Motia deployable that are ultimately deployed to a cloud provider of your choice.
Currently we're supporting AWS and Kubernetes, more Cloud providers coming soon. Check ourroadmapfor more details.
Rollbacks and deployment strategies
Deploying cloud-native, fault-tolerant applications often involves modifying queue systems and other infrastructure components.
These changes can introduce incompatibilities and lead to runtime failures.
Motia Cloud solves this withAtomic Deployments, which:
Each deployment spins up a new isolated service that shares the same data layer
Ensures safe, rollback-capable deployments without risking service downtime
Instant rollbacks with one click since each deployment is isolated
Real-time data streaming
Handling real-time data is one of the most common—and complex—challenges in backend development. It's necessary when building event-driven applications,
and it typically requires setting up and maintaining a significant amount of infrastructure.
Motia provides what we callStreams: Developers define the structure of the data—any changes to these objects are streamed to all subscribed clients in real-time.
The image above shows a Stream definition, a Node.js Step mutating the data and a client subscribing to the stream receiving real-time updates.
Quick Start
Get up and running with a new Motia project in just a few seconds.
On this page



===== https://www.motia.dev/docs/getting-started/quick-start =====

Quick Start
Get up and running with a new Motia project in just a few seconds.
1. Create Your Project
Usenpxto create a new Motia project. This single command will scaffold a new application and install all necessary dependencies.
npx
npxmotia@latestcreate
npxmotia@latestcreate
The installer will guide you through a few questions to set up your project. Once it's done, you will have a new project directory ready to go.
2. Start the Development Server
Navigate into your new project directory and start the Motia development server.
cd<your-project-name># If you've created a new folder for the project, navigate into itnpxmotiadev
cd<your-project-name># If you've created a new folder for the project, navigate into itnpxmotiadev
Thecreatecommand usesnpmby default. If you chose a different package manager during setup, usepnpm dev,yarn dev, orbun dev.
create
npm
pnpm dev
yarn dev
bun dev
This command starts the Motia runtime and the Workbench, a powerful UI for developing and debugging your workflows. By default, it's available athttp://localhost:3000.
http://localhost:3000
3. Run Your First Flow
The starter project comes with a pre-builtbasic-tutorialflow. Let's run it.
basic-tutorial
Open the Workbenchin your browser athttp://localhost:3000.
http://localhost:3000
Click theTutorialbutton on the top right of the workbench.
Tutorial
Complete theTutorialto get an understanding of the basics of Motia and using the Workbench.
Tutorial
Next Steps
Congratulations! You've successfully ran, and observed your first Motia workflow.
Build your first application from scratch, follow ourBuild Your First Motia Appguide.
To learn about Motia, dive into ourCore Concepts.
Welcome to Motia
Motia is a multi-language, event-driven runtime manager built on a core primitive: the Step. It feels like a backend framework, but powers distributed backends for APIs, background jobs, queues, workflows, agents, streaming, state, and observability, all unified in one system.
Build Your First Motia App
Learn Motia step-by-step by building a real pet store backend
On this page



===== https://www.motia.dev/docs =====

Welcome to Motia
Motia is a multi-language, event-driven runtime manager built on a core primitive: the Step. It feels like a backend framework, but powers distributed backends for APIs, background jobs, queues, workflows, agents, streaming, state, and observability, all unified in one system.
Welcome to Motia
Why Motia?
Backend development today is fragmented.
APIs live in one framework, background jobs in another, queues and schedulers elsewhere, and now AI agents and streaming systems have their own runtimes. Add observability and state management on top, and you’re stitching together half a dozen tools before writing your first feature.
Motia unifies all of these concerns around one core primitive: the Step.
Just as React made frontend development simple by introducing components, Motia redefines backend development with Steps.
Every backend pattern, API endpoints, background jobs, queues, workflows, AI agents, streaming, observability, and state, is expressed with the same primitive.
To read more about this, check out ourmanifesto.
The Core Primitive: the Step
At the heart of Motia is a single primitive: theStep.
A Step is just a file with aconfigand ahandler. Motia auto-discovers these files from/stepsdirectory and connects them automatically.
config
handler
/steps
Here’s a simple example of two Steps working together: an API Step that emits an event, and an Event Step that processes it.
exportconstconfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
exportconstconfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
exportconstconfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler=async(input, {logger})=>{logger.info('Processing message', input);};
exportconstconfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you’ve built anAPI endpoint, aqueue, and aworker. No extra frameworks required.
Learn more about Steps here:What is a Step?.
Working with multiple Languages
The rapid advancement of AI has reshaped the software industry—many cutting-edge AI tools are available only in specific programming languages, this forces companies to decide if they either change their team's skillset to a different language or not leveraging these technologies at all.
Motia removes this limitation by allowing each Step to be written in any language, while still sharing a common state.
Each rectangle in the diagram above represents a Step, some of them are in TypeScript and others in Python.
Scalability
One of the biggest dilemmas in backend development is choosing between scalability and development velocity. In startup environments, speed often takes priority, resulting in systems that don't scale well and become problematic under increased load.
Motia addresses scalability by leveraging the core primitive ofSteps: Each step can scale independently avoiding the bottlenecks common in monolithic architectures.
Observability
Observability in traditional backends often demands significant engineering effort to implement logging, alerting, and tracing. Typically, these tools are only configured for cloud environments, local development is generally neglected—leading to low productivity and poor dev experience.
Motia offers a complete observability toolkit available in both cloud and local environments, including:
Logs visualization
Tracing tool to quickly visualize the flow of requests through the system
State visualization
Diagram representation of dependencies between steps and how they are connected
The image below shows the Workbench interface available when you runmotia dev. On the top panel you can see a workflow diagram with multiple steps connected.
On the bottom panel you can see the trace view of a single request and what happened in each step.
motia dev
Fault tolerance
With the rise of AI, many backend tasks have become less deterministic and more error-prone. These scenarios require robust error handling and retry mechanisms. In traditional systems, developers often need to set up and maintain queue infrastructures to ensure resilience, especially when dealing with unreliable responses from LLMs.
Motia provides fault tolerance out of the box, eliminating the need to manually spin up queue infrastructure.
Using Event Steps, you get retry mechanisms out of the box
Configuration of queue infrastructure is abstracted away
Building and Shipping
Building and deploying backends is inherently complex—especially in polyglot environments. Shipping production systems requires tight collaboration between developers and operations, and automation often takes weeks to get right.
Beyond that, cloud provider lock-in, complicated deployment strategies (e.g., rollbacks, blue/green deployments), and a lack of deployment tooling increase the risk of failure.
Motia abstracts these concerns by providing:
True cloud-provider agnosticism
Atomic blue/green deployments and one-click rollbacks via Motia Cloud (canary support coming soon)
First-class polyglot backend support (currently Node.js and Python, with more on the way)
The image above shows several Steps being build to a single Motia deployable that are ultimately deployed to a cloud provider of your choice.
Currently we're supporting AWS and Kubernetes, more Cloud providers coming soon. Check ourroadmapfor more details.
Rollbacks and deployment strategies
Deploying cloud-native, fault-tolerant applications often involves modifying queue systems and other infrastructure components.
These changes can introduce incompatibilities and lead to runtime failures.
Motia Cloud solves this withAtomic Deployments, which:
Each deployment spins up a new isolated service that shares the same data layer
Ensures safe, rollback-capable deployments without risking service downtime
Instant rollbacks with one click since each deployment is isolated
Real-time data streaming
Handling real-time data is one of the most common—and complex—challenges in backend development. It's necessary when building event-driven applications,
and it typically requires setting up and maintaining a significant amount of infrastructure.
Motia provides what we callStreams: Developers define the structure of the data—any changes to these objects are streamed to all subscribed clients in real-time.
The image above shows a Stream definition, a Node.js Step mutating the data and a client subscribing to the stream receiving real-time updates.
Quick Start
Get up and running with a new Motia project in just a few seconds.
On this page



===== https://www.motia.dev/docs/getting-started/quick-start =====

Quick Start
Get up and running with a new Motia project in just a few seconds.
1. Create Your Project
Usenpxto create a new Motia project. This single command will scaffold a new application and install all necessary dependencies.
npx
npxmotia@latestcreate
npxmotia@latestcreate
The installer will guide you through a few questions to set up your project. Once it's done, you will have a new project directory ready to go.
2. Start the Development Server
Navigate into your new project directory and start the Motia development server.
cd<your-project-name># If you've created a new folder for the project, navigate into itnpxmotiadev
cd<your-project-name># If you've created a new folder for the project, navigate into itnpxmotiadev
Thecreatecommand usesnpmby default. If you chose a different package manager during setup, usepnpm dev,yarn dev, orbun dev.
create
npm
pnpm dev
yarn dev
bun dev
This command starts the Motia runtime and the Workbench, a powerful UI for developing and debugging your workflows. By default, it's available athttp://localhost:3000.
http://localhost:3000
3. Run Your First Flow
The starter project comes with a pre-builtbasic-tutorialflow. Let's run it.
basic-tutorial
Open the Workbenchin your browser athttp://localhost:3000.
http://localhost:3000
Click theTutorialbutton on the top right of the workbench.
Tutorial
Complete theTutorialto get an understanding of the basics of Motia and using the Workbench.
Tutorial
Next Steps
Congratulations! You've successfully ran, and observed your first Motia workflow.
Build your first application from scratch, follow ourBuild Your First Motia Appguide.
To learn about Motia, dive into ourCore Concepts.
Welcome to Motia
Motia is a multi-language, event-driven runtime manager built on a core primitive: the Step. It feels like a backend framework, but powers distributed backends for APIs, background jobs, queues, workflows, agents, streaming, state, and observability, all unified in one system.
Build Your First Motia App
Learn Motia step-by-step by building a real pet store backend
On this page



===== https://www.motia.dev/docs/development-guide/cli#get-config =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#emit =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#generate =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#generate-step =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#generate-openapi =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#state =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#state-list =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#debugging =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#docker =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#docker-setup =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#docker-build =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#docker-run =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/development-guide/cli#next-steps =====

Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Command Line Interface (CLI)
Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.
Installation
The Motia CLI is automatically installed when you install themotiapackage. You can use it by runningnpx motiafollowed by the desired command.
motia
npx motia
Commands
create
create
Create a new Motia project.
npxmotia@latestcreate[options]
npxmotia@latestcreate[options]
Options:
-n, --name <project name>: The name for your project, used to create a directory. Use.or./to create it in the current directory.
-n, --name <project name>
.
./
build
build
Build your project, generating zip files for each step and creating a configuration file.
npxmotiabuild
npxmotiabuild
This command:
Compiles all your steps (both Node.js and Python)
Bundles each step into a zip file
Generates amotia.steps.jsonconfiguration file in thedistdirectory
motia.steps.json
dist
Organizes the output in thedistdirectory
dist
deploy
deploy
Deploy your built steps to the Motia deployment service.
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
Options:
-k, --api-key <key>(required): Your API key for authentication
-k, --api-key <key>
-n, --project-name <name>: Project name (used when creating a new project)
-n, --project-name <name>
-s, --environment-id <id>: Environment ID (can also be set via MOTIA_ENVIRONMENT_ID env var)
-s, --environment-id <id>
--environment-name <name>: Environment name (used when creating a new environment)
--environment-name <name>
-v, --version-name <version>(required): The version to deploy
-v, --version-name <version>
-d, --version-description <description>: The description of the version
-d, --version-description <description>
-e, --env-file <path>: Path to environment file
-e, --env-file <path>
Example:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3--environment-idenv-uuid
The deployment process:
Build your project
Uploads each zip file individually with its path information
Starts the deployment process on the server
dev
dev
Start the development server.
npxmotiadev[options]
npxmotiadev[options]
Options:
-p, --port <port>: The port to run the server on (default: 3000).
-p, --port <port>
-H, --host [host]: The host address for the server (default: localhost).
-H, --host [host]
-d, --debug: Enable debug logging.
-d, --debug
get-config
get-config
Get the generated config for your project.
npxmotiaget-config[options]
npxmotiaget-config[options]
Options:
-o, --output <path>: Path to write the generated config file.
-o, --output <path>
emit
emit
Emit an event to the Motia server.
npxmotiaemit[options]
npxmotiaemit[options]
Options:
--topic <topic>(required): Event topic/type to emit.
--topic <topic>
--message <message>(required): Event payload as a JSON string.
--message <message>
-p, --port <number>: Port number (default: 3000).
-p, --port <number>
generate
generate
Generate Motia resources.
generate step
Create a new step with interactive prompts.
npxmotiageneratestep[options]
npxmotiageneratestep[options]
Options:
-d, --dir <step file path>: The path relative to the steps directory to create the step file.
-d, --dir <step file path>
generate openapi
Generate OpenAPI spec for your project.
npxmotiagenerateopenapi[options]
npxmotiagenerateopenapi[options]
Options:
-t, --title <tile of the document>: Title for the OpenAPI document. Defaults to project name from package.json.
-t, --title <tile of the document>
-v, --version <version of the document>: Version of the OpenAPI document. Defaults to 1.0.0.
-v, --version <version of the document>
-o, --output <output file name / path>: The file name and path relative to root to create the openapi file. Defaults toopenapi.jsonat the root.
-o, --output <output file name / path>
openapi.json
state
state
Manage application state.
state list
List the current file state.
npxmotiastatelist
npxmotiastatelist
Debugging
You can enable debug logging by passing the-dor--debugflag to thedevcommand:
-d
--debug
dev
npxmotiadev--debug
npxmotiadev--debug
This will set theLOG_LEVELenvironment variable to'debug', providing more detailed logging output.
LOG_LEVEL
'debug'
docker
docker
Tools to help you setup your Motia project with docker and run it inside a container.
docker setup
Setup your Motia project for Docker
npxmotiadockersetup
npxmotiadockersetup
docker build
Build your Motia project Docker image
npxmotiadockerbuild
npxmotiadockerbuild
Options:
--project-name <project name>(required): The name of your project.
--project-name <project name>
docker run
Run your Motia project inside a container
npxmotiadockerrun
npxmotiadockerrun
Options:
--port <number>: Port number (default: 3000).
--port <number>
--project-name <project name>(required): The name of your project.
--project-name <project name>
--skip-build: Skip building the Docker image and used the last built image.
--skip-build
Next Steps
Explore theCore Conceptsto learn more about Steps, Flows, Events, and Topics.
Check out theExamplesfor common patterns and use cases.
Join ourCommunityfor help and discussions.
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Getting Started
Learn how to deploy your Motia project to production
On this page
create
build
deploy
dev
get-config
emit
generate
generate step
generate openapi
state
state list
docker
docker setup
docker build
docker run



===== https://www.motia.dev/docs/concepts =====





===== https://www.motia.dev/docs/deployment-guide/getting-started =====

Getting Started
Learn how to deploy your Motia project to production
When you're ready to deploy your Motia project to production, there are the two paths you can take:
Deploy with Motia
Deploy your Motia project to production using Motia.
Self-Hosted
Deploy your Motia project to production using motia-docker.
Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker



===== https://www.motia.dev/docs/deployment-guide/self-hosted =====

Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
We provide a docker image that you can use to deploy your Motia project to production. You can use it as a base image and add your own customizations or use it as is.
Quick setup
npxmotia@latestdockersetup
npxmotia@latestdockersetup
npxmotia@latestdockerrun
npxmotia@latestdockerrun
npxmotia@latestdockerrun--help
npxmotia@latestdockerrun--help
Reference theCLIfor more information on the docker commands.
Using the docker image
You will need to implement your own Dockerfile where you will use the motia-docker image as a base image. Use the following template as a starting point for your Dockerfile:
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
Depending on the cloud provider you will use to deploy your Motia project, you will need to adjust the exposed ports
and the command to start your application.
Create a .dockerignore file
Create a .dockerignore file in the root of your project to exclude files that are not needed in the docker image. You can use the following template as a starting point for your .dockerignore file:
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
Build your image
dockerbuild-t<your-image-name>.
dockerbuild-t<your-image-name>.
Run your Motia application
Once you've built your image, you can run it using the following command:
dockerrun-it--rm-p3000:3000<your-image-name>
dockerrun-it--rm-p3000:3000<your-image-name>
Motia Docker Resources
Docker Registry
Github Repo
Example Motia project with deployment boilerplate for AWS LightSail and Railway
Getting Started
Learn how to deploy your Motia project to production
Features
Learn how to deploy your Motia Project to a live environment
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/features =====

Features
Learn how to deploy your Motia Project to a live environment
Motia Cloud is the easiest way to deploy your Motia Project to a live environment.
Quickly deploy your project to a live environment with one click. Then confidently
roll up updates, roll back to a previous stable version, and scale your project with ease.
Manage multiple environments, visualize logs and traces, and keep your project running smoothly.
Real-time deployment status updates
You can see the deployment status in real-time in the Motia Cloud web interface
Deployment history
All recent deployments on your project are available in Motia Cloud UI. You can browse them
and promote them to be live in the environment.
Zero downtime deployments
Every deployment is an atomic deployment, this means that Motia Cloud creates a new infrastructure
with all the Message Queues system isolatedly for each deployment.
Why is this important?
No downtime deployments
Avoid backwards compatibility issues on message queues: Example, you can change a topic data structure
without worrying about breaking messages that are flowing during the deployment.
Instant rollbacks and roll up updates
With one button you can rollback to a previous deployment. This allows you to be confident
on deployments, if anything fails, quickly rollback to a previous stable version.
One-click deployment
Deploy your project from workbench to a live environment with one click.
Observability
Have the same experience you have with Workbench locally in cloud. Such as:
Logs visualization
Tracing tool
Logs visualization
You can see the logs of your project in the Motia Cloud web interface.
Tracing tool
Tracing tool to quickly visualize the flow of requests through the system.
Multiple environments support
Motia Cloud supports creating multiple environments for your projects.
Scalability
Horizontal scaling individually for each step
Retry mechanisms for event steps built-in (3 retries by default)
Learn how to deploy
Learn how to deploy your project to Motia Cloud in theDeploymentpage.
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
Deployment
Deploying your project to Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/deployment =====

Deployment
Deploying your project to Motia Cloud
There are two ways to deploy your project to Motia Cloud:
Using the CLI
Using the Web interface
Using the Motia CLI for Deployment
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
--api-key
-k
MOTIA_API_KEY
--version-name
-v
--environment-id
-s
MOTIA_ENVIRONMENT_ID
--version-description
-d
--env-file
-e
Note:Command-line options take precedence over environment variables. If both are provided, the command-line value will be used.
Deploy with a specific version:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
Deploy to a specific environment with environment variables:
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
Using Web interface
Through the web interface, you can deploy your project from workbench to a live environment with one click.
Steps to deploy from web interface:
Have your local project running (make sure your Motia version is 0.6.4 or higher)
Go to import from workbench on Motia Cloud
Select the port your local project is running on
Choose the project and environment name
Add any environment variables you need (you can upload from .env file or paste the content to auto-fill)
Click Deploy
Watch the magic happen
Adding static files to the bundle
Sometimes we need to use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Adding them to Steps as static files, you need to addincludeFilesto the step config. The path
should be relative to the step file.
includeFiles
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
Adding binary files to the bundle
Binary files are also supported, but the entire bundle size must not exceed 100MB.
The binary architecture should be linux_amd64.
Troubleshooting Build Outputs
When adding static files, it's important to check the build output to make sure the files are included.
For example, inthis project, there are a few steps that
include static files.
When runningnpx motia build, it will generate the following output indistfolder:
npx motia build
dist
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
If you check the content ofcontent-outliner.step.zip, it should have this
content-outliner.step.zip
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
Now you made sure the static file calledcontent-outliner.mustacheis included in the bundle.
content-outliner.mustache
Features
Learn how to deploy your Motia Project to a live environment
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/architecture =====

Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Bundle sizes
Motia Cloud currently has limited bundle sizes to 100MB, we're actively working on increasing this limit
to be higher than 1GB.
Payload size on events
When sending events to topics, the data should not have more than 4KB.
Make sure you're not sending files as Base64 in the content of the event.
Make sure payloads you send are not too large, prefer storing in state and fetch it on the other steps.
Using Local Files
Sometimes we need toa use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Make sure you follow the instructions inDeployments page.
Runtime timeouts
Motia Cloud currently has limited runtime timeouts:
15 minutes for Event and Cron Steps.
30 seconds for API Steps.
Reserved environment variables
Motia Cloud is currently deployed to Amazon Web Services. Which means that there are
some environment variables that are reserved for internal use. If you need to use one
of these variables, make sure to add a different name.
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
Limitations
100MB bundle size
4KB payload size on events
15 minutes runtime timeout for Event and Cron Steps
30 seconds runtime timeout for API Steps
Troubleshooting build outputs
Make sure you follow the instructions inDeployments page.
Deployment
Deploying your project to Motia Cloud
FAQ
Frequently asked questions about Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/faq =====

FAQ
Frequently asked questions about Motia Cloud
Can I deploy any Motia app to Motia Cloud?
Node.JS projects are fully supported. Python projects are supported as well but there are a few external libraries that are not currently supported, such as:
TensorFlow
Pytorch
These are not supported due to the limited bundle size of 100MB.
Be mindful that static or binary files added to the bundle must not exceed 100MB.
What happens when I deploy my project to Motia Cloud?
When you deploy for the first time, it's immediately available. But when you deploy
for the second time and beyond, the deployment is listed but needs to be manually promoted to be live.
Promoting a deployment is a really simple process and happens immediately after you click.
Check thePromotepage for more information.
I deployed a new version but it didn't update
It's because Motia Cloud doesn't automatically promote the new version to be live. You need to promote it manually.
Check thePromotepage for more information.
How do I deploy my project to Motia Cloud?
You can deploy your project to Motia Cloud by using the Motia CLI or through the web interface.
Check theDeploymentpage for more information.
How do I rollback to a previous deployment?
You can rollback to a previous deployment by clicking the rollback button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I promote a deployment to be live?
You can promote a deployment to be live by clicking the promote button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I delete a deployment?
You can delete a deployment by clicking the delete button in the Motia Cloud web interface.
How do I update environment variables?
Currently, the only way to update environment variables is by creating a new deployment.
The reason is that every deployment is an atomic deployment and Environment Variables can also be source of
issues.
This was a decision to make sure that deployments are always predictable and consistent. And rollbacks
can be done with confidence. If an environment variable updated caused an issue, you can quickly rollback to
a previous deployment.
How do I add static or binary files to my project?
You can add static files to your project by adding them to theincludeFilesproperty in the step config.
Check theDeploymentpage for more information.
includeFiles
Is it possible to deploy using GitHub Actions?
Yes, it's totally possible to deploy your project using GitHub Actions.
How much it cost?
We're still working on the pricing model, but it's going to be based on usage. You will pay for what you use.
How do I get support?
You can get support by creating an issue on ourGitHub repository.
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Continuous Deployment
Move faster with continuous deployment
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/continuous-deployment =====

Continuous Deployment
Move faster with continuous deployment
This guide helps creating a continuous deployment pipeline for your Motia project.
Before you start
Before you create your pipeline, you first need to have deployed your project to Motia Cloud.
Check theDeploymentpage for more information.
Adding the Environment ID
After you have deployed your project to Motia Cloud, you need to add the environment ID to your pipeline.
You can find the environment ID in the Motia Cloud web interface by navigating to the Environment page and
clicking on the Settings tab.
Creating an API Key
When you open Motia Cloud, you should see API Keys tab. Click on the Create API Key button to create a new API Key.
Copy the API Key and add it to your projectas a secret.
Do NOT paste the API Key content to your workflow file.
Populating Environment Variables
Add all environment variables you need on your project torepository secrets,
then make sure to updateCreate Env filesection in the workflow file.
Create Env file
Using GitHub Actions
You can use GitHub Actions to deploy your Motia project to Motia Cloud.
name:Deployon:push:branches:-mainworkflow_dispatch:inputs:versionName:description:'Version Name to deploy'required:trueversionDescription:description:'Version Description to deploy'required:trueenv:# Add your API Key as a Secret in your Repository (Do NOT add it here)# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secretsMOTIA_API_KEY:${{ secrets.MOTIA_API_KEY }}# Fill your environment ID hereMOTIA_ENV_ID:__FILL YOUR ENVIRONMENT ID HERE__jobs:deploy:name:Deployruns-on:ubuntu-lateststeps:-name:Checkout codeuses:actions/checkout@v4with:ref:${{ github.event.release.tag_name || github.ref }}-name:Set VERSION_NAME and DESCRIPTIONid:metarun:|if [ "${{ github.event_name }}" = "workflow_dispatch" ]; thenecho "VERSION_NAME=${{ github.event.inputs.versionName }}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.inputs.versionDescription }}" >> $GITHUB_ENVelseecho "VERSION_NAME=${GITHUB_SHA::7}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.head_commit.message }}" >> $GITHUB_ENVfi-name:Set up Pythonuses:actions/setup-python@v5with:python-version:'3.13'-name:Setup Node.jsuses:actions/setup-node@v4with:node-version:'22'cache:'npm'cache-dependency-path:'package-lock.json'-name:Install dependenciesrun:npm ci# Replace MY_SECRET with your secret# Add as many as you need# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets-name:Create Env filerun:|echo "MY_SECRET=${{ secrets.MY_SECRET }}" > .env-name:Deploy using Motia Cloudrun:|npx motia cloud deploy \--api-key ${{ env.MOTIA_API_KEY }} \--environment-id ${{ env.MOTIA_ENV_ID }} \--version-name "${{ env.VERSION_NAME }}" \--version-description "${{ env.VERSION_DESCRIPTION }}" \--env-file .env
name:Deployon:push:branches:-mainworkflow_dispatch:inputs:versionName:description:'Version Name to deploy'required:trueversionDescription:description:'Version Description to deploy'required:trueenv:# Add your API Key as a Secret in your Repository (Do NOT add it here)# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secretsMOTIA_API_KEY:${{ secrets.MOTIA_API_KEY }}# Fill your environment ID hereMOTIA_ENV_ID:__FILL YOUR ENVIRONMENT ID HERE__jobs:deploy:name:Deployruns-on:ubuntu-lateststeps:-name:Checkout codeuses:actions/checkout@v4with:ref:${{ github.event.release.tag_name || github.ref }}-name:Set VERSION_NAME and DESCRIPTIONid:metarun:|if [ "${{ github.event_name }}" = "workflow_dispatch" ]; thenecho "VERSION_NAME=${{ github.event.inputs.versionName }}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.inputs.versionDescription }}" >> $GITHUB_ENVelseecho "VERSION_NAME=${GITHUB_SHA::7}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.head_commit.message }}" >> $GITHUB_ENVfi-name:Set up Pythonuses:actions/setup-python@v5with:python-version:'3.13'-name:Setup Node.jsuses:actions/setup-node@v4with:node-version:'22'cache:'npm'cache-dependency-path:'package-lock.json'-name:Install dependenciesrun:npm ci# Replace MY_SECRET with your secret# Add as many as you need# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets-name:Create Env filerun:|echo "MY_SECRET=${{ secrets.MY_SECRET }}" > .env-name:Deploy using Motia Cloudrun:|npx motia cloud deploy \--api-key ${{ env.MOTIA_API_KEY }} \--environment-id ${{ env.MOTIA_ENV_ID }} \--version-name "${{ env.VERSION_NAME }}" \--version-description "${{ env.VERSION_DESCRIPTION }}" \--env-file .env
FAQ
Frequently asked questions about Motia Cloud
AI Development Guide
Guide for building Motia applications with AI coding tools
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/continuous-deployment#before-you-start =====

Continuous Deployment
Move faster with continuous deployment
This guide helps creating a continuous deployment pipeline for your Motia project.
Before you start
Before you create your pipeline, you first need to have deployed your project to Motia Cloud.
Check theDeploymentpage for more information.
Adding the Environment ID
After you have deployed your project to Motia Cloud, you need to add the environment ID to your pipeline.
You can find the environment ID in the Motia Cloud web interface by navigating to the Environment page and
clicking on the Settings tab.
Creating an API Key
When you open Motia Cloud, you should see API Keys tab. Click on the Create API Key button to create a new API Key.
Copy the API Key and add it to your projectas a secret.
Do NOT paste the API Key content to your workflow file.
Populating Environment Variables
Add all environment variables you need on your project torepository secrets,
then make sure to updateCreate Env filesection in the workflow file.
Create Env file
Using GitHub Actions
You can use GitHub Actions to deploy your Motia project to Motia Cloud.
name:Deployon:push:branches:-mainworkflow_dispatch:inputs:versionName:description:'Version Name to deploy'required:trueversionDescription:description:'Version Description to deploy'required:trueenv:# Add your API Key as a Secret in your Repository (Do NOT add it here)# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secretsMOTIA_API_KEY:${{ secrets.MOTIA_API_KEY }}# Fill your environment ID hereMOTIA_ENV_ID:__FILL YOUR ENVIRONMENT ID HERE__jobs:deploy:name:Deployruns-on:ubuntu-lateststeps:-name:Checkout codeuses:actions/checkout@v4with:ref:${{ github.event.release.tag_name || github.ref }}-name:Set VERSION_NAME and DESCRIPTIONid:metarun:|if [ "${{ github.event_name }}" = "workflow_dispatch" ]; thenecho "VERSION_NAME=${{ github.event.inputs.versionName }}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.inputs.versionDescription }}" >> $GITHUB_ENVelseecho "VERSION_NAME=${GITHUB_SHA::7}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.head_commit.message }}" >> $GITHUB_ENVfi-name:Set up Pythonuses:actions/setup-python@v5with:python-version:'3.13'-name:Setup Node.jsuses:actions/setup-node@v4with:node-version:'22'cache:'npm'cache-dependency-path:'package-lock.json'-name:Install dependenciesrun:npm ci# Replace MY_SECRET with your secret# Add as many as you need# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets-name:Create Env filerun:|echo "MY_SECRET=${{ secrets.MY_SECRET }}" > .env-name:Deploy using Motia Cloudrun:|npx motia cloud deploy \--api-key ${{ env.MOTIA_API_KEY }} \--environment-id ${{ env.MOTIA_ENV_ID }} \--version-name "${{ env.VERSION_NAME }}" \--version-description "${{ env.VERSION_DESCRIPTION }}" \--env-file .env
name:Deployon:push:branches:-mainworkflow_dispatch:inputs:versionName:description:'Version Name to deploy'required:trueversionDescription:description:'Version Description to deploy'required:trueenv:# Add your API Key as a Secret in your Repository (Do NOT add it here)# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secretsMOTIA_API_KEY:${{ secrets.MOTIA_API_KEY }}# Fill your environment ID hereMOTIA_ENV_ID:__FILL YOUR ENVIRONMENT ID HERE__jobs:deploy:name:Deployruns-on:ubuntu-lateststeps:-name:Checkout codeuses:actions/checkout@v4with:ref:${{ github.event.release.tag_name || github.ref }}-name:Set VERSION_NAME and DESCRIPTIONid:metarun:|if [ "${{ github.event_name }}" = "workflow_dispatch" ]; thenecho "VERSION_NAME=${{ github.event.inputs.versionName }}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.inputs.versionDescription }}" >> $GITHUB_ENVelseecho "VERSION_NAME=${GITHUB_SHA::7}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.head_commit.message }}" >> $GITHUB_ENVfi-name:Set up Pythonuses:actions/setup-python@v5with:python-version:'3.13'-name:Setup Node.jsuses:actions/setup-node@v4with:node-version:'22'cache:'npm'cache-dependency-path:'package-lock.json'-name:Install dependenciesrun:npm ci# Replace MY_SECRET with your secret# Add as many as you need# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets-name:Create Env filerun:|echo "MY_SECRET=${{ secrets.MY_SECRET }}" > .env-name:Deploy using Motia Cloudrun:|npx motia cloud deploy \--api-key ${{ env.MOTIA_API_KEY }} \--environment-id ${{ env.MOTIA_ENV_ID }} \--version-name "${{ env.VERSION_NAME }}" \--version-description "${{ env.VERSION_DESCRIPTION }}" \--env-file .env
FAQ
Frequently asked questions about Motia Cloud
AI Development Guide
Guide for building Motia applications with AI coding tools
On this page



===== https://www.motia.dev/docs/concepts/deployment/motia-cloud/deployment =====





===== https://www.motia.dev/docs/deployment-guide/motia-cloud/continuous-deployment#adding-the-environment-id =====

Continuous Deployment
Move faster with continuous deployment
This guide helps creating a continuous deployment pipeline for your Motia project.
Before you start
Before you create your pipeline, you first need to have deployed your project to Motia Cloud.
Check theDeploymentpage for more information.
Adding the Environment ID
After you have deployed your project to Motia Cloud, you need to add the environment ID to your pipeline.
You can find the environment ID in the Motia Cloud web interface by navigating to the Environment page and
clicking on the Settings tab.
Creating an API Key
When you open Motia Cloud, you should see API Keys tab. Click on the Create API Key button to create a new API Key.
Copy the API Key and add it to your projectas a secret.
Do NOT paste the API Key content to your workflow file.
Populating Environment Variables
Add all environment variables you need on your project torepository secrets,
then make sure to updateCreate Env filesection in the workflow file.
Create Env file
Using GitHub Actions
You can use GitHub Actions to deploy your Motia project to Motia Cloud.
name:Deployon:push:branches:-mainworkflow_dispatch:inputs:versionName:description:'Version Name to deploy'required:trueversionDescription:description:'Version Description to deploy'required:trueenv:# Add your API Key as a Secret in your Repository (Do NOT add it here)# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secretsMOTIA_API_KEY:${{ secrets.MOTIA_API_KEY }}# Fill your environment ID hereMOTIA_ENV_ID:__FILL YOUR ENVIRONMENT ID HERE__jobs:deploy:name:Deployruns-on:ubuntu-lateststeps:-name:Checkout codeuses:actions/checkout@v4with:ref:${{ github.event.release.tag_name || github.ref }}-name:Set VERSION_NAME and DESCRIPTIONid:metarun:|if [ "${{ github.event_name }}" = "workflow_dispatch" ]; thenecho "VERSION_NAME=${{ github.event.inputs.versionName }}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.inputs.versionDescription }}" >> $GITHUB_ENVelseecho "VERSION_NAME=${GITHUB_SHA::7}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.head_commit.message }}" >> $GITHUB_ENVfi-name:Set up Pythonuses:actions/setup-python@v5with:python-version:'3.13'-name:Setup Node.jsuses:actions/setup-node@v4with:node-version:'22'cache:'npm'cache-dependency-path:'package-lock.json'-name:Install dependenciesrun:npm ci# Replace MY_SECRET with your secret# Add as many as you need# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets-name:Create Env filerun:|echo "MY_SECRET=${{ secrets.MY_SECRET }}" > .env-name:Deploy using Motia Cloudrun:|npx motia cloud deploy \--api-key ${{ env.MOTIA_API_KEY }} \--environment-id ${{ env.MOTIA_ENV_ID }} \--version-name "${{ env.VERSION_NAME }}" \--version-description "${{ env.VERSION_DESCRIPTION }}" \--env-file .env
name:Deployon:push:branches:-mainworkflow_dispatch:inputs:versionName:description:'Version Name to deploy'required:trueversionDescription:description:'Version Description to deploy'required:trueenv:# Add your API Key as a Secret in your Repository (Do NOT add it here)# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secretsMOTIA_API_KEY:${{ secrets.MOTIA_API_KEY }}# Fill your environment ID hereMOTIA_ENV_ID:__FILL YOUR ENVIRONMENT ID HERE__jobs:deploy:name:Deployruns-on:ubuntu-lateststeps:-name:Checkout codeuses:actions/checkout@v4with:ref:${{ github.event.release.tag_name || github.ref }}-name:Set VERSION_NAME and DESCRIPTIONid:metarun:|if [ "${{ github.event_name }}" = "workflow_dispatch" ]; thenecho "VERSION_NAME=${{ github.event.inputs.versionName }}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.inputs.versionDescription }}" >> $GITHUB_ENVelseecho "VERSION_NAME=${GITHUB_SHA::7}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.head_commit.message }}" >> $GITHUB_ENVfi-name:Set up Pythonuses:actions/setup-python@v5with:python-version:'3.13'-name:Setup Node.jsuses:actions/setup-node@v4with:node-version:'22'cache:'npm'cache-dependency-path:'package-lock.json'-name:Install dependenciesrun:npm ci# Replace MY_SECRET with your secret# Add as many as you need# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets-name:Create Env filerun:|echo "MY_SECRET=${{ secrets.MY_SECRET }}" > .env-name:Deploy using Motia Cloudrun:|npx motia cloud deploy \--api-key ${{ env.MOTIA_API_KEY }} \--environment-id ${{ env.MOTIA_ENV_ID }} \--version-name "${{ env.VERSION_NAME }}" \--version-description "${{ env.VERSION_DESCRIPTION }}" \--env-file .env
FAQ
Frequently asked questions about Motia Cloud
AI Development Guide
Guide for building Motia applications with AI coding tools
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/continuous-deployment#creating-an-api-key =====

Continuous Deployment
Move faster with continuous deployment
This guide helps creating a continuous deployment pipeline for your Motia project.
Before you start
Before you create your pipeline, you first need to have deployed your project to Motia Cloud.
Check theDeploymentpage for more information.
Adding the Environment ID
After you have deployed your project to Motia Cloud, you need to add the environment ID to your pipeline.
You can find the environment ID in the Motia Cloud web interface by navigating to the Environment page and
clicking on the Settings tab.
Creating an API Key
When you open Motia Cloud, you should see API Keys tab. Click on the Create API Key button to create a new API Key.
Copy the API Key and add it to your projectas a secret.
Do NOT paste the API Key content to your workflow file.
Populating Environment Variables
Add all environment variables you need on your project torepository secrets,
then make sure to updateCreate Env filesection in the workflow file.
Create Env file
Using GitHub Actions
You can use GitHub Actions to deploy your Motia project to Motia Cloud.
name:Deployon:push:branches:-mainworkflow_dispatch:inputs:versionName:description:'Version Name to deploy'required:trueversionDescription:description:'Version Description to deploy'required:trueenv:# Add your API Key as a Secret in your Repository (Do NOT add it here)# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secretsMOTIA_API_KEY:${{ secrets.MOTIA_API_KEY }}# Fill your environment ID hereMOTIA_ENV_ID:__FILL YOUR ENVIRONMENT ID HERE__jobs:deploy:name:Deployruns-on:ubuntu-lateststeps:-name:Checkout codeuses:actions/checkout@v4with:ref:${{ github.event.release.tag_name || github.ref }}-name:Set VERSION_NAME and DESCRIPTIONid:metarun:|if [ "${{ github.event_name }}" = "workflow_dispatch" ]; thenecho "VERSION_NAME=${{ github.event.inputs.versionName }}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.inputs.versionDescription }}" >> $GITHUB_ENVelseecho "VERSION_NAME=${GITHUB_SHA::7}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.head_commit.message }}" >> $GITHUB_ENVfi-name:Set up Pythonuses:actions/setup-python@v5with:python-version:'3.13'-name:Setup Node.jsuses:actions/setup-node@v4with:node-version:'22'cache:'npm'cache-dependency-path:'package-lock.json'-name:Install dependenciesrun:npm ci# Replace MY_SECRET with your secret# Add as many as you need# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets-name:Create Env filerun:|echo "MY_SECRET=${{ secrets.MY_SECRET }}" > .env-name:Deploy using Motia Cloudrun:|npx motia cloud deploy \--api-key ${{ env.MOTIA_API_KEY }} \--environment-id ${{ env.MOTIA_ENV_ID }} \--version-name "${{ env.VERSION_NAME }}" \--version-description "${{ env.VERSION_DESCRIPTION }}" \--env-file .env
name:Deployon:push:branches:-mainworkflow_dispatch:inputs:versionName:description:'Version Name to deploy'required:trueversionDescription:description:'Version Description to deploy'required:trueenv:# Add your API Key as a Secret in your Repository (Do NOT add it here)# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secretsMOTIA_API_KEY:${{ secrets.MOTIA_API_KEY }}# Fill your environment ID hereMOTIA_ENV_ID:__FILL YOUR ENVIRONMENT ID HERE__jobs:deploy:name:Deployruns-on:ubuntu-lateststeps:-name:Checkout codeuses:actions/checkout@v4with:ref:${{ github.event.release.tag_name || github.ref }}-name:Set VERSION_NAME and DESCRIPTIONid:metarun:|if [ "${{ github.event_name }}" = "workflow_dispatch" ]; thenecho "VERSION_NAME=${{ github.event.inputs.versionName }}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.inputs.versionDescription }}" >> $GITHUB_ENVelseecho "VERSION_NAME=${GITHUB_SHA::7}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.head_commit.message }}" >> $GITHUB_ENVfi-name:Set up Pythonuses:actions/setup-python@v5with:python-version:'3.13'-name:Setup Node.jsuses:actions/setup-node@v4with:node-version:'22'cache:'npm'cache-dependency-path:'package-lock.json'-name:Install dependenciesrun:npm ci# Replace MY_SECRET with your secret# Add as many as you need# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets-name:Create Env filerun:|echo "MY_SECRET=${{ secrets.MY_SECRET }}" > .env-name:Deploy using Motia Cloudrun:|npx motia cloud deploy \--api-key ${{ env.MOTIA_API_KEY }} \--environment-id ${{ env.MOTIA_ENV_ID }} \--version-name "${{ env.VERSION_NAME }}" \--version-description "${{ env.VERSION_DESCRIPTION }}" \--env-file .env
FAQ
Frequently asked questions about Motia Cloud
AI Development Guide
Guide for building Motia applications with AI coding tools
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/continuous-deployment#populating-environment-variables =====

Continuous Deployment
Move faster with continuous deployment
This guide helps creating a continuous deployment pipeline for your Motia project.
Before you start
Before you create your pipeline, you first need to have deployed your project to Motia Cloud.
Check theDeploymentpage for more information.
Adding the Environment ID
After you have deployed your project to Motia Cloud, you need to add the environment ID to your pipeline.
You can find the environment ID in the Motia Cloud web interface by navigating to the Environment page and
clicking on the Settings tab.
Creating an API Key
When you open Motia Cloud, you should see API Keys tab. Click on the Create API Key button to create a new API Key.
Copy the API Key and add it to your projectas a secret.
Do NOT paste the API Key content to your workflow file.
Populating Environment Variables
Add all environment variables you need on your project torepository secrets,
then make sure to updateCreate Env filesection in the workflow file.
Create Env file
Using GitHub Actions
You can use GitHub Actions to deploy your Motia project to Motia Cloud.
name:Deployon:push:branches:-mainworkflow_dispatch:inputs:versionName:description:'Version Name to deploy'required:trueversionDescription:description:'Version Description to deploy'required:trueenv:# Add your API Key as a Secret in your Repository (Do NOT add it here)# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secretsMOTIA_API_KEY:${{ secrets.MOTIA_API_KEY }}# Fill your environment ID hereMOTIA_ENV_ID:__FILL YOUR ENVIRONMENT ID HERE__jobs:deploy:name:Deployruns-on:ubuntu-lateststeps:-name:Checkout codeuses:actions/checkout@v4with:ref:${{ github.event.release.tag_name || github.ref }}-name:Set VERSION_NAME and DESCRIPTIONid:metarun:|if [ "${{ github.event_name }}" = "workflow_dispatch" ]; thenecho "VERSION_NAME=${{ github.event.inputs.versionName }}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.inputs.versionDescription }}" >> $GITHUB_ENVelseecho "VERSION_NAME=${GITHUB_SHA::7}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.head_commit.message }}" >> $GITHUB_ENVfi-name:Set up Pythonuses:actions/setup-python@v5with:python-version:'3.13'-name:Setup Node.jsuses:actions/setup-node@v4with:node-version:'22'cache:'npm'cache-dependency-path:'package-lock.json'-name:Install dependenciesrun:npm ci# Replace MY_SECRET with your secret# Add as many as you need# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets-name:Create Env filerun:|echo "MY_SECRET=${{ secrets.MY_SECRET }}" > .env-name:Deploy using Motia Cloudrun:|npx motia cloud deploy \--api-key ${{ env.MOTIA_API_KEY }} \--environment-id ${{ env.MOTIA_ENV_ID }} \--version-name "${{ env.VERSION_NAME }}" \--version-description "${{ env.VERSION_DESCRIPTION }}" \--env-file .env
name:Deployon:push:branches:-mainworkflow_dispatch:inputs:versionName:description:'Version Name to deploy'required:trueversionDescription:description:'Version Description to deploy'required:trueenv:# Add your API Key as a Secret in your Repository (Do NOT add it here)# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secretsMOTIA_API_KEY:${{ secrets.MOTIA_API_KEY }}# Fill your environment ID hereMOTIA_ENV_ID:__FILL YOUR ENVIRONMENT ID HERE__jobs:deploy:name:Deployruns-on:ubuntu-lateststeps:-name:Checkout codeuses:actions/checkout@v4with:ref:${{ github.event.release.tag_name || github.ref }}-name:Set VERSION_NAME and DESCRIPTIONid:metarun:|if [ "${{ github.event_name }}" = "workflow_dispatch" ]; thenecho "VERSION_NAME=${{ github.event.inputs.versionName }}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.inputs.versionDescription }}" >> $GITHUB_ENVelseecho "VERSION_NAME=${GITHUB_SHA::7}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.head_commit.message }}" >> $GITHUB_ENVfi-name:Set up Pythonuses:actions/setup-python@v5with:python-version:'3.13'-name:Setup Node.jsuses:actions/setup-node@v4with:node-version:'22'cache:'npm'cache-dependency-path:'package-lock.json'-name:Install dependenciesrun:npm ci# Replace MY_SECRET with your secret# Add as many as you need# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets-name:Create Env filerun:|echo "MY_SECRET=${{ secrets.MY_SECRET }}" > .env-name:Deploy using Motia Cloudrun:|npx motia cloud deploy \--api-key ${{ env.MOTIA_API_KEY }} \--environment-id ${{ env.MOTIA_ENV_ID }} \--version-name "${{ env.VERSION_NAME }}" \--version-description "${{ env.VERSION_DESCRIPTION }}" \--env-file .env
FAQ
Frequently asked questions about Motia Cloud
AI Development Guide
Guide for building Motia applications with AI coding tools
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/continuous-deployment#using-github-actions =====

Continuous Deployment
Move faster with continuous deployment
This guide helps creating a continuous deployment pipeline for your Motia project.
Before you start
Before you create your pipeline, you first need to have deployed your project to Motia Cloud.
Check theDeploymentpage for more information.
Adding the Environment ID
After you have deployed your project to Motia Cloud, you need to add the environment ID to your pipeline.
You can find the environment ID in the Motia Cloud web interface by navigating to the Environment page and
clicking on the Settings tab.
Creating an API Key
When you open Motia Cloud, you should see API Keys tab. Click on the Create API Key button to create a new API Key.
Copy the API Key and add it to your projectas a secret.
Do NOT paste the API Key content to your workflow file.
Populating Environment Variables
Add all environment variables you need on your project torepository secrets,
then make sure to updateCreate Env filesection in the workflow file.
Create Env file
Using GitHub Actions
You can use GitHub Actions to deploy your Motia project to Motia Cloud.
name:Deployon:push:branches:-mainworkflow_dispatch:inputs:versionName:description:'Version Name to deploy'required:trueversionDescription:description:'Version Description to deploy'required:trueenv:# Add your API Key as a Secret in your Repository (Do NOT add it here)# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secretsMOTIA_API_KEY:${{ secrets.MOTIA_API_KEY }}# Fill your environment ID hereMOTIA_ENV_ID:__FILL YOUR ENVIRONMENT ID HERE__jobs:deploy:name:Deployruns-on:ubuntu-lateststeps:-name:Checkout codeuses:actions/checkout@v4with:ref:${{ github.event.release.tag_name || github.ref }}-name:Set VERSION_NAME and DESCRIPTIONid:metarun:|if [ "${{ github.event_name }}" = "workflow_dispatch" ]; thenecho "VERSION_NAME=${{ github.event.inputs.versionName }}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.inputs.versionDescription }}" >> $GITHUB_ENVelseecho "VERSION_NAME=${GITHUB_SHA::7}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.head_commit.message }}" >> $GITHUB_ENVfi-name:Set up Pythonuses:actions/setup-python@v5with:python-version:'3.13'-name:Setup Node.jsuses:actions/setup-node@v4with:node-version:'22'cache:'npm'cache-dependency-path:'package-lock.json'-name:Install dependenciesrun:npm ci# Replace MY_SECRET with your secret# Add as many as you need# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets-name:Create Env filerun:|echo "MY_SECRET=${{ secrets.MY_SECRET }}" > .env-name:Deploy using Motia Cloudrun:|npx motia cloud deploy \--api-key ${{ env.MOTIA_API_KEY }} \--environment-id ${{ env.MOTIA_ENV_ID }} \--version-name "${{ env.VERSION_NAME }}" \--version-description "${{ env.VERSION_DESCRIPTION }}" \--env-file .env
name:Deployon:push:branches:-mainworkflow_dispatch:inputs:versionName:description:'Version Name to deploy'required:trueversionDescription:description:'Version Description to deploy'required:trueenv:# Add your API Key as a Secret in your Repository (Do NOT add it here)# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secretsMOTIA_API_KEY:${{ secrets.MOTIA_API_KEY }}# Fill your environment ID hereMOTIA_ENV_ID:__FILL YOUR ENVIRONMENT ID HERE__jobs:deploy:name:Deployruns-on:ubuntu-lateststeps:-name:Checkout codeuses:actions/checkout@v4with:ref:${{ github.event.release.tag_name || github.ref }}-name:Set VERSION_NAME and DESCRIPTIONid:metarun:|if [ "${{ github.event_name }}" = "workflow_dispatch" ]; thenecho "VERSION_NAME=${{ github.event.inputs.versionName }}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.inputs.versionDescription }}" >> $GITHUB_ENVelseecho "VERSION_NAME=${GITHUB_SHA::7}" >> $GITHUB_ENVecho "VERSION_DESCRIPTION=${{ github.event.head_commit.message }}" >> $GITHUB_ENVfi-name:Set up Pythonuses:actions/setup-python@v5with:python-version:'3.13'-name:Setup Node.jsuses:actions/setup-node@v4with:node-version:'22'cache:'npm'cache-dependency-path:'package-lock.json'-name:Install dependenciesrun:npm ci# Replace MY_SECRET with your secret# Add as many as you need# https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets-name:Create Env filerun:|echo "MY_SECRET=${{ secrets.MY_SECRET }}" > .env-name:Deploy using Motia Cloudrun:|npx motia cloud deploy \--api-key ${{ env.MOTIA_API_KEY }} \--environment-id ${{ env.MOTIA_ENV_ID }} \--version-name "${{ env.VERSION_NAME }}" \--version-description "${{ env.VERSION_DESCRIPTION }}" \--env-file .env
FAQ
Frequently asked questions about Motia Cloud
AI Development Guide
Guide for building Motia applications with AI coding tools
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/faq#can-i-deploy-any-motia-app-to-motia-cloud =====

FAQ
Frequently asked questions about Motia Cloud
Can I deploy any Motia app to Motia Cloud?
Node.JS projects are fully supported. Python projects are supported as well but there are a few external libraries that are not currently supported, such as:
TensorFlow
Pytorch
These are not supported due to the limited bundle size of 100MB.
Be mindful that static or binary files added to the bundle must not exceed 100MB.
What happens when I deploy my project to Motia Cloud?
When you deploy for the first time, it's immediately available. But when you deploy
for the second time and beyond, the deployment is listed but needs to be manually promoted to be live.
Promoting a deployment is a really simple process and happens immediately after you click.
Check thePromotepage for more information.
I deployed a new version but it didn't update
It's because Motia Cloud doesn't automatically promote the new version to be live. You need to promote it manually.
Check thePromotepage for more information.
How do I deploy my project to Motia Cloud?
You can deploy your project to Motia Cloud by using the Motia CLI or through the web interface.
Check theDeploymentpage for more information.
How do I rollback to a previous deployment?
You can rollback to a previous deployment by clicking the rollback button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I promote a deployment to be live?
You can promote a deployment to be live by clicking the promote button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I delete a deployment?
You can delete a deployment by clicking the delete button in the Motia Cloud web interface.
How do I update environment variables?
Currently, the only way to update environment variables is by creating a new deployment.
The reason is that every deployment is an atomic deployment and Environment Variables can also be source of
issues.
This was a decision to make sure that deployments are always predictable and consistent. And rollbacks
can be done with confidence. If an environment variable updated caused an issue, you can quickly rollback to
a previous deployment.
How do I add static or binary files to my project?
You can add static files to your project by adding them to theincludeFilesproperty in the step config.
Check theDeploymentpage for more information.
includeFiles
Is it possible to deploy using GitHub Actions?
Yes, it's totally possible to deploy your project using GitHub Actions.
How much it cost?
We're still working on the pricing model, but it's going to be based on usage. You will pay for what you use.
How do I get support?
You can get support by creating an issue on ourGitHub repository.
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Continuous Deployment
Move faster with continuous deployment
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/faq#what-happens-when-i-deploy-my-project-to-motia-cloud =====

FAQ
Frequently asked questions about Motia Cloud
Can I deploy any Motia app to Motia Cloud?
Node.JS projects are fully supported. Python projects are supported as well but there are a few external libraries that are not currently supported, such as:
TensorFlow
Pytorch
These are not supported due to the limited bundle size of 100MB.
Be mindful that static or binary files added to the bundle must not exceed 100MB.
What happens when I deploy my project to Motia Cloud?
When you deploy for the first time, it's immediately available. But when you deploy
for the second time and beyond, the deployment is listed but needs to be manually promoted to be live.
Promoting a deployment is a really simple process and happens immediately after you click.
Check thePromotepage for more information.
I deployed a new version but it didn't update
It's because Motia Cloud doesn't automatically promote the new version to be live. You need to promote it manually.
Check thePromotepage for more information.
How do I deploy my project to Motia Cloud?
You can deploy your project to Motia Cloud by using the Motia CLI or through the web interface.
Check theDeploymentpage for more information.
How do I rollback to a previous deployment?
You can rollback to a previous deployment by clicking the rollback button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I promote a deployment to be live?
You can promote a deployment to be live by clicking the promote button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I delete a deployment?
You can delete a deployment by clicking the delete button in the Motia Cloud web interface.
How do I update environment variables?
Currently, the only way to update environment variables is by creating a new deployment.
The reason is that every deployment is an atomic deployment and Environment Variables can also be source of
issues.
This was a decision to make sure that deployments are always predictable and consistent. And rollbacks
can be done with confidence. If an environment variable updated caused an issue, you can quickly rollback to
a previous deployment.
How do I add static or binary files to my project?
You can add static files to your project by adding them to theincludeFilesproperty in the step config.
Check theDeploymentpage for more information.
includeFiles
Is it possible to deploy using GitHub Actions?
Yes, it's totally possible to deploy your project using GitHub Actions.
How much it cost?
We're still working on the pricing model, but it's going to be based on usage. You will pay for what you use.
How do I get support?
You can get support by creating an issue on ourGitHub repository.
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Continuous Deployment
Move faster with continuous deployment
On this page



===== https://www.motia.dev/docs/concepts/deployment/motia-cloud/features#instant-rollbacks-and-roll-ups-updates =====





===== https://www.motia.dev/docs/deployment-guide/motia-cloud/faq#i-deployed-a-new-version-but-it-didnt-update =====

FAQ
Frequently asked questions about Motia Cloud
Can I deploy any Motia app to Motia Cloud?
Node.JS projects are fully supported. Python projects are supported as well but there are a few external libraries that are not currently supported, such as:
TensorFlow
Pytorch
These are not supported due to the limited bundle size of 100MB.
Be mindful that static or binary files added to the bundle must not exceed 100MB.
What happens when I deploy my project to Motia Cloud?
When you deploy for the first time, it's immediately available. But when you deploy
for the second time and beyond, the deployment is listed but needs to be manually promoted to be live.
Promoting a deployment is a really simple process and happens immediately after you click.
Check thePromotepage for more information.
I deployed a new version but it didn't update
It's because Motia Cloud doesn't automatically promote the new version to be live. You need to promote it manually.
Check thePromotepage for more information.
How do I deploy my project to Motia Cloud?
You can deploy your project to Motia Cloud by using the Motia CLI or through the web interface.
Check theDeploymentpage for more information.
How do I rollback to a previous deployment?
You can rollback to a previous deployment by clicking the rollback button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I promote a deployment to be live?
You can promote a deployment to be live by clicking the promote button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I delete a deployment?
You can delete a deployment by clicking the delete button in the Motia Cloud web interface.
How do I update environment variables?
Currently, the only way to update environment variables is by creating a new deployment.
The reason is that every deployment is an atomic deployment and Environment Variables can also be source of
issues.
This was a decision to make sure that deployments are always predictable and consistent. And rollbacks
can be done with confidence. If an environment variable updated caused an issue, you can quickly rollback to
a previous deployment.
How do I add static or binary files to my project?
You can add static files to your project by adding them to theincludeFilesproperty in the step config.
Check theDeploymentpage for more information.
includeFiles
Is it possible to deploy using GitHub Actions?
Yes, it's totally possible to deploy your project using GitHub Actions.
How much it cost?
We're still working on the pricing model, but it's going to be based on usage. You will pay for what you use.
How do I get support?
You can get support by creating an issue on ourGitHub repository.
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Continuous Deployment
Move faster with continuous deployment
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/faq#how-do-i-deploy-my-project-to-motia-cloud =====

FAQ
Frequently asked questions about Motia Cloud
Can I deploy any Motia app to Motia Cloud?
Node.JS projects are fully supported. Python projects are supported as well but there are a few external libraries that are not currently supported, such as:
TensorFlow
Pytorch
These are not supported due to the limited bundle size of 100MB.
Be mindful that static or binary files added to the bundle must not exceed 100MB.
What happens when I deploy my project to Motia Cloud?
When you deploy for the first time, it's immediately available. But when you deploy
for the second time and beyond, the deployment is listed but needs to be manually promoted to be live.
Promoting a deployment is a really simple process and happens immediately after you click.
Check thePromotepage for more information.
I deployed a new version but it didn't update
It's because Motia Cloud doesn't automatically promote the new version to be live. You need to promote it manually.
Check thePromotepage for more information.
How do I deploy my project to Motia Cloud?
You can deploy your project to Motia Cloud by using the Motia CLI or through the web interface.
Check theDeploymentpage for more information.
How do I rollback to a previous deployment?
You can rollback to a previous deployment by clicking the rollback button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I promote a deployment to be live?
You can promote a deployment to be live by clicking the promote button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I delete a deployment?
You can delete a deployment by clicking the delete button in the Motia Cloud web interface.
How do I update environment variables?
Currently, the only way to update environment variables is by creating a new deployment.
The reason is that every deployment is an atomic deployment and Environment Variables can also be source of
issues.
This was a decision to make sure that deployments are always predictable and consistent. And rollbacks
can be done with confidence. If an environment variable updated caused an issue, you can quickly rollback to
a previous deployment.
How do I add static or binary files to my project?
You can add static files to your project by adding them to theincludeFilesproperty in the step config.
Check theDeploymentpage for more information.
includeFiles
Is it possible to deploy using GitHub Actions?
Yes, it's totally possible to deploy your project using GitHub Actions.
How much it cost?
We're still working on the pricing model, but it's going to be based on usage. You will pay for what you use.
How do I get support?
You can get support by creating an issue on ourGitHub repository.
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Continuous Deployment
Move faster with continuous deployment
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/faq#how-do-i-rollback-to-a-previous-deployment =====

FAQ
Frequently asked questions about Motia Cloud
Can I deploy any Motia app to Motia Cloud?
Node.JS projects are fully supported. Python projects are supported as well but there are a few external libraries that are not currently supported, such as:
TensorFlow
Pytorch
These are not supported due to the limited bundle size of 100MB.
Be mindful that static or binary files added to the bundle must not exceed 100MB.
What happens when I deploy my project to Motia Cloud?
When you deploy for the first time, it's immediately available. But when you deploy
for the second time and beyond, the deployment is listed but needs to be manually promoted to be live.
Promoting a deployment is a really simple process and happens immediately after you click.
Check thePromotepage for more information.
I deployed a new version but it didn't update
It's because Motia Cloud doesn't automatically promote the new version to be live. You need to promote it manually.
Check thePromotepage for more information.
How do I deploy my project to Motia Cloud?
You can deploy your project to Motia Cloud by using the Motia CLI or through the web interface.
Check theDeploymentpage for more information.
How do I rollback to a previous deployment?
You can rollback to a previous deployment by clicking the rollback button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I promote a deployment to be live?
You can promote a deployment to be live by clicking the promote button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I delete a deployment?
You can delete a deployment by clicking the delete button in the Motia Cloud web interface.
How do I update environment variables?
Currently, the only way to update environment variables is by creating a new deployment.
The reason is that every deployment is an atomic deployment and Environment Variables can also be source of
issues.
This was a decision to make sure that deployments are always predictable and consistent. And rollbacks
can be done with confidence. If an environment variable updated caused an issue, you can quickly rollback to
a previous deployment.
How do I add static or binary files to my project?
You can add static files to your project by adding them to theincludeFilesproperty in the step config.
Check theDeploymentpage for more information.
includeFiles
Is it possible to deploy using GitHub Actions?
Yes, it's totally possible to deploy your project using GitHub Actions.
How much it cost?
We're still working on the pricing model, but it's going to be based on usage. You will pay for what you use.
How do I get support?
You can get support by creating an issue on ourGitHub repository.
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Continuous Deployment
Move faster with continuous deployment
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/faq#how-do-i-promote-a-deployment-to-be-live =====

FAQ
Frequently asked questions about Motia Cloud
Can I deploy any Motia app to Motia Cloud?
Node.JS projects are fully supported. Python projects are supported as well but there are a few external libraries that are not currently supported, such as:
TensorFlow
Pytorch
These are not supported due to the limited bundle size of 100MB.
Be mindful that static or binary files added to the bundle must not exceed 100MB.
What happens when I deploy my project to Motia Cloud?
When you deploy for the first time, it's immediately available. But when you deploy
for the second time and beyond, the deployment is listed but needs to be manually promoted to be live.
Promoting a deployment is a really simple process and happens immediately after you click.
Check thePromotepage for more information.
I deployed a new version but it didn't update
It's because Motia Cloud doesn't automatically promote the new version to be live. You need to promote it manually.
Check thePromotepage for more information.
How do I deploy my project to Motia Cloud?
You can deploy your project to Motia Cloud by using the Motia CLI or through the web interface.
Check theDeploymentpage for more information.
How do I rollback to a previous deployment?
You can rollback to a previous deployment by clicking the rollback button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I promote a deployment to be live?
You can promote a deployment to be live by clicking the promote button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I delete a deployment?
You can delete a deployment by clicking the delete button in the Motia Cloud web interface.
How do I update environment variables?
Currently, the only way to update environment variables is by creating a new deployment.
The reason is that every deployment is an atomic deployment and Environment Variables can also be source of
issues.
This was a decision to make sure that deployments are always predictable and consistent. And rollbacks
can be done with confidence. If an environment variable updated caused an issue, you can quickly rollback to
a previous deployment.
How do I add static or binary files to my project?
You can add static files to your project by adding them to theincludeFilesproperty in the step config.
Check theDeploymentpage for more information.
includeFiles
Is it possible to deploy using GitHub Actions?
Yes, it's totally possible to deploy your project using GitHub Actions.
How much it cost?
We're still working on the pricing model, but it's going to be based on usage. You will pay for what you use.
How do I get support?
You can get support by creating an issue on ourGitHub repository.
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Continuous Deployment
Move faster with continuous deployment
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/faq#how-do-i-delete-a-deployment =====

FAQ
Frequently asked questions about Motia Cloud
Can I deploy any Motia app to Motia Cloud?
Node.JS projects are fully supported. Python projects are supported as well but there are a few external libraries that are not currently supported, such as:
TensorFlow
Pytorch
These are not supported due to the limited bundle size of 100MB.
Be mindful that static or binary files added to the bundle must not exceed 100MB.
What happens when I deploy my project to Motia Cloud?
When you deploy for the first time, it's immediately available. But when you deploy
for the second time and beyond, the deployment is listed but needs to be manually promoted to be live.
Promoting a deployment is a really simple process and happens immediately after you click.
Check thePromotepage for more information.
I deployed a new version but it didn't update
It's because Motia Cloud doesn't automatically promote the new version to be live. You need to promote it manually.
Check thePromotepage for more information.
How do I deploy my project to Motia Cloud?
You can deploy your project to Motia Cloud by using the Motia CLI or through the web interface.
Check theDeploymentpage for more information.
How do I rollback to a previous deployment?
You can rollback to a previous deployment by clicking the rollback button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I promote a deployment to be live?
You can promote a deployment to be live by clicking the promote button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I delete a deployment?
You can delete a deployment by clicking the delete button in the Motia Cloud web interface.
How do I update environment variables?
Currently, the only way to update environment variables is by creating a new deployment.
The reason is that every deployment is an atomic deployment and Environment Variables can also be source of
issues.
This was a decision to make sure that deployments are always predictable and consistent. And rollbacks
can be done with confidence. If an environment variable updated caused an issue, you can quickly rollback to
a previous deployment.
How do I add static or binary files to my project?
You can add static files to your project by adding them to theincludeFilesproperty in the step config.
Check theDeploymentpage for more information.
includeFiles
Is it possible to deploy using GitHub Actions?
Yes, it's totally possible to deploy your project using GitHub Actions.
How much it cost?
We're still working on the pricing model, but it's going to be based on usage. You will pay for what you use.
How do I get support?
You can get support by creating an issue on ourGitHub repository.
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Continuous Deployment
Move faster with continuous deployment
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/faq#how-do-i-update-environment-variables =====

FAQ
Frequently asked questions about Motia Cloud
Can I deploy any Motia app to Motia Cloud?
Node.JS projects are fully supported. Python projects are supported as well but there are a few external libraries that are not currently supported, such as:
TensorFlow
Pytorch
These are not supported due to the limited bundle size of 100MB.
Be mindful that static or binary files added to the bundle must not exceed 100MB.
What happens when I deploy my project to Motia Cloud?
When you deploy for the first time, it's immediately available. But when you deploy
for the second time and beyond, the deployment is listed but needs to be manually promoted to be live.
Promoting a deployment is a really simple process and happens immediately after you click.
Check thePromotepage for more information.
I deployed a new version but it didn't update
It's because Motia Cloud doesn't automatically promote the new version to be live. You need to promote it manually.
Check thePromotepage for more information.
How do I deploy my project to Motia Cloud?
You can deploy your project to Motia Cloud by using the Motia CLI or through the web interface.
Check theDeploymentpage for more information.
How do I rollback to a previous deployment?
You can rollback to a previous deployment by clicking the rollback button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I promote a deployment to be live?
You can promote a deployment to be live by clicking the promote button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I delete a deployment?
You can delete a deployment by clicking the delete button in the Motia Cloud web interface.
How do I update environment variables?
Currently, the only way to update environment variables is by creating a new deployment.
The reason is that every deployment is an atomic deployment and Environment Variables can also be source of
issues.
This was a decision to make sure that deployments are always predictable and consistent. And rollbacks
can be done with confidence. If an environment variable updated caused an issue, you can quickly rollback to
a previous deployment.
How do I add static or binary files to my project?
You can add static files to your project by adding them to theincludeFilesproperty in the step config.
Check theDeploymentpage for more information.
includeFiles
Is it possible to deploy using GitHub Actions?
Yes, it's totally possible to deploy your project using GitHub Actions.
How much it cost?
We're still working on the pricing model, but it's going to be based on usage. You will pay for what you use.
How do I get support?
You can get support by creating an issue on ourGitHub repository.
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Continuous Deployment
Move faster with continuous deployment
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/faq#how-do-i-add-static-or-binary-files-to-my-project =====

FAQ
Frequently asked questions about Motia Cloud
Can I deploy any Motia app to Motia Cloud?
Node.JS projects are fully supported. Python projects are supported as well but there are a few external libraries that are not currently supported, such as:
TensorFlow
Pytorch
These are not supported due to the limited bundle size of 100MB.
Be mindful that static or binary files added to the bundle must not exceed 100MB.
What happens when I deploy my project to Motia Cloud?
When you deploy for the first time, it's immediately available. But when you deploy
for the second time and beyond, the deployment is listed but needs to be manually promoted to be live.
Promoting a deployment is a really simple process and happens immediately after you click.
Check thePromotepage for more information.
I deployed a new version but it didn't update
It's because Motia Cloud doesn't automatically promote the new version to be live. You need to promote it manually.
Check thePromotepage for more information.
How do I deploy my project to Motia Cloud?
You can deploy your project to Motia Cloud by using the Motia CLI or through the web interface.
Check theDeploymentpage for more information.
How do I rollback to a previous deployment?
You can rollback to a previous deployment by clicking the rollback button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I promote a deployment to be live?
You can promote a deployment to be live by clicking the promote button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I delete a deployment?
You can delete a deployment by clicking the delete button in the Motia Cloud web interface.
How do I update environment variables?
Currently, the only way to update environment variables is by creating a new deployment.
The reason is that every deployment is an atomic deployment and Environment Variables can also be source of
issues.
This was a decision to make sure that deployments are always predictable and consistent. And rollbacks
can be done with confidence. If an environment variable updated caused an issue, you can quickly rollback to
a previous deployment.
How do I add static or binary files to my project?
You can add static files to your project by adding them to theincludeFilesproperty in the step config.
Check theDeploymentpage for more information.
includeFiles
Is it possible to deploy using GitHub Actions?
Yes, it's totally possible to deploy your project using GitHub Actions.
How much it cost?
We're still working on the pricing model, but it's going to be based on usage. You will pay for what you use.
How do I get support?
You can get support by creating an issue on ourGitHub repository.
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Continuous Deployment
Move faster with continuous deployment
On this page



===== https://www.motia.dev/docs/concepts/deployment/motia-cloud/deployment#adding-static-files-to-the-bundle =====





===== https://www.motia.dev/docs/deployment-guide/motia-cloud/faq#is-it-possible-to-deploy-using-github-actions =====

FAQ
Frequently asked questions about Motia Cloud
Can I deploy any Motia app to Motia Cloud?
Node.JS projects are fully supported. Python projects are supported as well but there are a few external libraries that are not currently supported, such as:
TensorFlow
Pytorch
These are not supported due to the limited bundle size of 100MB.
Be mindful that static or binary files added to the bundle must not exceed 100MB.
What happens when I deploy my project to Motia Cloud?
When you deploy for the first time, it's immediately available. But when you deploy
for the second time and beyond, the deployment is listed but needs to be manually promoted to be live.
Promoting a deployment is a really simple process and happens immediately after you click.
Check thePromotepage for more information.
I deployed a new version but it didn't update
It's because Motia Cloud doesn't automatically promote the new version to be live. You need to promote it manually.
Check thePromotepage for more information.
How do I deploy my project to Motia Cloud?
You can deploy your project to Motia Cloud by using the Motia CLI or through the web interface.
Check theDeploymentpage for more information.
How do I rollback to a previous deployment?
You can rollback to a previous deployment by clicking the rollback button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I promote a deployment to be live?
You can promote a deployment to be live by clicking the promote button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I delete a deployment?
You can delete a deployment by clicking the delete button in the Motia Cloud web interface.
How do I update environment variables?
Currently, the only way to update environment variables is by creating a new deployment.
The reason is that every deployment is an atomic deployment and Environment Variables can also be source of
issues.
This was a decision to make sure that deployments are always predictable and consistent. And rollbacks
can be done with confidence. If an environment variable updated caused an issue, you can quickly rollback to
a previous deployment.
How do I add static or binary files to my project?
You can add static files to your project by adding them to theincludeFilesproperty in the step config.
Check theDeploymentpage for more information.
includeFiles
Is it possible to deploy using GitHub Actions?
Yes, it's totally possible to deploy your project using GitHub Actions.
How much it cost?
We're still working on the pricing model, but it's going to be based on usage. You will pay for what you use.
How do I get support?
You can get support by creating an issue on ourGitHub repository.
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Continuous Deployment
Move faster with continuous deployment
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/faq#how-much-it-cost =====

FAQ
Frequently asked questions about Motia Cloud
Can I deploy any Motia app to Motia Cloud?
Node.JS projects are fully supported. Python projects are supported as well but there are a few external libraries that are not currently supported, such as:
TensorFlow
Pytorch
These are not supported due to the limited bundle size of 100MB.
Be mindful that static or binary files added to the bundle must not exceed 100MB.
What happens when I deploy my project to Motia Cloud?
When you deploy for the first time, it's immediately available. But when you deploy
for the second time and beyond, the deployment is listed but needs to be manually promoted to be live.
Promoting a deployment is a really simple process and happens immediately after you click.
Check thePromotepage for more information.
I deployed a new version but it didn't update
It's because Motia Cloud doesn't automatically promote the new version to be live. You need to promote it manually.
Check thePromotepage for more information.
How do I deploy my project to Motia Cloud?
You can deploy your project to Motia Cloud by using the Motia CLI or through the web interface.
Check theDeploymentpage for more information.
How do I rollback to a previous deployment?
You can rollback to a previous deployment by clicking the rollback button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I promote a deployment to be live?
You can promote a deployment to be live by clicking the promote button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I delete a deployment?
You can delete a deployment by clicking the delete button in the Motia Cloud web interface.
How do I update environment variables?
Currently, the only way to update environment variables is by creating a new deployment.
The reason is that every deployment is an atomic deployment and Environment Variables can also be source of
issues.
This was a decision to make sure that deployments are always predictable and consistent. And rollbacks
can be done with confidence. If an environment variable updated caused an issue, you can quickly rollback to
a previous deployment.
How do I add static or binary files to my project?
You can add static files to your project by adding them to theincludeFilesproperty in the step config.
Check theDeploymentpage for more information.
includeFiles
Is it possible to deploy using GitHub Actions?
Yes, it's totally possible to deploy your project using GitHub Actions.
How much it cost?
We're still working on the pricing model, but it's going to be based on usage. You will pay for what you use.
How do I get support?
You can get support by creating an issue on ourGitHub repository.
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Continuous Deployment
Move faster with continuous deployment
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/faq#how-do-i-get-support =====

FAQ
Frequently asked questions about Motia Cloud
Can I deploy any Motia app to Motia Cloud?
Node.JS projects are fully supported. Python projects are supported as well but there are a few external libraries that are not currently supported, such as:
TensorFlow
Pytorch
These are not supported due to the limited bundle size of 100MB.
Be mindful that static or binary files added to the bundle must not exceed 100MB.
What happens when I deploy my project to Motia Cloud?
When you deploy for the first time, it's immediately available. But when you deploy
for the second time and beyond, the deployment is listed but needs to be manually promoted to be live.
Promoting a deployment is a really simple process and happens immediately after you click.
Check thePromotepage for more information.
I deployed a new version but it didn't update
It's because Motia Cloud doesn't automatically promote the new version to be live. You need to promote it manually.
Check thePromotepage for more information.
How do I deploy my project to Motia Cloud?
You can deploy your project to Motia Cloud by using the Motia CLI or through the web interface.
Check theDeploymentpage for more information.
How do I rollback to a previous deployment?
You can rollback to a previous deployment by clicking the rollback button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I promote a deployment to be live?
You can promote a deployment to be live by clicking the promote button in the Motia Cloud web interface.
Check thePromotepage for more information.
How do I delete a deployment?
You can delete a deployment by clicking the delete button in the Motia Cloud web interface.
How do I update environment variables?
Currently, the only way to update environment variables is by creating a new deployment.
The reason is that every deployment is an atomic deployment and Environment Variables can also be source of
issues.
This was a decision to make sure that deployments are always predictable and consistent. And rollbacks
can be done with confidence. If an environment variable updated caused an issue, you can quickly rollback to
a previous deployment.
How do I add static or binary files to my project?
You can add static files to your project by adding them to theincludeFilesproperty in the step config.
Check theDeploymentpage for more information.
includeFiles
Is it possible to deploy using GitHub Actions?
Yes, it's totally possible to deploy your project using GitHub Actions.
How much it cost?
We're still working on the pricing model, but it's going to be based on usage. You will pay for what you use.
How do I get support?
You can get support by creating an issue on ourGitHub repository.
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Continuous Deployment
Move faster with continuous deployment
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/architecture#bundle-sizes =====

Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Bundle sizes
Motia Cloud currently has limited bundle sizes to 100MB, we're actively working on increasing this limit
to be higher than 1GB.
Payload size on events
When sending events to topics, the data should not have more than 4KB.
Make sure you're not sending files as Base64 in the content of the event.
Make sure payloads you send are not too large, prefer storing in state and fetch it on the other steps.
Using Local Files
Sometimes we need toa use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Make sure you follow the instructions inDeployments page.
Runtime timeouts
Motia Cloud currently has limited runtime timeouts:
15 minutes for Event and Cron Steps.
30 seconds for API Steps.
Reserved environment variables
Motia Cloud is currently deployed to Amazon Web Services. Which means that there are
some environment variables that are reserved for internal use. If you need to use one
of these variables, make sure to add a different name.
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
Limitations
100MB bundle size
4KB payload size on events
15 minutes runtime timeout for Event and Cron Steps
30 seconds runtime timeout for API Steps
Troubleshooting build outputs
Make sure you follow the instructions inDeployments page.
Deployment
Deploying your project to Motia Cloud
FAQ
Frequently asked questions about Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/architecture#payload-size-on-events =====

Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Bundle sizes
Motia Cloud currently has limited bundle sizes to 100MB, we're actively working on increasing this limit
to be higher than 1GB.
Payload size on events
When sending events to topics, the data should not have more than 4KB.
Make sure you're not sending files as Base64 in the content of the event.
Make sure payloads you send are not too large, prefer storing in state and fetch it on the other steps.
Using Local Files
Sometimes we need toa use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Make sure you follow the instructions inDeployments page.
Runtime timeouts
Motia Cloud currently has limited runtime timeouts:
15 minutes for Event and Cron Steps.
30 seconds for API Steps.
Reserved environment variables
Motia Cloud is currently deployed to Amazon Web Services. Which means that there are
some environment variables that are reserved for internal use. If you need to use one
of these variables, make sure to add a different name.
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
Limitations
100MB bundle size
4KB payload size on events
15 minutes runtime timeout for Event and Cron Steps
30 seconds runtime timeout for API Steps
Troubleshooting build outputs
Make sure you follow the instructions inDeployments page.
Deployment
Deploying your project to Motia Cloud
FAQ
Frequently asked questions about Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/architecture#using-local-files =====

Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Bundle sizes
Motia Cloud currently has limited bundle sizes to 100MB, we're actively working on increasing this limit
to be higher than 1GB.
Payload size on events
When sending events to topics, the data should not have more than 4KB.
Make sure you're not sending files as Base64 in the content of the event.
Make sure payloads you send are not too large, prefer storing in state and fetch it on the other steps.
Using Local Files
Sometimes we need toa use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Make sure you follow the instructions inDeployments page.
Runtime timeouts
Motia Cloud currently has limited runtime timeouts:
15 minutes for Event and Cron Steps.
30 seconds for API Steps.
Reserved environment variables
Motia Cloud is currently deployed to Amazon Web Services. Which means that there are
some environment variables that are reserved for internal use. If you need to use one
of these variables, make sure to add a different name.
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
Limitations
100MB bundle size
4KB payload size on events
15 minutes runtime timeout for Event and Cron Steps
30 seconds runtime timeout for API Steps
Troubleshooting build outputs
Make sure you follow the instructions inDeployments page.
Deployment
Deploying your project to Motia Cloud
FAQ
Frequently asked questions about Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/architecture#runtime-timeouts =====

Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Bundle sizes
Motia Cloud currently has limited bundle sizes to 100MB, we're actively working on increasing this limit
to be higher than 1GB.
Payload size on events
When sending events to topics, the data should not have more than 4KB.
Make sure you're not sending files as Base64 in the content of the event.
Make sure payloads you send are not too large, prefer storing in state and fetch it on the other steps.
Using Local Files
Sometimes we need toa use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Make sure you follow the instructions inDeployments page.
Runtime timeouts
Motia Cloud currently has limited runtime timeouts:
15 minutes for Event and Cron Steps.
30 seconds for API Steps.
Reserved environment variables
Motia Cloud is currently deployed to Amazon Web Services. Which means that there are
some environment variables that are reserved for internal use. If you need to use one
of these variables, make sure to add a different name.
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
Limitations
100MB bundle size
4KB payload size on events
15 minutes runtime timeout for Event and Cron Steps
30 seconds runtime timeout for API Steps
Troubleshooting build outputs
Make sure you follow the instructions inDeployments page.
Deployment
Deploying your project to Motia Cloud
FAQ
Frequently asked questions about Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/architecture#reserved-environment-variables =====

Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Bundle sizes
Motia Cloud currently has limited bundle sizes to 100MB, we're actively working on increasing this limit
to be higher than 1GB.
Payload size on events
When sending events to topics, the data should not have more than 4KB.
Make sure you're not sending files as Base64 in the content of the event.
Make sure payloads you send are not too large, prefer storing in state and fetch it on the other steps.
Using Local Files
Sometimes we need toa use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Make sure you follow the instructions inDeployments page.
Runtime timeouts
Motia Cloud currently has limited runtime timeouts:
15 minutes for Event and Cron Steps.
30 seconds for API Steps.
Reserved environment variables
Motia Cloud is currently deployed to Amazon Web Services. Which means that there are
some environment variables that are reserved for internal use. If you need to use one
of these variables, make sure to add a different name.
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
Limitations
100MB bundle size
4KB payload size on events
15 minutes runtime timeout for Event and Cron Steps
30 seconds runtime timeout for API Steps
Troubleshooting build outputs
Make sure you follow the instructions inDeployments page.
Deployment
Deploying your project to Motia Cloud
FAQ
Frequently asked questions about Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/architecture#limitations =====

Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Bundle sizes
Motia Cloud currently has limited bundle sizes to 100MB, we're actively working on increasing this limit
to be higher than 1GB.
Payload size on events
When sending events to topics, the data should not have more than 4KB.
Make sure you're not sending files as Base64 in the content of the event.
Make sure payloads you send are not too large, prefer storing in state and fetch it on the other steps.
Using Local Files
Sometimes we need toa use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Make sure you follow the instructions inDeployments page.
Runtime timeouts
Motia Cloud currently has limited runtime timeouts:
15 minutes for Event and Cron Steps.
30 seconds for API Steps.
Reserved environment variables
Motia Cloud is currently deployed to Amazon Web Services. Which means that there are
some environment variables that are reserved for internal use. If you need to use one
of these variables, make sure to add a different name.
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
Limitations
100MB bundle size
4KB payload size on events
15 minutes runtime timeout for Event and Cron Steps
30 seconds runtime timeout for API Steps
Troubleshooting build outputs
Make sure you follow the instructions inDeployments page.
Deployment
Deploying your project to Motia Cloud
FAQ
Frequently asked questions about Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/architecture#troubleshooting-build-outputs =====

Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
Bundle sizes
Motia Cloud currently has limited bundle sizes to 100MB, we're actively working on increasing this limit
to be higher than 1GB.
Payload size on events
When sending events to topics, the data should not have more than 4KB.
Make sure you're not sending files as Base64 in the content of the event.
Make sure payloads you send are not too large, prefer storing in state and fetch it on the other steps.
Using Local Files
Sometimes we need toa use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Make sure you follow the instructions inDeployments page.
Runtime timeouts
Motia Cloud currently has limited runtime timeouts:
15 minutes for Event and Cron Steps.
30 seconds for API Steps.
Reserved environment variables
Motia Cloud is currently deployed to Amazon Web Services. Which means that there are
some environment variables that are reserved for internal use. If you need to use one
of these variables, make sure to add a different name.
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
_HANDLER_X_AMZN_TRACE_IDAWS_DEFAULT_REGIONAWS_REGIONAWS_EXECUTION_ENVAWS_LAMBDA_FUNCTION_NAMEAWS_LAMBDA_FUNCTION_MEMORY_SIZEAWS_LAMBDA_FUNCTION_VERSIONAWS_LAMBDA_INITIALIZATION_TYPEAWS_LAMBDA_LOG_GROUP_NAMEAWS_LAMBDA_LOG_STREAM_NAMEAWS_ACCESS_KEYAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEYAWS_SESSION_TOKENAWS_LAMBDA_RUNTIME_APILAMBDA_TASK_ROOTLAMBDA_RUNTIME_DIR
Limitations
100MB bundle size
4KB payload size on events
15 minutes runtime timeout for Event and Cron Steps
30 seconds runtime timeout for API Steps
Troubleshooting build outputs
Make sure you follow the instructions inDeployments page.
Deployment
Deploying your project to Motia Cloud
FAQ
Frequently asked questions about Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/deployment#using-the-motia-cli-for-deployment =====

Deployment
Deploying your project to Motia Cloud
There are two ways to deploy your project to Motia Cloud:
Using the CLI
Using the Web interface
Using the Motia CLI for Deployment
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
--api-key
-k
MOTIA_API_KEY
--version-name
-v
--environment-id
-s
MOTIA_ENVIRONMENT_ID
--version-description
-d
--env-file
-e
Note:Command-line options take precedence over environment variables. If both are provided, the command-line value will be used.
Deploy with a specific version:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
Deploy to a specific environment with environment variables:
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
Using Web interface
Through the web interface, you can deploy your project from workbench to a live environment with one click.
Steps to deploy from web interface:
Have your local project running (make sure your Motia version is 0.6.4 or higher)
Go to import from workbench on Motia Cloud
Select the port your local project is running on
Choose the project and environment name
Add any environment variables you need (you can upload from .env file or paste the content to auto-fill)
Click Deploy
Watch the magic happen
Adding static files to the bundle
Sometimes we need to use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Adding them to Steps as static files, you need to addincludeFilesto the step config. The path
should be relative to the step file.
includeFiles
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
Adding binary files to the bundle
Binary files are also supported, but the entire bundle size must not exceed 100MB.
The binary architecture should be linux_amd64.
Troubleshooting Build Outputs
When adding static files, it's important to check the build output to make sure the files are included.
For example, inthis project, there are a few steps that
include static files.
When runningnpx motia build, it will generate the following output indistfolder:
npx motia build
dist
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
If you check the content ofcontent-outliner.step.zip, it should have this
content-outliner.step.zip
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
Now you made sure the static file calledcontent-outliner.mustacheis included in the bundle.
content-outliner.mustache
Features
Learn how to deploy your Motia Project to a live environment
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/deployment#required-options =====

Deployment
Deploying your project to Motia Cloud
There are two ways to deploy your project to Motia Cloud:
Using the CLI
Using the Web interface
Using the Motia CLI for Deployment
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
--api-key
-k
MOTIA_API_KEY
--version-name
-v
--environment-id
-s
MOTIA_ENVIRONMENT_ID
--version-description
-d
--env-file
-e
Note:Command-line options take precedence over environment variables. If both are provided, the command-line value will be used.
Deploy with a specific version:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
Deploy to a specific environment with environment variables:
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
Using Web interface
Through the web interface, you can deploy your project from workbench to a live environment with one click.
Steps to deploy from web interface:
Have your local project running (make sure your Motia version is 0.6.4 or higher)
Go to import from workbench on Motia Cloud
Select the port your local project is running on
Choose the project and environment name
Add any environment variables you need (you can upload from .env file or paste the content to auto-fill)
Click Deploy
Watch the magic happen
Adding static files to the bundle
Sometimes we need to use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Adding them to Steps as static files, you need to addincludeFilesto the step config. The path
should be relative to the step file.
includeFiles
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
Adding binary files to the bundle
Binary files are also supported, but the entire bundle size must not exceed 100MB.
The binary architecture should be linux_amd64.
Troubleshooting Build Outputs
When adding static files, it's important to check the build output to make sure the files are included.
For example, inthis project, there are a few steps that
include static files.
When runningnpx motia build, it will generate the following output indistfolder:
npx motia build
dist
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
If you check the content ofcontent-outliner.step.zip, it should have this
content-outliner.step.zip
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
Now you made sure the static file calledcontent-outliner.mustacheis included in the bundle.
content-outliner.mustache
Features
Learn how to deploy your Motia Project to a live environment
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/deployment#optional-options =====

Deployment
Deploying your project to Motia Cloud
There are two ways to deploy your project to Motia Cloud:
Using the CLI
Using the Web interface
Using the Motia CLI for Deployment
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
--api-key
-k
MOTIA_API_KEY
--version-name
-v
--environment-id
-s
MOTIA_ENVIRONMENT_ID
--version-description
-d
--env-file
-e
Note:Command-line options take precedence over environment variables. If both are provided, the command-line value will be used.
Deploy with a specific version:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
Deploy to a specific environment with environment variables:
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
Using Web interface
Through the web interface, you can deploy your project from workbench to a live environment with one click.
Steps to deploy from web interface:
Have your local project running (make sure your Motia version is 0.6.4 or higher)
Go to import from workbench on Motia Cloud
Select the port your local project is running on
Choose the project and environment name
Add any environment variables you need (you can upload from .env file or paste the content to auto-fill)
Click Deploy
Watch the magic happen
Adding static files to the bundle
Sometimes we need to use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Adding them to Steps as static files, you need to addincludeFilesto the step config. The path
should be relative to the step file.
includeFiles
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
Adding binary files to the bundle
Binary files are also supported, but the entire bundle size must not exceed 100MB.
The binary architecture should be linux_amd64.
Troubleshooting Build Outputs
When adding static files, it's important to check the build output to make sure the files are included.
For example, inthis project, there are a few steps that
include static files.
When runningnpx motia build, it will generate the following output indistfolder:
npx motia build
dist
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
If you check the content ofcontent-outliner.step.zip, it should have this
content-outliner.step.zip
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
Now you made sure the static file calledcontent-outliner.mustacheis included in the bundle.
content-outliner.mustache
Features
Learn how to deploy your Motia Project to a live environment
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/deployment#using-web-interface =====

Deployment
Deploying your project to Motia Cloud
There are two ways to deploy your project to Motia Cloud:
Using the CLI
Using the Web interface
Using the Motia CLI for Deployment
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
--api-key
-k
MOTIA_API_KEY
--version-name
-v
--environment-id
-s
MOTIA_ENVIRONMENT_ID
--version-description
-d
--env-file
-e
Note:Command-line options take precedence over environment variables. If both are provided, the command-line value will be used.
Deploy with a specific version:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
Deploy to a specific environment with environment variables:
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
Using Web interface
Through the web interface, you can deploy your project from workbench to a live environment with one click.
Steps to deploy from web interface:
Have your local project running (make sure your Motia version is 0.6.4 or higher)
Go to import from workbench on Motia Cloud
Select the port your local project is running on
Choose the project and environment name
Add any environment variables you need (you can upload from .env file or paste the content to auto-fill)
Click Deploy
Watch the magic happen
Adding static files to the bundle
Sometimes we need to use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Adding them to Steps as static files, you need to addincludeFilesto the step config. The path
should be relative to the step file.
includeFiles
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
Adding binary files to the bundle
Binary files are also supported, but the entire bundle size must not exceed 100MB.
The binary architecture should be linux_amd64.
Troubleshooting Build Outputs
When adding static files, it's important to check the build output to make sure the files are included.
For example, inthis project, there are a few steps that
include static files.
When runningnpx motia build, it will generate the following output indistfolder:
npx motia build
dist
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
If you check the content ofcontent-outliner.step.zip, it should have this
content-outliner.step.zip
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
Now you made sure the static file calledcontent-outliner.mustacheis included in the bundle.
content-outliner.mustache
Features
Learn how to deploy your Motia Project to a live environment
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/deployment#adding-static-files-to-the-bundle =====

Deployment
Deploying your project to Motia Cloud
There are two ways to deploy your project to Motia Cloud:
Using the CLI
Using the Web interface
Using the Motia CLI for Deployment
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
--api-key
-k
MOTIA_API_KEY
--version-name
-v
--environment-id
-s
MOTIA_ENVIRONMENT_ID
--version-description
-d
--env-file
-e
Note:Command-line options take precedence over environment variables. If both are provided, the command-line value will be used.
Deploy with a specific version:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
Deploy to a specific environment with environment variables:
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
Using Web interface
Through the web interface, you can deploy your project from workbench to a live environment with one click.
Steps to deploy from web interface:
Have your local project running (make sure your Motia version is 0.6.4 or higher)
Go to import from workbench on Motia Cloud
Select the port your local project is running on
Choose the project and environment name
Add any environment variables you need (you can upload from .env file or paste the content to auto-fill)
Click Deploy
Watch the magic happen
Adding static files to the bundle
Sometimes we need to use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Adding them to Steps as static files, you need to addincludeFilesto the step config. The path
should be relative to the step file.
includeFiles
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
Adding binary files to the bundle
Binary files are also supported, but the entire bundle size must not exceed 100MB.
The binary architecture should be linux_amd64.
Troubleshooting Build Outputs
When adding static files, it's important to check the build output to make sure the files are included.
For example, inthis project, there are a few steps that
include static files.
When runningnpx motia build, it will generate the following output indistfolder:
npx motia build
dist
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
If you check the content ofcontent-outliner.step.zip, it should have this
content-outliner.step.zip
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
Now you made sure the static file calledcontent-outliner.mustacheis included in the bundle.
content-outliner.mustache
Features
Learn how to deploy your Motia Project to a live environment
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/deployment#adding-binary-files-to-the-bundle =====

Deployment
Deploying your project to Motia Cloud
There are two ways to deploy your project to Motia Cloud:
Using the CLI
Using the Web interface
Using the Motia CLI for Deployment
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
--api-key
-k
MOTIA_API_KEY
--version-name
-v
--environment-id
-s
MOTIA_ENVIRONMENT_ID
--version-description
-d
--env-file
-e
Note:Command-line options take precedence over environment variables. If both are provided, the command-line value will be used.
Deploy with a specific version:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
Deploy to a specific environment with environment variables:
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
Using Web interface
Through the web interface, you can deploy your project from workbench to a live environment with one click.
Steps to deploy from web interface:
Have your local project running (make sure your Motia version is 0.6.4 or higher)
Go to import from workbench on Motia Cloud
Select the port your local project is running on
Choose the project and environment name
Add any environment variables you need (you can upload from .env file or paste the content to auto-fill)
Click Deploy
Watch the magic happen
Adding static files to the bundle
Sometimes we need to use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Adding them to Steps as static files, you need to addincludeFilesto the step config. The path
should be relative to the step file.
includeFiles
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
Adding binary files to the bundle
Binary files are also supported, but the entire bundle size must not exceed 100MB.
The binary architecture should be linux_amd64.
Troubleshooting Build Outputs
When adding static files, it's important to check the build output to make sure the files are included.
For example, inthis project, there are a few steps that
include static files.
When runningnpx motia build, it will generate the following output indistfolder:
npx motia build
dist
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
If you check the content ofcontent-outliner.step.zip, it should have this
content-outliner.step.zip
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
Now you made sure the static file calledcontent-outliner.mustacheis included in the bundle.
content-outliner.mustache
Features
Learn how to deploy your Motia Project to a live environment
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/deployment#troubleshooting-build-outputs =====

Deployment
Deploying your project to Motia Cloud
There are two ways to deploy your project to Motia Cloud:
Using the CLI
Using the Web interface
Using the Motia CLI for Deployment
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
motiaclouddeploy--api-key<api-key>--version-name<version>[options]
--api-key
-k
MOTIA_API_KEY
--version-name
-v
--environment-id
-s
MOTIA_ENVIRONMENT_ID
--version-description
-d
--env-file
-e
Note:Command-line options take precedence over environment variables. If both are provided, the command-line value will be used.
Deploy with a specific version:
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
motiaclouddeploy--api-keyyour-api-key-here--version-name1.2.3
Deploy to a specific environment with environment variables:
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
motiaclouddeploy--api-keyyour-api-key-here\--version-name1.2.3\--env-file.env.production\--environment-idenv-id
Using Web interface
Through the web interface, you can deploy your project from workbench to a live environment with one click.
Steps to deploy from web interface:
Have your local project running (make sure your Motia version is 0.6.4 or higher)
Go to import from workbench on Motia Cloud
Select the port your local project is running on
Choose the project and environment name
Add any environment variables you need (you can upload from .env file or paste the content to auto-fill)
Click Deploy
Watch the magic happen
Adding static files to the bundle
Sometimes we need to use local files when creating our backend logic. For example, creating templates.
Running binary files, etc. To do this, we can add them to steps as static files.
Adding them to Steps as static files, you need to addincludeFilesto the step config. The path
should be relative to the step file.
includeFiles
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
import{ EventConfig }from'motia'exportconstconfig:EventConfig={name:'Content Outliner',description:'Creates detailed content outline based on the initial idea',type:'event',emits: [{ topic:'write-content', label:'Write first content'}],virtualEmits: ['virtual-write-content'],flows: ['Content'],subscribes: ['build-outline'],input,includeFiles: ['./content-outliner.mustache'],// relative to the step file}
Adding binary files to the bundle
Binary files are also supported, but the entire bundle size must not exceed 100MB.
The binary architecture should be linux_amd64.
Troubleshooting Build Outputs
When adding static files, it's important to check the build output to make sure the files are included.
For example, inthis project, there are a few steps that
include static files.
When runningnpx motia build, it will generate the following output indistfolder:
npx motia build
dist
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
dist/└── node/steps/content/├── agents│   ├── content-outliner.step.zip│   ├── content-writer.step.zip│   └── ideator.step.zip├── api│   ├── generate-content-api.step.zip│   └── get-content.step.zip├── motia.steps.json└── router-node.zip
If you check the content ofcontent-outliner.step.zip, it should have this
content-outliner.step.zip
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
steps/└── content/└── agents/├── content-outliner.mustache├── content-outliner.step.js└── content-outliner.step.js.map
Now you made sure the static file calledcontent-outliner.mustacheis included in the bundle.
content-outliner.mustache
Features
Learn how to deploy your Motia Project to a live environment
Architecture
Motia Cloud is a serverless platform. Some stuff that work locally may not work in the cloud.
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/features#real-time-deployment-status-updates =====

Features
Learn how to deploy your Motia Project to a live environment
Motia Cloud is the easiest way to deploy your Motia Project to a live environment.
Quickly deploy your project to a live environment with one click. Then confidently
roll up updates, roll back to a previous stable version, and scale your project with ease.
Manage multiple environments, visualize logs and traces, and keep your project running smoothly.
Real-time deployment status updates
You can see the deployment status in real-time in the Motia Cloud web interface
Deployment history
All recent deployments on your project are available in Motia Cloud UI. You can browse them
and promote them to be live in the environment.
Zero downtime deployments
Every deployment is an atomic deployment, this means that Motia Cloud creates a new infrastructure
with all the Message Queues system isolatedly for each deployment.
Why is this important?
No downtime deployments
Avoid backwards compatibility issues on message queues: Example, you can change a topic data structure
without worrying about breaking messages that are flowing during the deployment.
Instant rollbacks and roll up updates
With one button you can rollback to a previous deployment. This allows you to be confident
on deployments, if anything fails, quickly rollback to a previous stable version.
One-click deployment
Deploy your project from workbench to a live environment with one click.
Observability
Have the same experience you have with Workbench locally in cloud. Such as:
Logs visualization
Tracing tool
Logs visualization
You can see the logs of your project in the Motia Cloud web interface.
Tracing tool
Tracing tool to quickly visualize the flow of requests through the system.
Multiple environments support
Motia Cloud supports creating multiple environments for your projects.
Scalability
Horizontal scaling individually for each step
Retry mechanisms for event steps built-in (3 retries by default)
Learn how to deploy
Learn how to deploy your project to Motia Cloud in theDeploymentpage.
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
Deployment
Deploying your project to Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/features#deployment-history =====

Features
Learn how to deploy your Motia Project to a live environment
Motia Cloud is the easiest way to deploy your Motia Project to a live environment.
Quickly deploy your project to a live environment with one click. Then confidently
roll up updates, roll back to a previous stable version, and scale your project with ease.
Manage multiple environments, visualize logs and traces, and keep your project running smoothly.
Real-time deployment status updates
You can see the deployment status in real-time in the Motia Cloud web interface
Deployment history
All recent deployments on your project are available in Motia Cloud UI. You can browse them
and promote them to be live in the environment.
Zero downtime deployments
Every deployment is an atomic deployment, this means that Motia Cloud creates a new infrastructure
with all the Message Queues system isolatedly for each deployment.
Why is this important?
No downtime deployments
Avoid backwards compatibility issues on message queues: Example, you can change a topic data structure
without worrying about breaking messages that are flowing during the deployment.
Instant rollbacks and roll up updates
With one button you can rollback to a previous deployment. This allows you to be confident
on deployments, if anything fails, quickly rollback to a previous stable version.
One-click deployment
Deploy your project from workbench to a live environment with one click.
Observability
Have the same experience you have with Workbench locally in cloud. Such as:
Logs visualization
Tracing tool
Logs visualization
You can see the logs of your project in the Motia Cloud web interface.
Tracing tool
Tracing tool to quickly visualize the flow of requests through the system.
Multiple environments support
Motia Cloud supports creating multiple environments for your projects.
Scalability
Horizontal scaling individually for each step
Retry mechanisms for event steps built-in (3 retries by default)
Learn how to deploy
Learn how to deploy your project to Motia Cloud in theDeploymentpage.
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
Deployment
Deploying your project to Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/features#zero-downtime-deployments =====

Features
Learn how to deploy your Motia Project to a live environment
Motia Cloud is the easiest way to deploy your Motia Project to a live environment.
Quickly deploy your project to a live environment with one click. Then confidently
roll up updates, roll back to a previous stable version, and scale your project with ease.
Manage multiple environments, visualize logs and traces, and keep your project running smoothly.
Real-time deployment status updates
You can see the deployment status in real-time in the Motia Cloud web interface
Deployment history
All recent deployments on your project are available in Motia Cloud UI. You can browse them
and promote them to be live in the environment.
Zero downtime deployments
Every deployment is an atomic deployment, this means that Motia Cloud creates a new infrastructure
with all the Message Queues system isolatedly for each deployment.
Why is this important?
No downtime deployments
Avoid backwards compatibility issues on message queues: Example, you can change a topic data structure
without worrying about breaking messages that are flowing during the deployment.
Instant rollbacks and roll up updates
With one button you can rollback to a previous deployment. This allows you to be confident
on deployments, if anything fails, quickly rollback to a previous stable version.
One-click deployment
Deploy your project from workbench to a live environment with one click.
Observability
Have the same experience you have with Workbench locally in cloud. Such as:
Logs visualization
Tracing tool
Logs visualization
You can see the logs of your project in the Motia Cloud web interface.
Tracing tool
Tracing tool to quickly visualize the flow of requests through the system.
Multiple environments support
Motia Cloud supports creating multiple environments for your projects.
Scalability
Horizontal scaling individually for each step
Retry mechanisms for event steps built-in (3 retries by default)
Learn how to deploy
Learn how to deploy your project to Motia Cloud in theDeploymentpage.
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
Deployment
Deploying your project to Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/features#why-is-this-important =====

Features
Learn how to deploy your Motia Project to a live environment
Motia Cloud is the easiest way to deploy your Motia Project to a live environment.
Quickly deploy your project to a live environment with one click. Then confidently
roll up updates, roll back to a previous stable version, and scale your project with ease.
Manage multiple environments, visualize logs and traces, and keep your project running smoothly.
Real-time deployment status updates
You can see the deployment status in real-time in the Motia Cloud web interface
Deployment history
All recent deployments on your project are available in Motia Cloud UI. You can browse them
and promote them to be live in the environment.
Zero downtime deployments
Every deployment is an atomic deployment, this means that Motia Cloud creates a new infrastructure
with all the Message Queues system isolatedly for each deployment.
Why is this important?
No downtime deployments
Avoid backwards compatibility issues on message queues: Example, you can change a topic data structure
without worrying about breaking messages that are flowing during the deployment.
Instant rollbacks and roll up updates
With one button you can rollback to a previous deployment. This allows you to be confident
on deployments, if anything fails, quickly rollback to a previous stable version.
One-click deployment
Deploy your project from workbench to a live environment with one click.
Observability
Have the same experience you have with Workbench locally in cloud. Such as:
Logs visualization
Tracing tool
Logs visualization
You can see the logs of your project in the Motia Cloud web interface.
Tracing tool
Tracing tool to quickly visualize the flow of requests through the system.
Multiple environments support
Motia Cloud supports creating multiple environments for your projects.
Scalability
Horizontal scaling individually for each step
Retry mechanisms for event steps built-in (3 retries by default)
Learn how to deploy
Learn how to deploy your project to Motia Cloud in theDeploymentpage.
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
Deployment
Deploying your project to Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/features#instant-rollbacks-and-roll-up-updates =====

Features
Learn how to deploy your Motia Project to a live environment
Motia Cloud is the easiest way to deploy your Motia Project to a live environment.
Quickly deploy your project to a live environment with one click. Then confidently
roll up updates, roll back to a previous stable version, and scale your project with ease.
Manage multiple environments, visualize logs and traces, and keep your project running smoothly.
Real-time deployment status updates
You can see the deployment status in real-time in the Motia Cloud web interface
Deployment history
All recent deployments on your project are available in Motia Cloud UI. You can browse them
and promote them to be live in the environment.
Zero downtime deployments
Every deployment is an atomic deployment, this means that Motia Cloud creates a new infrastructure
with all the Message Queues system isolatedly for each deployment.
Why is this important?
No downtime deployments
Avoid backwards compatibility issues on message queues: Example, you can change a topic data structure
without worrying about breaking messages that are flowing during the deployment.
Instant rollbacks and roll up updates
With one button you can rollback to a previous deployment. This allows you to be confident
on deployments, if anything fails, quickly rollback to a previous stable version.
One-click deployment
Deploy your project from workbench to a live environment with one click.
Observability
Have the same experience you have with Workbench locally in cloud. Such as:
Logs visualization
Tracing tool
Logs visualization
You can see the logs of your project in the Motia Cloud web interface.
Tracing tool
Tracing tool to quickly visualize the flow of requests through the system.
Multiple environments support
Motia Cloud supports creating multiple environments for your projects.
Scalability
Horizontal scaling individually for each step
Retry mechanisms for event steps built-in (3 retries by default)
Learn how to deploy
Learn how to deploy your project to Motia Cloud in theDeploymentpage.
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
Deployment
Deploying your project to Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/features#one-click-deployment =====

Features
Learn how to deploy your Motia Project to a live environment
Motia Cloud is the easiest way to deploy your Motia Project to a live environment.
Quickly deploy your project to a live environment with one click. Then confidently
roll up updates, roll back to a previous stable version, and scale your project with ease.
Manage multiple environments, visualize logs and traces, and keep your project running smoothly.
Real-time deployment status updates
You can see the deployment status in real-time in the Motia Cloud web interface
Deployment history
All recent deployments on your project are available in Motia Cloud UI. You can browse them
and promote them to be live in the environment.
Zero downtime deployments
Every deployment is an atomic deployment, this means that Motia Cloud creates a new infrastructure
with all the Message Queues system isolatedly for each deployment.
Why is this important?
No downtime deployments
Avoid backwards compatibility issues on message queues: Example, you can change a topic data structure
without worrying about breaking messages that are flowing during the deployment.
Instant rollbacks and roll up updates
With one button you can rollback to a previous deployment. This allows you to be confident
on deployments, if anything fails, quickly rollback to a previous stable version.
One-click deployment
Deploy your project from workbench to a live environment with one click.
Observability
Have the same experience you have with Workbench locally in cloud. Such as:
Logs visualization
Tracing tool
Logs visualization
You can see the logs of your project in the Motia Cloud web interface.
Tracing tool
Tracing tool to quickly visualize the flow of requests through the system.
Multiple environments support
Motia Cloud supports creating multiple environments for your projects.
Scalability
Horizontal scaling individually for each step
Retry mechanisms for event steps built-in (3 retries by default)
Learn how to deploy
Learn how to deploy your project to Motia Cloud in theDeploymentpage.
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
Deployment
Deploying your project to Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/features#observability =====

Features
Learn how to deploy your Motia Project to a live environment
Motia Cloud is the easiest way to deploy your Motia Project to a live environment.
Quickly deploy your project to a live environment with one click. Then confidently
roll up updates, roll back to a previous stable version, and scale your project with ease.
Manage multiple environments, visualize logs and traces, and keep your project running smoothly.
Real-time deployment status updates
You can see the deployment status in real-time in the Motia Cloud web interface
Deployment history
All recent deployments on your project are available in Motia Cloud UI. You can browse them
and promote them to be live in the environment.
Zero downtime deployments
Every deployment is an atomic deployment, this means that Motia Cloud creates a new infrastructure
with all the Message Queues system isolatedly for each deployment.
Why is this important?
No downtime deployments
Avoid backwards compatibility issues on message queues: Example, you can change a topic data structure
without worrying about breaking messages that are flowing during the deployment.
Instant rollbacks and roll up updates
With one button you can rollback to a previous deployment. This allows you to be confident
on deployments, if anything fails, quickly rollback to a previous stable version.
One-click deployment
Deploy your project from workbench to a live environment with one click.
Observability
Have the same experience you have with Workbench locally in cloud. Such as:
Logs visualization
Tracing tool
Logs visualization
You can see the logs of your project in the Motia Cloud web interface.
Tracing tool
Tracing tool to quickly visualize the flow of requests through the system.
Multiple environments support
Motia Cloud supports creating multiple environments for your projects.
Scalability
Horizontal scaling individually for each step
Retry mechanisms for event steps built-in (3 retries by default)
Learn how to deploy
Learn how to deploy your project to Motia Cloud in theDeploymentpage.
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
Deployment
Deploying your project to Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/features#logs-visualization =====

Features
Learn how to deploy your Motia Project to a live environment
Motia Cloud is the easiest way to deploy your Motia Project to a live environment.
Quickly deploy your project to a live environment with one click. Then confidently
roll up updates, roll back to a previous stable version, and scale your project with ease.
Manage multiple environments, visualize logs and traces, and keep your project running smoothly.
Real-time deployment status updates
You can see the deployment status in real-time in the Motia Cloud web interface
Deployment history
All recent deployments on your project are available in Motia Cloud UI. You can browse them
and promote them to be live in the environment.
Zero downtime deployments
Every deployment is an atomic deployment, this means that Motia Cloud creates a new infrastructure
with all the Message Queues system isolatedly for each deployment.
Why is this important?
No downtime deployments
Avoid backwards compatibility issues on message queues: Example, you can change a topic data structure
without worrying about breaking messages that are flowing during the deployment.
Instant rollbacks and roll up updates
With one button you can rollback to a previous deployment. This allows you to be confident
on deployments, if anything fails, quickly rollback to a previous stable version.
One-click deployment
Deploy your project from workbench to a live environment with one click.
Observability
Have the same experience you have with Workbench locally in cloud. Such as:
Logs visualization
Tracing tool
Logs visualization
You can see the logs of your project in the Motia Cloud web interface.
Tracing tool
Tracing tool to quickly visualize the flow of requests through the system.
Multiple environments support
Motia Cloud supports creating multiple environments for your projects.
Scalability
Horizontal scaling individually for each step
Retry mechanisms for event steps built-in (3 retries by default)
Learn how to deploy
Learn how to deploy your project to Motia Cloud in theDeploymentpage.
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
Deployment
Deploying your project to Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/features#tracing-tool =====

Features
Learn how to deploy your Motia Project to a live environment
Motia Cloud is the easiest way to deploy your Motia Project to a live environment.
Quickly deploy your project to a live environment with one click. Then confidently
roll up updates, roll back to a previous stable version, and scale your project with ease.
Manage multiple environments, visualize logs and traces, and keep your project running smoothly.
Real-time deployment status updates
You can see the deployment status in real-time in the Motia Cloud web interface
Deployment history
All recent deployments on your project are available in Motia Cloud UI. You can browse them
and promote them to be live in the environment.
Zero downtime deployments
Every deployment is an atomic deployment, this means that Motia Cloud creates a new infrastructure
with all the Message Queues system isolatedly for each deployment.
Why is this important?
No downtime deployments
Avoid backwards compatibility issues on message queues: Example, you can change a topic data structure
without worrying about breaking messages that are flowing during the deployment.
Instant rollbacks and roll up updates
With one button you can rollback to a previous deployment. This allows you to be confident
on deployments, if anything fails, quickly rollback to a previous stable version.
One-click deployment
Deploy your project from workbench to a live environment with one click.
Observability
Have the same experience you have with Workbench locally in cloud. Such as:
Logs visualization
Tracing tool
Logs visualization
You can see the logs of your project in the Motia Cloud web interface.
Tracing tool
Tracing tool to quickly visualize the flow of requests through the system.
Multiple environments support
Motia Cloud supports creating multiple environments for your projects.
Scalability
Horizontal scaling individually for each step
Retry mechanisms for event steps built-in (3 retries by default)
Learn how to deploy
Learn how to deploy your project to Motia Cloud in theDeploymentpage.
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
Deployment
Deploying your project to Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/features#multiple-environments-support =====

Features
Learn how to deploy your Motia Project to a live environment
Motia Cloud is the easiest way to deploy your Motia Project to a live environment.
Quickly deploy your project to a live environment with one click. Then confidently
roll up updates, roll back to a previous stable version, and scale your project with ease.
Manage multiple environments, visualize logs and traces, and keep your project running smoothly.
Real-time deployment status updates
You can see the deployment status in real-time in the Motia Cloud web interface
Deployment history
All recent deployments on your project are available in Motia Cloud UI. You can browse them
and promote them to be live in the environment.
Zero downtime deployments
Every deployment is an atomic deployment, this means that Motia Cloud creates a new infrastructure
with all the Message Queues system isolatedly for each deployment.
Why is this important?
No downtime deployments
Avoid backwards compatibility issues on message queues: Example, you can change a topic data structure
without worrying about breaking messages that are flowing during the deployment.
Instant rollbacks and roll up updates
With one button you can rollback to a previous deployment. This allows you to be confident
on deployments, if anything fails, quickly rollback to a previous stable version.
One-click deployment
Deploy your project from workbench to a live environment with one click.
Observability
Have the same experience you have with Workbench locally in cloud. Such as:
Logs visualization
Tracing tool
Logs visualization
You can see the logs of your project in the Motia Cloud web interface.
Tracing tool
Tracing tool to quickly visualize the flow of requests through the system.
Multiple environments support
Motia Cloud supports creating multiple environments for your projects.
Scalability
Horizontal scaling individually for each step
Retry mechanisms for event steps built-in (3 retries by default)
Learn how to deploy
Learn how to deploy your project to Motia Cloud in theDeploymentpage.
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
Deployment
Deploying your project to Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/features#scalability =====

Features
Learn how to deploy your Motia Project to a live environment
Motia Cloud is the easiest way to deploy your Motia Project to a live environment.
Quickly deploy your project to a live environment with one click. Then confidently
roll up updates, roll back to a previous stable version, and scale your project with ease.
Manage multiple environments, visualize logs and traces, and keep your project running smoothly.
Real-time deployment status updates
You can see the deployment status in real-time in the Motia Cloud web interface
Deployment history
All recent deployments on your project are available in Motia Cloud UI. You can browse them
and promote them to be live in the environment.
Zero downtime deployments
Every deployment is an atomic deployment, this means that Motia Cloud creates a new infrastructure
with all the Message Queues system isolatedly for each deployment.
Why is this important?
No downtime deployments
Avoid backwards compatibility issues on message queues: Example, you can change a topic data structure
without worrying about breaking messages that are flowing during the deployment.
Instant rollbacks and roll up updates
With one button you can rollback to a previous deployment. This allows you to be confident
on deployments, if anything fails, quickly rollback to a previous stable version.
One-click deployment
Deploy your project from workbench to a live environment with one click.
Observability
Have the same experience you have with Workbench locally in cloud. Such as:
Logs visualization
Tracing tool
Logs visualization
You can see the logs of your project in the Motia Cloud web interface.
Tracing tool
Tracing tool to quickly visualize the flow of requests through the system.
Multiple environments support
Motia Cloud supports creating multiple environments for your projects.
Scalability
Horizontal scaling individually for each step
Retry mechanisms for event steps built-in (3 retries by default)
Learn how to deploy
Learn how to deploy your project to Motia Cloud in theDeploymentpage.
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
Deployment
Deploying your project to Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/motia-cloud/features#learn-how-to-deploy =====

Features
Learn how to deploy your Motia Project to a live environment
Motia Cloud is the easiest way to deploy your Motia Project to a live environment.
Quickly deploy your project to a live environment with one click. Then confidently
roll up updates, roll back to a previous stable version, and scale your project with ease.
Manage multiple environments, visualize logs and traces, and keep your project running smoothly.
Real-time deployment status updates
You can see the deployment status in real-time in the Motia Cloud web interface
Deployment history
All recent deployments on your project are available in Motia Cloud UI. You can browse them
and promote them to be live in the environment.
Zero downtime deployments
Every deployment is an atomic deployment, this means that Motia Cloud creates a new infrastructure
with all the Message Queues system isolatedly for each deployment.
Why is this important?
No downtime deployments
Avoid backwards compatibility issues on message queues: Example, you can change a topic data structure
without worrying about breaking messages that are flowing during the deployment.
Instant rollbacks and roll up updates
With one button you can rollback to a previous deployment. This allows you to be confident
on deployments, if anything fails, quickly rollback to a previous stable version.
One-click deployment
Deploy your project from workbench to a live environment with one click.
Observability
Have the same experience you have with Workbench locally in cloud. Such as:
Logs visualization
Tracing tool
Logs visualization
You can see the logs of your project in the Motia Cloud web interface.
Tracing tool
Tracing tool to quickly visualize the flow of requests through the system.
Multiple environments support
Motia Cloud supports creating multiple environments for your projects.
Scalability
Horizontal scaling individually for each step
Retry mechanisms for event steps built-in (3 retries by default)
Learn how to deploy
Learn how to deploy your project to Motia Cloud in theDeploymentpage.
Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
Deployment
Deploying your project to Motia Cloud
On this page



===== https://www.motia.dev/docs/deployment-guide/self-hosted#quick-setup =====

Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
We provide a docker image that you can use to deploy your Motia project to production. You can use it as a base image and add your own customizations or use it as is.
Quick setup
npxmotia@latestdockersetup
npxmotia@latestdockersetup
npxmotia@latestdockerrun
npxmotia@latestdockerrun
npxmotia@latestdockerrun--help
npxmotia@latestdockerrun--help
Reference theCLIfor more information on the docker commands.
Using the docker image
You will need to implement your own Dockerfile where you will use the motia-docker image as a base image. Use the following template as a starting point for your Dockerfile:
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
Depending on the cloud provider you will use to deploy your Motia project, you will need to adjust the exposed ports
and the command to start your application.
Create a .dockerignore file
Create a .dockerignore file in the root of your project to exclude files that are not needed in the docker image. You can use the following template as a starting point for your .dockerignore file:
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
Build your image
dockerbuild-t<your-image-name>.
dockerbuild-t<your-image-name>.
Run your Motia application
Once you've built your image, you can run it using the following command:
dockerrun-it--rm-p3000:3000<your-image-name>
dockerrun-it--rm-p3000:3000<your-image-name>
Motia Docker Resources
Docker Registry
Github Repo
Example Motia project with deployment boilerplate for AWS LightSail and Railway
Getting Started
Learn how to deploy your Motia project to production
Features
Learn how to deploy your Motia Project to a live environment
On this page



===== https://www.motia.dev/docs/deployment-guide/self-hosted#setup-your-motia-project =====

Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
We provide a docker image that you can use to deploy your Motia project to production. You can use it as a base image and add your own customizations or use it as is.
Quick setup
npxmotia@latestdockersetup
npxmotia@latestdockersetup
npxmotia@latestdockerrun
npxmotia@latestdockerrun
npxmotia@latestdockerrun--help
npxmotia@latestdockerrun--help
Reference theCLIfor more information on the docker commands.
Using the docker image
You will need to implement your own Dockerfile where you will use the motia-docker image as a base image. Use the following template as a starting point for your Dockerfile:
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
Depending on the cloud provider you will use to deploy your Motia project, you will need to adjust the exposed ports
and the command to start your application.
Create a .dockerignore file
Create a .dockerignore file in the root of your project to exclude files that are not needed in the docker image. You can use the following template as a starting point for your .dockerignore file:
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
Build your image
dockerbuild-t<your-image-name>.
dockerbuild-t<your-image-name>.
Run your Motia application
Once you've built your image, you can run it using the following command:
dockerrun-it--rm-p3000:3000<your-image-name>
dockerrun-it--rm-p3000:3000<your-image-name>
Motia Docker Resources
Docker Registry
Github Repo
Example Motia project with deployment boilerplate for AWS LightSail and Railway
Getting Started
Learn how to deploy your Motia project to production
Features
Learn how to deploy your Motia Project to a live environment
On this page



===== https://www.motia.dev/docs/deployment-guide/self-hosted#run-your-motia-project-inside-a-container =====

Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
We provide a docker image that you can use to deploy your Motia project to production. You can use it as a base image and add your own customizations or use it as is.
Quick setup
npxmotia@latestdockersetup
npxmotia@latestdockersetup
npxmotia@latestdockerrun
npxmotia@latestdockerrun
npxmotia@latestdockerrun--help
npxmotia@latestdockerrun--help
Reference theCLIfor more information on the docker commands.
Using the docker image
You will need to implement your own Dockerfile where you will use the motia-docker image as a base image. Use the following template as a starting point for your Dockerfile:
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
Depending on the cloud provider you will use to deploy your Motia project, you will need to adjust the exposed ports
and the command to start your application.
Create a .dockerignore file
Create a .dockerignore file in the root of your project to exclude files that are not needed in the docker image. You can use the following template as a starting point for your .dockerignore file:
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
Build your image
dockerbuild-t<your-image-name>.
dockerbuild-t<your-image-name>.
Run your Motia application
Once you've built your image, you can run it using the following command:
dockerrun-it--rm-p3000:3000<your-image-name>
dockerrun-it--rm-p3000:3000<your-image-name>
Motia Docker Resources
Docker Registry
Github Repo
Example Motia project with deployment boilerplate for AWS LightSail and Railway
Getting Started
Learn how to deploy your Motia project to production
Features
Learn how to deploy your Motia Project to a live environment
On this page



===== https://www.motia.dev/docs/deployment-guide/self-hosted#you-are-good-to-go-your-project-should-be-running-on-localhost-under-port-3000-for-additional-options-and-configuration-run =====

Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
We provide a docker image that you can use to deploy your Motia project to production. You can use it as a base image and add your own customizations or use it as is.
Quick setup
npxmotia@latestdockersetup
npxmotia@latestdockersetup
npxmotia@latestdockerrun
npxmotia@latestdockerrun
npxmotia@latestdockerrun--help
npxmotia@latestdockerrun--help
Reference theCLIfor more information on the docker commands.
Using the docker image
You will need to implement your own Dockerfile where you will use the motia-docker image as a base image. Use the following template as a starting point for your Dockerfile:
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
Depending on the cloud provider you will use to deploy your Motia project, you will need to adjust the exposed ports
and the command to start your application.
Create a .dockerignore file
Create a .dockerignore file in the root of your project to exclude files that are not needed in the docker image. You can use the following template as a starting point for your .dockerignore file:
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
Build your image
dockerbuild-t<your-image-name>.
dockerbuild-t<your-image-name>.
Run your Motia application
Once you've built your image, you can run it using the following command:
dockerrun-it--rm-p3000:3000<your-image-name>
dockerrun-it--rm-p3000:3000<your-image-name>
Motia Docker Resources
Docker Registry
Github Repo
Example Motia project with deployment boilerplate for AWS LightSail and Railway
Getting Started
Learn how to deploy your Motia project to production
Features
Learn how to deploy your Motia Project to a live environment
On this page



===== https://www.motia.dev/docs/concepts/cli#docker =====





===== https://www.motia.dev/docs/deployment-guide/self-hosted#using-the-docker-image =====

Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
We provide a docker image that you can use to deploy your Motia project to production. You can use it as a base image and add your own customizations or use it as is.
Quick setup
npxmotia@latestdockersetup
npxmotia@latestdockersetup
npxmotia@latestdockerrun
npxmotia@latestdockerrun
npxmotia@latestdockerrun--help
npxmotia@latestdockerrun--help
Reference theCLIfor more information on the docker commands.
Using the docker image
You will need to implement your own Dockerfile where you will use the motia-docker image as a base image. Use the following template as a starting point for your Dockerfile:
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
Depending on the cloud provider you will use to deploy your Motia project, you will need to adjust the exposed ports
and the command to start your application.
Create a .dockerignore file
Create a .dockerignore file in the root of your project to exclude files that are not needed in the docker image. You can use the following template as a starting point for your .dockerignore file:
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
Build your image
dockerbuild-t<your-image-name>.
dockerbuild-t<your-image-name>.
Run your Motia application
Once you've built your image, you can run it using the following command:
dockerrun-it--rm-p3000:3000<your-image-name>
dockerrun-it--rm-p3000:3000<your-image-name>
Motia Docker Resources
Docker Registry
Github Repo
Example Motia project with deployment boilerplate for AWS LightSail and Railway
Getting Started
Learn how to deploy your Motia project to production
Features
Learn how to deploy your Motia Project to a live environment
On this page



===== https://www.motia.dev/docs/deployment-guide/self-hosted#create-a-dockerignore-file =====

Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
We provide a docker image that you can use to deploy your Motia project to production. You can use it as a base image and add your own customizations or use it as is.
Quick setup
npxmotia@latestdockersetup
npxmotia@latestdockersetup
npxmotia@latestdockerrun
npxmotia@latestdockerrun
npxmotia@latestdockerrun--help
npxmotia@latestdockerrun--help
Reference theCLIfor more information on the docker commands.
Using the docker image
You will need to implement your own Dockerfile where you will use the motia-docker image as a base image. Use the following template as a starting point for your Dockerfile:
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
Depending on the cloud provider you will use to deploy your Motia project, you will need to adjust the exposed ports
and the command to start your application.
Create a .dockerignore file
Create a .dockerignore file in the root of your project to exclude files that are not needed in the docker image. You can use the following template as a starting point for your .dockerignore file:
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
Build your image
dockerbuild-t<your-image-name>.
dockerbuild-t<your-image-name>.
Run your Motia application
Once you've built your image, you can run it using the following command:
dockerrun-it--rm-p3000:3000<your-image-name>
dockerrun-it--rm-p3000:3000<your-image-name>
Motia Docker Resources
Docker Registry
Github Repo
Example Motia project with deployment boilerplate for AWS LightSail and Railway
Getting Started
Learn how to deploy your Motia project to production
Features
Learn how to deploy your Motia Project to a live environment
On this page



===== https://www.motia.dev/docs/deployment-guide/self-hosted#build-your-image =====

Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
We provide a docker image that you can use to deploy your Motia project to production. You can use it as a base image and add your own customizations or use it as is.
Quick setup
npxmotia@latestdockersetup
npxmotia@latestdockersetup
npxmotia@latestdockerrun
npxmotia@latestdockerrun
npxmotia@latestdockerrun--help
npxmotia@latestdockerrun--help
Reference theCLIfor more information on the docker commands.
Using the docker image
You will need to implement your own Dockerfile where you will use the motia-docker image as a base image. Use the following template as a starting point for your Dockerfile:
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
Depending on the cloud provider you will use to deploy your Motia project, you will need to adjust the exposed ports
and the command to start your application.
Create a .dockerignore file
Create a .dockerignore file in the root of your project to exclude files that are not needed in the docker image. You can use the following template as a starting point for your .dockerignore file:
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
Build your image
dockerbuild-t<your-image-name>.
dockerbuild-t<your-image-name>.
Run your Motia application
Once you've built your image, you can run it using the following command:
dockerrun-it--rm-p3000:3000<your-image-name>
dockerrun-it--rm-p3000:3000<your-image-name>
Motia Docker Resources
Docker Registry
Github Repo
Example Motia project with deployment boilerplate for AWS LightSail and Railway
Getting Started
Learn how to deploy your Motia project to production
Features
Learn how to deploy your Motia Project to a live environment
On this page



===== https://www.motia.dev/docs/deployment-guide/self-hosted#run-your-motia-application =====

Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
We provide a docker image that you can use to deploy your Motia project to production. You can use it as a base image and add your own customizations or use it as is.
Quick setup
npxmotia@latestdockersetup
npxmotia@latestdockersetup
npxmotia@latestdockerrun
npxmotia@latestdockerrun
npxmotia@latestdockerrun--help
npxmotia@latestdockerrun--help
Reference theCLIfor more information on the docker commands.
Using the docker image
You will need to implement your own Dockerfile where you will use the motia-docker image as a base image. Use the following template as a starting point for your Dockerfile:
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
Depending on the cloud provider you will use to deploy your Motia project, you will need to adjust the exposed ports
and the command to start your application.
Create a .dockerignore file
Create a .dockerignore file in the root of your project to exclude files that are not needed in the docker image. You can use the following template as a starting point for your .dockerignore file:
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
Build your image
dockerbuild-t<your-image-name>.
dockerbuild-t<your-image-name>.
Run your Motia application
Once you've built your image, you can run it using the following command:
dockerrun-it--rm-p3000:3000<your-image-name>
dockerrun-it--rm-p3000:3000<your-image-name>
Motia Docker Resources
Docker Registry
Github Repo
Example Motia project with deployment boilerplate for AWS LightSail and Railway
Getting Started
Learn how to deploy your Motia project to production
Features
Learn how to deploy your Motia Project to a live environment
On this page



===== https://www.motia.dev/docs/deployment-guide/self-hosted#motia-docker-resources =====

Self-Hosted Deployment
Learn how to deploy your Motia project to production using motia-docker
We provide a docker image that you can use to deploy your Motia project to production. You can use it as a base image and add your own customizations or use it as is.
Quick setup
npxmotia@latestdockersetup
npxmotia@latestdockersetup
npxmotia@latestdockerrun
npxmotia@latestdockerrun
npxmotia@latestdockerrun--help
npxmotia@latestdockerrun--help
Reference theCLIfor more information on the docker commands.
Using the docker image
You will need to implement your own Dockerfile where you will use the motia-docker image as a base image. Use the following template as a starting point for your Dockerfile:
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
# NOTE: Some cloud providers will require you to specify the platform to match your target architecture# i.e.: AWS Lightsail requires arm64, therefore you update your FROM statement to: FROM --platform=linux/arm64 motiadev/motia:latestFROMmotiadev/motia:latest# Install DependenciesCOPYpackage*.json ./RUNnpm ci --only=production# Move application filesCOPY. .# Enable the following lines if you are using python steps!!!# Setup python steps dependencies# RUN npx motia@latest install# Expose outside access to the motia projectEXPOSE3000# Run your applicationCMD["npm","run","start"]
Depending on the cloud provider you will use to deploy your Motia project, you will need to adjust the exposed ports
and the command to start your application.
Create a .dockerignore file
Create a .dockerignore file in the root of your project to exclude files that are not needed in the docker image. You can use the following template as a starting point for your .dockerignore file:
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
# Git.git.gitignore# Python__pycache__/*.py[cod]*$py.class*.so.Pythonenv/venv/ENV/# Nodenode_modules/npm-debug.logyarn-debug.logyarn-error.log# IDE.vscode/.idea/*.swp*.swo# Local development.env# OS generated files.DS_Store.DS_Store?._*.Spotlight-V100.Trashesehthumbs.dbThumbs.db
Build your image
dockerbuild-t<your-image-name>.
dockerbuild-t<your-image-name>.
Run your Motia application
Once you've built your image, you can run it using the following command:
dockerrun-it--rm-p3000:3000<your-image-name>
dockerrun-it--rm-p3000:3000<your-image-name>
Motia Docker Resources
Docker Registry
Github Repo
Example Motia project with deployment boilerplate for AWS LightSail and Railway
Getting Started
Learn how to deploy your Motia project to production
Features
Learn how to deploy your Motia Project to a live environment
On this page



===== https://www.motia.dev/docs/concepts/deployment/motia-cloud/features =====





===== https://www.motia.dev/docs/concepts/deployment/self-hosted =====





===== https://www.motia.dev/docs/development-guide/environment-variables#environment-variables =====

Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Environment Variables
Environment variables let you store API keys, database URLs, and other configuration outside your code. This keeps sensitive information secure and makes it easy to use different settings for development and production.
Quick Setup
1. Create a.envFile
.env
Create a.envfile in your project root:
.env
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
2. Add to.gitignore
.gitignore
Make sure you never commit your.envfile:
.env
.env.env.local
.env.env.local
3. Create Template for Your Team
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
Using Environment Variables in Steps
TypeScript/JavaScript
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
Python
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
Deployment
When you deploy your app, set environment variables through your hosting platform:
Motia Cloud
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
Important Security Tips
🔒 Keep Your Keys Safe
Never commit.envfiles to git
.env
Use different API keys for development and production
Don't share API keys in code or messages
That's it! Environment variables are simple - just put them in.envand useprocess.env.VARIABLE_NAMEin your code.
.env
process.env.VARIABLE_NAME
Testing
Learn how to write and run tests for your Motia components
Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
On this page
.env
.gitignore



===== https://www.motia.dev/docs/development-guide/environment-variables#quick-setup =====

Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Environment Variables
Environment variables let you store API keys, database URLs, and other configuration outside your code. This keeps sensitive information secure and makes it easy to use different settings for development and production.
Quick Setup
1. Create a.envFile
.env
Create a.envfile in your project root:
.env
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
2. Add to.gitignore
.gitignore
Make sure you never commit your.envfile:
.env
.env.env.local
.env.env.local
3. Create Template for Your Team
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
Using Environment Variables in Steps
TypeScript/JavaScript
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
Python
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
Deployment
When you deploy your app, set environment variables through your hosting platform:
Motia Cloud
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
Important Security Tips
🔒 Keep Your Keys Safe
Never commit.envfiles to git
.env
Use different API keys for development and production
Don't share API keys in code or messages
That's it! Environment variables are simple - just put them in.envand useprocess.env.VARIABLE_NAMEin your code.
.env
process.env.VARIABLE_NAME
Testing
Learn how to write and run tests for your Motia components
Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
On this page
.env
.gitignore



===== https://www.motia.dev/docs/development-guide/environment-variables#1-create-a-env-file =====

Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Environment Variables
Environment variables let you store API keys, database URLs, and other configuration outside your code. This keeps sensitive information secure and makes it easy to use different settings for development and production.
Quick Setup
1. Create a.envFile
.env
Create a.envfile in your project root:
.env
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
2. Add to.gitignore
.gitignore
Make sure you never commit your.envfile:
.env
.env.env.local
.env.env.local
3. Create Template for Your Team
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
Using Environment Variables in Steps
TypeScript/JavaScript
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
Python
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
Deployment
When you deploy your app, set environment variables through your hosting platform:
Motia Cloud
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
Important Security Tips
🔒 Keep Your Keys Safe
Never commit.envfiles to git
.env
Use different API keys for development and production
Don't share API keys in code or messages
That's it! Environment variables are simple - just put them in.envand useprocess.env.VARIABLE_NAMEin your code.
.env
process.env.VARIABLE_NAME
Testing
Learn how to write and run tests for your Motia components
Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
On this page
.env
.gitignore



===== https://www.motia.dev/docs/development-guide/environment-variables#2-add-to-gitignore =====

Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Environment Variables
Environment variables let you store API keys, database URLs, and other configuration outside your code. This keeps sensitive information secure and makes it easy to use different settings for development and production.
Quick Setup
1. Create a.envFile
.env
Create a.envfile in your project root:
.env
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
2. Add to.gitignore
.gitignore
Make sure you never commit your.envfile:
.env
.env.env.local
.env.env.local
3. Create Template for Your Team
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
Using Environment Variables in Steps
TypeScript/JavaScript
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
Python
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
Deployment
When you deploy your app, set environment variables through your hosting platform:
Motia Cloud
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
Important Security Tips
🔒 Keep Your Keys Safe
Never commit.envfiles to git
.env
Use different API keys for development and production
Don't share API keys in code or messages
That's it! Environment variables are simple - just put them in.envand useprocess.env.VARIABLE_NAMEin your code.
.env
process.env.VARIABLE_NAME
Testing
Learn how to write and run tests for your Motia components
Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
On this page
.env
.gitignore



===== https://www.motia.dev/docs/development-guide/environment-variables#3-create-template-for-your-team =====

Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Environment Variables
Environment variables let you store API keys, database URLs, and other configuration outside your code. This keeps sensitive information secure and makes it easy to use different settings for development and production.
Quick Setup
1. Create a.envFile
.env
Create a.envfile in your project root:
.env
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
2. Add to.gitignore
.gitignore
Make sure you never commit your.envfile:
.env
.env.env.local
.env.env.local
3. Create Template for Your Team
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
Using Environment Variables in Steps
TypeScript/JavaScript
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
Python
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
Deployment
When you deploy your app, set environment variables through your hosting platform:
Motia Cloud
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
Important Security Tips
🔒 Keep Your Keys Safe
Never commit.envfiles to git
.env
Use different API keys for development and production
Don't share API keys in code or messages
That's it! Environment variables are simple - just put them in.envand useprocess.env.VARIABLE_NAMEin your code.
.env
process.env.VARIABLE_NAME
Testing
Learn how to write and run tests for your Motia components
Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
On this page
.env
.gitignore



===== https://www.motia.dev/docs/development-guide/environment-variables#using-environment-variables-in-steps =====

Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Environment Variables
Environment variables let you store API keys, database URLs, and other configuration outside your code. This keeps sensitive information secure and makes it easy to use different settings for development and production.
Quick Setup
1. Create a.envFile
.env
Create a.envfile in your project root:
.env
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
2. Add to.gitignore
.gitignore
Make sure you never commit your.envfile:
.env
.env.env.local
.env.env.local
3. Create Template for Your Team
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
Using Environment Variables in Steps
TypeScript/JavaScript
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
Python
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
Deployment
When you deploy your app, set environment variables through your hosting platform:
Motia Cloud
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
Important Security Tips
🔒 Keep Your Keys Safe
Never commit.envfiles to git
.env
Use different API keys for development and production
Don't share API keys in code or messages
That's it! Environment variables are simple - just put them in.envand useprocess.env.VARIABLE_NAMEin your code.
.env
process.env.VARIABLE_NAME
Testing
Learn how to write and run tests for your Motia components
Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
On this page
.env
.gitignore



===== https://www.motia.dev/docs/development-guide/environment-variables#typescriptjavascript =====

Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Environment Variables
Environment variables let you store API keys, database URLs, and other configuration outside your code. This keeps sensitive information secure and makes it easy to use different settings for development and production.
Quick Setup
1. Create a.envFile
.env
Create a.envfile in your project root:
.env
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
2. Add to.gitignore
.gitignore
Make sure you never commit your.envfile:
.env
.env.env.local
.env.env.local
3. Create Template for Your Team
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
Using Environment Variables in Steps
TypeScript/JavaScript
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
Python
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
Deployment
When you deploy your app, set environment variables through your hosting platform:
Motia Cloud
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
Important Security Tips
🔒 Keep Your Keys Safe
Never commit.envfiles to git
.env
Use different API keys for development and production
Don't share API keys in code or messages
That's it! Environment variables are simple - just put them in.envand useprocess.env.VARIABLE_NAMEin your code.
.env
process.env.VARIABLE_NAME
Testing
Learn how to write and run tests for your Motia components
Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
On this page
.env
.gitignore



===== https://www.motia.dev/docs/development-guide/environment-variables#python =====

Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Environment Variables
Environment variables let you store API keys, database URLs, and other configuration outside your code. This keeps sensitive information secure and makes it easy to use different settings for development and production.
Quick Setup
1. Create a.envFile
.env
Create a.envfile in your project root:
.env
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
2. Add to.gitignore
.gitignore
Make sure you never commit your.envfile:
.env
.env.env.local
.env.env.local
3. Create Template for Your Team
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
Using Environment Variables in Steps
TypeScript/JavaScript
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
Python
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
Deployment
When you deploy your app, set environment variables through your hosting platform:
Motia Cloud
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
Important Security Tips
🔒 Keep Your Keys Safe
Never commit.envfiles to git
.env
Use different API keys for development and production
Don't share API keys in code or messages
That's it! Environment variables are simple - just put them in.envand useprocess.env.VARIABLE_NAMEin your code.
.env
process.env.VARIABLE_NAME
Testing
Learn how to write and run tests for your Motia components
Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
On this page
.env
.gitignore



===== https://www.motia.dev/docs/development-guide/environment-variables#deployment =====

Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Environment Variables
Environment variables let you store API keys, database URLs, and other configuration outside your code. This keeps sensitive information secure and makes it easy to use different settings for development and production.
Quick Setup
1. Create a.envFile
.env
Create a.envfile in your project root:
.env
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
2. Add to.gitignore
.gitignore
Make sure you never commit your.envfile:
.env
.env.env.local
.env.env.local
3. Create Template for Your Team
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
Using Environment Variables in Steps
TypeScript/JavaScript
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
Python
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
Deployment
When you deploy your app, set environment variables through your hosting platform:
Motia Cloud
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
Important Security Tips
🔒 Keep Your Keys Safe
Never commit.envfiles to git
.env
Use different API keys for development and production
Don't share API keys in code or messages
That's it! Environment variables are simple - just put them in.envand useprocess.env.VARIABLE_NAMEin your code.
.env
process.env.VARIABLE_NAME
Testing
Learn how to write and run tests for your Motia components
Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
On this page
.env
.gitignore



===== https://www.motia.dev/docs/development-guide/environment-variables#motia-cloud =====

Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Environment Variables
Environment variables let you store API keys, database URLs, and other configuration outside your code. This keeps sensitive information secure and makes it easy to use different settings for development and production.
Quick Setup
1. Create a.envFile
.env
Create a.envfile in your project root:
.env
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
2. Add to.gitignore
.gitignore
Make sure you never commit your.envfile:
.env
.env.env.local
.env.env.local
3. Create Template for Your Team
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
Using Environment Variables in Steps
TypeScript/JavaScript
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
Python
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
Deployment
When you deploy your app, set environment variables through your hosting platform:
Motia Cloud
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
Important Security Tips
🔒 Keep Your Keys Safe
Never commit.envfiles to git
.env
Use different API keys for development and production
Don't share API keys in code or messages
That's it! Environment variables are simple - just put them in.envand useprocess.env.VARIABLE_NAMEin your code.
.env
process.env.VARIABLE_NAME
Testing
Learn how to write and run tests for your Motia components
Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
On this page
.env
.gitignore



===== https://www.motia.dev/docs/development-guide/environment-variables#important-security-tips =====

Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
Environment Variables
Environment variables let you store API keys, database URLs, and other configuration outside your code. This keeps sensitive information secure and makes it easy to use different settings for development and production.
Quick Setup
1. Create a.envFile
.env
Create a.envfile in your project root:
.env
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
# API KeysOPENAI_API_KEY=sk-your-api-key-hereDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook# DatabaseDATABASE_URL=postgresql://user:password@localhost:5432/myapp# App SettingsNODE_ENV=developmentPORT=3000
2. Add to.gitignore
.gitignore
Make sure you never commit your.envfile:
.env
.env.env.local
.env.env.local
3. Create Template for Your Team
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
# Copy this to .env and add your actual valuesOPENAI_API_KEY=your-api-key-hereDATABASE_URL=postgresql://user:password@localhost:5432/myapp
Using Environment Variables in Steps
TypeScript/JavaScript
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
exportconstconfig={type:'api',name:'chat-with-ai',path:'/chat',method:'POST'}exportconsthandler=async(req, {logger})=>{// Use environment variables with process.envconstapiKey=process.env.OPENAI_API_KEYconstwebhookUrl=process.env.DISCORD_WEBHOOK_URLif(!apiKey) {return{ status:400, body: { error:'Missing API key'} }}logger.info('Using OpenAI API', { hasKey:!!apiKey })// Your logic here...return{ status:200, body: { message:'Success!'} }}
Python
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
importosconfig={'type':'event','name':'process-data','subscribes': ['data.received']}asyncdefhandler(input_data, ctx):# Use environment variables with os.environapi_key=os.environ.get('OPENAI_API_KEY')database_url=os.environ.get('DATABASE_URL')ifnotapi_key:raiseValueError('Missing OPENAI_API_KEY')ctx.logger.info('Processing with API key', {'has_key':bool(api_key)})# Your logic here...return{'status':'processed'}
Deployment
When you deploy your app, set environment variables through your hosting platform:
Motia Cloud
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
motiaenvsetOPENAI_API_KEY=sk-your-production-keymotiaenvsetNODE_ENV=production
Important Security Tips
🔒 Keep Your Keys Safe
Never commit.envfiles to git
.env
Use different API keys for development and production
Don't share API keys in code or messages
That's it! Environment variables are simple - just put them in.envand useprocess.env.VARIABLE_NAMEin your code.
.env
process.env.VARIABLE_NAME
Testing
Learn how to write and run tests for your Motia components
Command Line Interface (CLI)
Learn how to use the Motia CLI to manage your projects and workflows
On this page
.env
.gitignore



===== https://www.motia.dev/docs/development-guide/testing#testing =====

Testing
Learn how to write and run tests for your Motia components
Testing
Testing is an essential part of building reliable and maintainable Motia applications. Motia provides built-in support for writing and running tests to ensure the correctness of your steps, flows, and event handling logic.
Writing Tests for Motia Components
Motia usesJestas its testing framework. You can write tests for your Motia components using Jest's syntax and assertions.
Step Tests
To test a step, create a test file with the same name as the step file, but with a.test.tsor.test.jsextension. For example, if your step file is namedmy-step.step.ts, create a test file namedmy-step.step.test.ts.
.test.ts
.test.js
my-step.step.ts
my-step.step.test.ts
Here's an example of a step test:
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
In this example, we use thecreateTestContextfunction from@motiadev/testingto create a test context with mockedemitanddonefunctions. We then call the step'shandlerfunction with test input and the mocked context. Finally, we assert that theemitfunction was called with the expected event type and data.
createTestContext
@motiadev/testing
emit
done
handler
emit
Flow Tests
To test a flow, create a test file with the flow name and a.test.tsor.test.jsextension. For example, if your flow is namedmy-flow, create a test file namedmy-flow.test.ts.
.test.ts
.test.js
my-flow
my-flow.test.ts
Here's an example of a flow test:
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
In this example, we use thecreateTestFlowfunction from@motiadev/testingto create a test flow with the specified steps. We then execute the flow with test input and assert that the final result matches the expected output.
createTestFlow
@motiadev/testing
Running Tests Locally
To run tests locally, use the following command:
pnpmtest
pnpmtest
This command will run all the test files in your project and display the test results in the terminal.
You can also run tests in watch mode, which automatically re-runs the tests whenever you make changes to your code:
pnpmtest--watch
pnpmtest--watch
Best Practices
Write tests for each step and flow to ensure comprehensive coverage.
Use meaningful test case descriptions to clarify the purpose of each test.
Test edge cases and error scenarios to ensure your components handle them gracefully.
Keep your tests focused and independent to make them easier to maintain.
Use mocks and stubs to isolate dependencies and improve test reliability.
By following these best practices and regularly running tests, you can catch bugs early, maintain code quality, and ensure the reliability of your Motia application.
Middleware
Run code before and after your API handlers
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
On this page



===== https://www.motia.dev/docs/development-guide/testing#writing-tests-for-motia-components =====

Testing
Learn how to write and run tests for your Motia components
Testing
Testing is an essential part of building reliable and maintainable Motia applications. Motia provides built-in support for writing and running tests to ensure the correctness of your steps, flows, and event handling logic.
Writing Tests for Motia Components
Motia usesJestas its testing framework. You can write tests for your Motia components using Jest's syntax and assertions.
Step Tests
To test a step, create a test file with the same name as the step file, but with a.test.tsor.test.jsextension. For example, if your step file is namedmy-step.step.ts, create a test file namedmy-step.step.test.ts.
.test.ts
.test.js
my-step.step.ts
my-step.step.test.ts
Here's an example of a step test:
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
In this example, we use thecreateTestContextfunction from@motiadev/testingto create a test context with mockedemitanddonefunctions. We then call the step'shandlerfunction with test input and the mocked context. Finally, we assert that theemitfunction was called with the expected event type and data.
createTestContext
@motiadev/testing
emit
done
handler
emit
Flow Tests
To test a flow, create a test file with the flow name and a.test.tsor.test.jsextension. For example, if your flow is namedmy-flow, create a test file namedmy-flow.test.ts.
.test.ts
.test.js
my-flow
my-flow.test.ts
Here's an example of a flow test:
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
In this example, we use thecreateTestFlowfunction from@motiadev/testingto create a test flow with the specified steps. We then execute the flow with test input and assert that the final result matches the expected output.
createTestFlow
@motiadev/testing
Running Tests Locally
To run tests locally, use the following command:
pnpmtest
pnpmtest
This command will run all the test files in your project and display the test results in the terminal.
You can also run tests in watch mode, which automatically re-runs the tests whenever you make changes to your code:
pnpmtest--watch
pnpmtest--watch
Best Practices
Write tests for each step and flow to ensure comprehensive coverage.
Use meaningful test case descriptions to clarify the purpose of each test.
Test edge cases and error scenarios to ensure your components handle them gracefully.
Keep your tests focused and independent to make them easier to maintain.
Use mocks and stubs to isolate dependencies and improve test reliability.
By following these best practices and regularly running tests, you can catch bugs early, maintain code quality, and ensure the reliability of your Motia application.
Middleware
Run code before and after your API handlers
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
On this page



===== https://www.motia.dev/docs/development-guide/testing#step-tests =====

Testing
Learn how to write and run tests for your Motia components
Testing
Testing is an essential part of building reliable and maintainable Motia applications. Motia provides built-in support for writing and running tests to ensure the correctness of your steps, flows, and event handling logic.
Writing Tests for Motia Components
Motia usesJestas its testing framework. You can write tests for your Motia components using Jest's syntax and assertions.
Step Tests
To test a step, create a test file with the same name as the step file, but with a.test.tsor.test.jsextension. For example, if your step file is namedmy-step.step.ts, create a test file namedmy-step.step.test.ts.
.test.ts
.test.js
my-step.step.ts
my-step.step.test.ts
Here's an example of a step test:
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
In this example, we use thecreateTestContextfunction from@motiadev/testingto create a test context with mockedemitanddonefunctions. We then call the step'shandlerfunction with test input and the mocked context. Finally, we assert that theemitfunction was called with the expected event type and data.
createTestContext
@motiadev/testing
emit
done
handler
emit
Flow Tests
To test a flow, create a test file with the flow name and a.test.tsor.test.jsextension. For example, if your flow is namedmy-flow, create a test file namedmy-flow.test.ts.
.test.ts
.test.js
my-flow
my-flow.test.ts
Here's an example of a flow test:
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
In this example, we use thecreateTestFlowfunction from@motiadev/testingto create a test flow with the specified steps. We then execute the flow with test input and assert that the final result matches the expected output.
createTestFlow
@motiadev/testing
Running Tests Locally
To run tests locally, use the following command:
pnpmtest
pnpmtest
This command will run all the test files in your project and display the test results in the terminal.
You can also run tests in watch mode, which automatically re-runs the tests whenever you make changes to your code:
pnpmtest--watch
pnpmtest--watch
Best Practices
Write tests for each step and flow to ensure comprehensive coverage.
Use meaningful test case descriptions to clarify the purpose of each test.
Test edge cases and error scenarios to ensure your components handle them gracefully.
Keep your tests focused and independent to make them easier to maintain.
Use mocks and stubs to isolate dependencies and improve test reliability.
By following these best practices and regularly running tests, you can catch bugs early, maintain code quality, and ensure the reliability of your Motia application.
Middleware
Run code before and after your API handlers
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
On this page



===== https://www.motia.dev/docs/development-guide/testing#flow-tests =====

Testing
Learn how to write and run tests for your Motia components
Testing
Testing is an essential part of building reliable and maintainable Motia applications. Motia provides built-in support for writing and running tests to ensure the correctness of your steps, flows, and event handling logic.
Writing Tests for Motia Components
Motia usesJestas its testing framework. You can write tests for your Motia components using Jest's syntax and assertions.
Step Tests
To test a step, create a test file with the same name as the step file, but with a.test.tsor.test.jsextension. For example, if your step file is namedmy-step.step.ts, create a test file namedmy-step.step.test.ts.
.test.ts
.test.js
my-step.step.ts
my-step.step.test.ts
Here's an example of a step test:
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
In this example, we use thecreateTestContextfunction from@motiadev/testingto create a test context with mockedemitanddonefunctions. We then call the step'shandlerfunction with test input and the mocked context. Finally, we assert that theemitfunction was called with the expected event type and data.
createTestContext
@motiadev/testing
emit
done
handler
emit
Flow Tests
To test a flow, create a test file with the flow name and a.test.tsor.test.jsextension. For example, if your flow is namedmy-flow, create a test file namedmy-flow.test.ts.
.test.ts
.test.js
my-flow
my-flow.test.ts
Here's an example of a flow test:
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
In this example, we use thecreateTestFlowfunction from@motiadev/testingto create a test flow with the specified steps. We then execute the flow with test input and assert that the final result matches the expected output.
createTestFlow
@motiadev/testing
Running Tests Locally
To run tests locally, use the following command:
pnpmtest
pnpmtest
This command will run all the test files in your project and display the test results in the terminal.
You can also run tests in watch mode, which automatically re-runs the tests whenever you make changes to your code:
pnpmtest--watch
pnpmtest--watch
Best Practices
Write tests for each step and flow to ensure comprehensive coverage.
Use meaningful test case descriptions to clarify the purpose of each test.
Test edge cases and error scenarios to ensure your components handle them gracefully.
Keep your tests focused and independent to make them easier to maintain.
Use mocks and stubs to isolate dependencies and improve test reliability.
By following these best practices and regularly running tests, you can catch bugs early, maintain code quality, and ensure the reliability of your Motia application.
Middleware
Run code before and after your API handlers
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
On this page



===== https://www.motia.dev/docs/development-guide/testing#running-tests-locally =====

Testing
Learn how to write and run tests for your Motia components
Testing
Testing is an essential part of building reliable and maintainable Motia applications. Motia provides built-in support for writing and running tests to ensure the correctness of your steps, flows, and event handling logic.
Writing Tests for Motia Components
Motia usesJestas its testing framework. You can write tests for your Motia components using Jest's syntax and assertions.
Step Tests
To test a step, create a test file with the same name as the step file, but with a.test.tsor.test.jsextension. For example, if your step file is namedmy-step.step.ts, create a test file namedmy-step.step.test.ts.
.test.ts
.test.js
my-step.step.ts
my-step.step.test.ts
Here's an example of a step test:
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
In this example, we use thecreateTestContextfunction from@motiadev/testingto create a test context with mockedemitanddonefunctions. We then call the step'shandlerfunction with test input and the mocked context. Finally, we assert that theemitfunction was called with the expected event type and data.
createTestContext
@motiadev/testing
emit
done
handler
emit
Flow Tests
To test a flow, create a test file with the flow name and a.test.tsor.test.jsextension. For example, if your flow is namedmy-flow, create a test file namedmy-flow.test.ts.
.test.ts
.test.js
my-flow
my-flow.test.ts
Here's an example of a flow test:
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
In this example, we use thecreateTestFlowfunction from@motiadev/testingto create a test flow with the specified steps. We then execute the flow with test input and assert that the final result matches the expected output.
createTestFlow
@motiadev/testing
Running Tests Locally
To run tests locally, use the following command:
pnpmtest
pnpmtest
This command will run all the test files in your project and display the test results in the terminal.
You can also run tests in watch mode, which automatically re-runs the tests whenever you make changes to your code:
pnpmtest--watch
pnpmtest--watch
Best Practices
Write tests for each step and flow to ensure comprehensive coverage.
Use meaningful test case descriptions to clarify the purpose of each test.
Test edge cases and error scenarios to ensure your components handle them gracefully.
Keep your tests focused and independent to make them easier to maintain.
Use mocks and stubs to isolate dependencies and improve test reliability.
By following these best practices and regularly running tests, you can catch bugs early, maintain code quality, and ensure the reliability of your Motia application.
Middleware
Run code before and after your API handlers
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
On this page



===== https://www.motia.dev/docs/development-guide/testing#best-practices =====

Testing
Learn how to write and run tests for your Motia components
Testing
Testing is an essential part of building reliable and maintainable Motia applications. Motia provides built-in support for writing and running tests to ensure the correctness of your steps, flows, and event handling logic.
Writing Tests for Motia Components
Motia usesJestas its testing framework. You can write tests for your Motia components using Jest's syntax and assertions.
Step Tests
To test a step, create a test file with the same name as the step file, but with a.test.tsor.test.jsextension. For example, if your step file is namedmy-step.step.ts, create a test file namedmy-step.step.test.ts.
.test.ts
.test.js
my-step.step.ts
my-step.step.test.ts
Here's an example of a step test:
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
// my-step.step.test.tsimport{ createTestContext }from'@motiadev/testing'import{ handler }from'./my-step.step'describe('MyStep', ()=>{it('should emit an event with the correct data',async()=>{const{emit,done}=createTestContext()awaithandler({ name:'John'}, { emit })expect(emit).toHaveBeenCalledWith({type:'my-event',data: { greeting:'Hello, John!'},})done()})})
In this example, we use thecreateTestContextfunction from@motiadev/testingto create a test context with mockedemitanddonefunctions. We then call the step'shandlerfunction with test input and the mocked context. Finally, we assert that theemitfunction was called with the expected event type and data.
createTestContext
@motiadev/testing
emit
done
handler
emit
Flow Tests
To test a flow, create a test file with the flow name and a.test.tsor.test.jsextension. For example, if your flow is namedmy-flow, create a test file namedmy-flow.test.ts.
.test.ts
.test.js
my-flow
my-flow.test.ts
Here's an example of a flow test:
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
// my-flow.test.tsimport{ createTestFlow }from'@motiadev/testing'import{ handlerasstepAHandler }from'./step-a.step'import{ handlerasstepBHandler }from'./step-b.step'describe('MyFlow', ()=>{it('should execute steps in the correct order',async()=>{constflow=createTestFlow('my-flow').step('step-a', stepAHandler).step('step-b', stepBHandler)constresult=awaitflow.execute({ name:'Alice'})expect(result).toEqual({greeting:'Hello, Alice!',message:'Welcome to Motia!',})})})
In this example, we use thecreateTestFlowfunction from@motiadev/testingto create a test flow with the specified steps. We then execute the flow with test input and assert that the final result matches the expected output.
createTestFlow
@motiadev/testing
Running Tests Locally
To run tests locally, use the following command:
pnpmtest
pnpmtest
This command will run all the test files in your project and display the test results in the terminal.
You can also run tests in watch mode, which automatically re-runs the tests whenever you make changes to your code:
pnpmtest--watch
pnpmtest--watch
Best Practices
Write tests for each step and flow to ensure comprehensive coverage.
Use meaningful test case descriptions to clarify the purpose of each test.
Test edge cases and error scenarios to ensure your components handle them gracefully.
Keep your tests focused and independent to make them easier to maintain.
Use mocks and stubs to isolate dependencies and improve test reliability.
By following these best practices and regularly running tests, you can catch bugs early, maintain code quality, and ensure the reliability of your Motia application.
Middleware
Run code before and after your API handlers
Environment Variables
Store API keys and configuration safely using .env files in your Motia apps.
On this page



===== https://www.motia.dev/docs/development-guide/middleware#what-is-middleware =====

Middleware
Run code before and after your API handlers
What is Middleware?
Middleware runs before your API handler. Use it for authentication, logging, error handling, or any logic that applies to multiple endpoints.
How It Works
A middleware is a function that receives three arguments:
middleware(req, ctx, next)
middleware(req, ctx, next)
req- The incoming request (same as handler)
ctx- The context object (same as handler)
next()- Call this to continue to the handler
If you don't callnext(), the request stops. The handler never runs.
next()
Simple Example
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
Execution Order
Middleware runs in the order you list them:
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
Modifying Responses
Awaitnext()to get the response, then modify it:
next()
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
Error Handling
Catch errors from handlers:
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
Reusing Middleware
Create middleware files in a shared location:
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
Import and use across steps:
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
What's Next?
Triggers
Learn more about Triggers
Testing
Learn more about testing your Motia Steps
Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Testing
Learn how to write and run tests for your Motia components
On this page



===== https://www.motia.dev/docs/development-guide/middleware#how-it-works =====

Middleware
Run code before and after your API handlers
What is Middleware?
Middleware runs before your API handler. Use it for authentication, logging, error handling, or any logic that applies to multiple endpoints.
How It Works
A middleware is a function that receives three arguments:
middleware(req, ctx, next)
middleware(req, ctx, next)
req- The incoming request (same as handler)
ctx- The context object (same as handler)
next()- Call this to continue to the handler
If you don't callnext(), the request stops. The handler never runs.
next()
Simple Example
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
Execution Order
Middleware runs in the order you list them:
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
Modifying Responses
Awaitnext()to get the response, then modify it:
next()
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
Error Handling
Catch errors from handlers:
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
Reusing Middleware
Create middleware files in a shared location:
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
Import and use across steps:
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
What's Next?
Triggers
Learn more about Triggers
Testing
Learn more about testing your Motia Steps
Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Testing
Learn how to write and run tests for your Motia components
On this page



===== https://www.motia.dev/docs/development-guide/middleware#simple-example =====

Middleware
Run code before and after your API handlers
What is Middleware?
Middleware runs before your API handler. Use it for authentication, logging, error handling, or any logic that applies to multiple endpoints.
How It Works
A middleware is a function that receives three arguments:
middleware(req, ctx, next)
middleware(req, ctx, next)
req- The incoming request (same as handler)
ctx- The context object (same as handler)
next()- Call this to continue to the handler
If you don't callnext(), the request stops. The handler never runs.
next()
Simple Example
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
Execution Order
Middleware runs in the order you list them:
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
Modifying Responses
Awaitnext()to get the response, then modify it:
next()
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
Error Handling
Catch errors from handlers:
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
Reusing Middleware
Create middleware files in a shared location:
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
Import and use across steps:
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
What's Next?
Triggers
Learn more about Triggers
Testing
Learn more about testing your Motia Steps
Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Testing
Learn how to write and run tests for your Motia components
On this page



===== https://www.motia.dev/docs/development-guide/middleware#execution-order =====

Middleware
Run code before and after your API handlers
What is Middleware?
Middleware runs before your API handler. Use it for authentication, logging, error handling, or any logic that applies to multiple endpoints.
How It Works
A middleware is a function that receives three arguments:
middleware(req, ctx, next)
middleware(req, ctx, next)
req- The incoming request (same as handler)
ctx- The context object (same as handler)
next()- Call this to continue to the handler
If you don't callnext(), the request stops. The handler never runs.
next()
Simple Example
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
Execution Order
Middleware runs in the order you list them:
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
Modifying Responses
Awaitnext()to get the response, then modify it:
next()
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
Error Handling
Catch errors from handlers:
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
Reusing Middleware
Create middleware files in a shared location:
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
Import and use across steps:
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
What's Next?
Triggers
Learn more about Triggers
Testing
Learn more about testing your Motia Steps
Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Testing
Learn how to write and run tests for your Motia components
On this page



===== https://www.motia.dev/docs/development-guide/middleware#modifying-responses =====

Middleware
Run code before and after your API handlers
What is Middleware?
Middleware runs before your API handler. Use it for authentication, logging, error handling, or any logic that applies to multiple endpoints.
How It Works
A middleware is a function that receives three arguments:
middleware(req, ctx, next)
middleware(req, ctx, next)
req- The incoming request (same as handler)
ctx- The context object (same as handler)
next()- Call this to continue to the handler
If you don't callnext(), the request stops. The handler never runs.
next()
Simple Example
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
Execution Order
Middleware runs in the order you list them:
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
Modifying Responses
Awaitnext()to get the response, then modify it:
next()
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
Error Handling
Catch errors from handlers:
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
Reusing Middleware
Create middleware files in a shared location:
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
Import and use across steps:
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
What's Next?
Triggers
Learn more about Triggers
Testing
Learn more about testing your Motia Steps
Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Testing
Learn how to write and run tests for your Motia components
On this page



===== https://www.motia.dev/docs/development-guide/middleware#error-handling =====

Middleware
Run code before and after your API handlers
What is Middleware?
Middleware runs before your API handler. Use it for authentication, logging, error handling, or any logic that applies to multiple endpoints.
How It Works
A middleware is a function that receives three arguments:
middleware(req, ctx, next)
middleware(req, ctx, next)
req- The incoming request (same as handler)
ctx- The context object (same as handler)
next()- Call this to continue to the handler
If you don't callnext(), the request stops. The handler never runs.
next()
Simple Example
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
Execution Order
Middleware runs in the order you list them:
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
Modifying Responses
Awaitnext()to get the response, then modify it:
next()
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
Error Handling
Catch errors from handlers:
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
Reusing Middleware
Create middleware files in a shared location:
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
Import and use across steps:
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
What's Next?
Triggers
Learn more about Triggers
Testing
Learn more about testing your Motia Steps
Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Testing
Learn how to write and run tests for your Motia components
On this page



===== https://www.motia.dev/docs/development-guide/middleware#reusing-middleware =====

Middleware
Run code before and after your API handlers
What is Middleware?
Middleware runs before your API handler. Use it for authentication, logging, error handling, or any logic that applies to multiple endpoints.
How It Works
A middleware is a function that receives three arguments:
middleware(req, ctx, next)
middleware(req, ctx, next)
req- The incoming request (same as handler)
ctx- The context object (same as handler)
next()- Call this to continue to the handler
If you don't callnext(), the request stops. The handler never runs.
next()
Simple Example
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
Execution Order
Middleware runs in the order you list them:
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
Modifying Responses
Awaitnext()to get the response, then modify it:
next()
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
Error Handling
Catch errors from handlers:
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
Reusing Middleware
Create middleware files in a shared location:
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
Import and use across steps:
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
What's Next?
Triggers
Learn more about Triggers
Testing
Learn more about testing your Motia Steps
Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Testing
Learn how to write and run tests for your Motia components
On this page



===== https://www.motia.dev/docs/development-guide/middleware#whats-next =====

Middleware
Run code before and after your API handlers
What is Middleware?
Middleware runs before your API handler. Use it for authentication, logging, error handling, or any logic that applies to multiple endpoints.
How It Works
A middleware is a function that receives three arguments:
middleware(req, ctx, next)
middleware(req, ctx, next)
req- The incoming request (same as handler)
ctx- The context object (same as handler)
next()- Call this to continue to the handler
If you don't callnext(), the request stops. The handler never runs.
next()
Simple Example
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
import{ ApiMiddleware }from'motia'constauthMiddleware:ApiMiddleware=async(req,ctx,next)=>{if(!req.headers.authorization) {return{ status:401, body: { error:'Unauthorized'} }}returnnext()}exportconstconfig={name:'ProtectedEndpoint',type:'api',path:'/protected',method:'GET',middleware: [authMiddleware]}exportconsthandler=async(req,ctx)=>{return{ status:200, body: { message:'Success'} }}
Execution Order
Middleware runs in the order you list them:
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
exportconstconfig={name:'MyEndpoint',type:'api',path:'/endpoint',method:'POST',middleware: [loggingMiddleware,// Runs firstauthMiddleware,// Runs seconderrorMiddleware// Runs third]}
Modifying Responses
Awaitnext()to get the response, then modify it:
next()
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
constaddHeadersMiddleware=async(req,ctx,next)=>{constresponse=awaitnext()return{...response,headers: {...response.headers,'X-Request-Id': ctx.traceId}}}
Error Handling
Catch errors from handlers:
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
import{ ZodError }from'zod'consterrorMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error:any) {if(errorinstanceofZodError) {ctx.logger.error('Validation error', { errors: error.errors })return{ status:400, body: { error:'Validation failed'} }}ctx.logger.error('Unexpected error', { error: error.message })return{ status:500, body: { error:'Internal server error'} }}}
Reusing Middleware
Create middleware files in a shared location:
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
exportconstcoreMiddleware=async(req,ctx,next)=>{try{returnawaitnext()}catch(error) {ctx.logger.error('Error', { error })return{ status:500, body: { error:'Internal server error'} }}}
Import and use across steps:
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
import{ coreMiddleware }from'../middlewares/core.middleware'exportconstconfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET',middleware: [coreMiddleware]}
What's Next?
Triggers
Learn more about Triggers
Testing
Learn more about testing your Motia Steps
Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Testing
Learn how to write and run tests for your Motia components
On this page



===== https://www.motia.dev/docs/concepts/steps#triggers =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#one-primitive-for-any-backend =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#the-simplest-example =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#steps-work-together-emit--subscribe =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#example-flow-api-step--event-step =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#api-trigger =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#context-object =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#core-functionality =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#state--persistent-data =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#logging--structured--contextual =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#streams--real-time-data =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#remember =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#whats-next =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#event-trigger =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/concepts/steps#cron-trigger =====

Steps
One primitive to build any backend. Simple, composable, and multi-language.
One Primitive for Any Backend
AStepis the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:how it runs, when it runs, where it runs, and what it does.
Every Step file contains two parts:
Config→ defines when and how the Step runs, and gives it a uniquename
name
Handler→ the function that executes your business logic
Motia automatically discovers any file ending in.step.ts,.step.js, or_step.py.The filename tells Motia to load it, and thenamein theconfiguniquely identifies the Step inside your system.
.step.ts
.step.js
_step.py
name
config
The Simplest Example
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'HelloStep',type:'api',path:'/hello',method:'GET'};exportconsthandler:Handlers['HelloStep']=async(req, {logger})=>{logger.info('Hello endpoint called');return{ status:200, body: { message:'Hello world!'} };};
👉 That’s all you need to make a running API endpoint.Motia will auto-discover this file and wire it into your backend.
Steps Work Together: Emit + Subscribe
Steps aren’t isolated. They communicate byemittingandsubscribingto events.This is the core of how you build backends with Motia.
Example Flow: API Step → Event Step
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ ApiRouteConfig, Handlers }from'motia';exportconstconfig:ApiRouteConfig={name:'SendMessage',type:'api',path:'/messages',method:'POST',emits: ['message.sent']};exportconsthandler:Handlers['SendMessage']=async(req, {emit})=>{awaitemit({topic:'message.sent',data: { text: req.body.text }});return{ status:200, body: { ok:true} };};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
import{ EventConfig, Handlers }from'motia';exportconstconfig:EventConfig={name:'ProcessMessage',type:'event',subscribes: ['message.sent']};exportconsthandler:Handlers['ProcessMessage']=async(input, {logger})=>{logger.info('Processing message', input);};
👉 With just two files, you have anAPI endpointthat triggers anevent-driven workflow.
Triggers
Every Step has atypethat defineshow it triggers:
type
api
event
cron
API Trigger
Runs when an HTTP request hits the path.
Example:
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
import{ ApiRouteConfig, Handlers }from'motia'exportconstconfig:ApiRouteConfig={name:'GetUser',type:'api',path:'/users/:id',method:'GET'}exportconsthandler:Handlers['GetUser']=async(req, {logger})=>{constuserId=req.pathParams.idlogger.info('Getting user', { userId })return{ status:200, body: { id: userId, name:'John'} }}
Config:
name
type
'api'
path
:params
method
bodySchema
Handler:handler(req, ctx)
handler(req, ctx)
req- Request withbody,headers,pathParams,queryParams
req
body
headers
pathParams
queryParams
ctx- Context withlogger,emit,state,streams,traceId
ctx
logger
emit
state
streams
traceId
Returns{ status, body, headers? }
{ status, body, headers? }
Context Object
Every handler receives actxobject with these tools:
ctx
logger
info
warn
error
emit
state
streams
traceId
Core Functionality
State – Persistent Data
Key-value storage shared across Steps and workflows.
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
awaitstate.set(traceId,'preferences', { theme:'dark'});constprefs=awaitstate.get(traceId,'preferences');
Logging – Structured & Contextual
For debugging, monitoring, and observability.
logger.info('Processing user', { userId:'123'});
logger.info('Processing user', { userId:'123'});
Streams – Real-Time Data
Push updates directly to connected clients.
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
awaitstreams.chat.set('room-123','msg-456', { text:'Hello!'});
Remember
Steps are just files.Export aconfigandhandler.
config
handler
Motia auto-discovers and connects them.
Combine Steps withemit + subscribeto build APIs, workflows, background jobs, or entire systems.
What’s Next?
👉Build your first app →
Overview
One primitive, any language, event-driven by default - that's Motia
Workbench
Visualize, test, and debug your Motia flows with the built-in development platform
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#customizing-flows =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#ui-steps =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#overview =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#basic-usage =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#available-components =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#complete-customization =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#important-notes =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#styling-guidelines =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#noop-steps =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#file-structure =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#step-configuration-file =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#ui-component-file =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#example-webhook-testing =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#representing-external-processes =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#webhook-callbacks =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#human-approvals =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#external-system-integration =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#best-practices =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page



===== https://www.motia.dev/docs/development-guide/customizing-flows#ui-steps-1 =====

Customizing Flows
Create custom visualizations and represent external processes in your Motia workflows
Customizing Flows
Motia Workbench allows you to customize how your Steps appear in the flow visualization tool. This helps you create intuitive, context-aware visual components that clearly communicate your flow's behavior and external dependencies.
UI Steps
UI Steps provide a way to create custom visual representations of your workflow Steps in the Workbench flow visualization tool.
Overview
To create a custom UI for a Step, create a.tsxor.jsxfile next to your Step file with the same base name:
.tsx
.jsx
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
steps/└── myStep/├── myStep.step.ts      # Step definition└── myStep.step.tsx     # Visual override
Basic Usage
Let's override an EventNode while keeping the same look. We'll add an image and show the description.
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
// myStep.step.tsximport{ EventNode, EventNodeProps }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<EventNode{...props}><divclassName="flex flex-row items-start gap-2"><divclassName="text-sm text-gray-400 font-mono">{props.data.description}</div><imgstyle={{ width:'64px', height:'64px'}}src="https://www.motia.dev/icon.png"/></div></EventNode>)}
Available Components
Motia Workbench provides out-of-the-box components for different Step types:
Complete Customization
You can fully customize your node to look completely different. Here's an example of a custom ideator agent node:
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
import{ BaseHandle, EventNodeProps, Position }from'motia/workbench'importReactfrom'react'exportconstNode:React.FC<EventNodeProps>=(props)=>{return(<divclassName="w-80 bg-black text-white rounded-xl p-4"><divclassName="group relative"><BaseHandletype="target"position={Position.Top}variant="event"/><divclassName="flex items-center space-x-3"><imgclassName="w-8 h-8"src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png"/><divclassName="text-lg font-semibold">{props.data.name}</div></div><divclassName="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Input</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">contentIdea:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">contentType:</div><divclassName="text-orange-500">string</div></div></div></div><divclassName="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full"><divclassName="flex items-center text-xs text-gray-400 space-x-2">Output</div><divclassName="flex flex-col gap-2 whitespace-pre-wrap font-mono"><divclassName="flex items-center gap-2"><divclassName="">topic:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">subtopics:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">keywords:</div><divclassName="text-orange-500">string[]</div></div><divclassName="flex items-center gap-2"><divclassName="">tone:</div><divclassName="text-orange-500">string</div></div><divclassName="flex items-center gap-2"><divclassName="">audience:</div><divclassName="text-orange-500">string</div></div></div></div><BaseHandletype="source"position={Position.Bottom}variant="event"/></div></div>)}
You will need to add<BaseHandle>to your node, otherwise it won't show the connectors.
<BaseHandle>
If your node has padding, make sure to add a group inside your node with classgroup relativeso the handles can be correctly positioned.
group relative
Styling Guidelines
NOOP Steps
NOOP (No Operation) Steps are a powerful feature that serve multiple purposes:
Modeling external processes, webhooks and integrations
Representing human-in-the-loop activities
Creating custom visualizations in the workbench
Testing flows during development
File Structure
NOOP Steps require two files with the same base name:
stepName.step.ts- Contains the step configuration
stepName.step.ts
stepName.step.tsx- Contains the UI component (optional)
stepName.step.tsx
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'My NOOP Step',description:'Description of what this step simulates',virtualEmits: ['event.one','event.two'],virtualSubscribes: [],// Required even if emptyflows: ['my-flow'],}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
// myStep.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionMyStep() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium">My StepUI</div><BaseHandle type="source"position={Position.Bottom}/></div>)}
Example: Webhook Testing
Here's a complete example of a NOOP Step that simulates webhook events:
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsimport{ NoopConfig }from'motia'exportconstconfig:NoopConfig={type:'noop',name:'Webhook Simulator',description:'Simulates incoming webhook events',virtualEmits: ['webhook.received'],virtualSubscribes: [],flows: ['webhook-flow'],}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
// test-webhook.step.tsximportReactfrom'react'import{ BaseHandle, Position }from'motia/workbench'exportdefaultfunctionWebhookSimulator() {return(<div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white"><div className="text-sm font-medium mb-2">Webhook Simulator</div><buttononClick={() => {fetch('/api/webhook', {method:'POST',headers: {'Content-Type':'application/json'},body:JSON.stringify({ event:'test'}),})}}className="px-3 py-1 bg-blue-600 rounded text-sm">TriggerWebhook</button><BaseHandle type="source"position={Position.Bottom}/></div>)}
Representing External Processes
NOOP Steps represent parts of your workflow that happen outside your system. Common examples include:
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Wait for Stripe Webhook',description:'Waits for payment confirmation',virtualSubscribes: ['payment.initiated'],virtualEmits: ['/api/stripe/webhook'],flows: ['payment'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'Manager Review',description:'Manager reviews request',virtualSubscribes: ['approval.requested'],virtualEmits: ['/api/approvals/submit'],flows: ['approval'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
exportconstconfig:NoopConfig={type:'noop',name:'GitHub Webhook',description:'Waiting for repository events',virtualSubscribes: ['repository.watched'],virtualEmits: ['/api/github/webhook'],flows: ['repo-automation'],}
Best Practices
UI Steps
EventNode
ApiNode
NOOP Steps
.step.ts
.step.tsx
virtualSubscribes
Component Reference
Core Imports
BaseHandle
EventNodeProps
Position
Handle Placement
Observability
Understanding how to use the logging and debugging system in Motia
Middleware
Run code before and after your API handlers
On this page

