

===== https://nodemailer.com/ =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Nodemailer
Nodemailer
Send e-mails with Node.JS – easy as cake! ✉️
Nodemailer makes sending email from a Node.js application straightforward and secure, without pulling in a single runtime dependency.
npm install nodemailer
npm install nodemailer
EmailEngineis a self‑hosted email gateway that lets you make REST calls to IMAP & SMTP accounts, receive webhooks for mailbox changes, and send email with extras such as OAuth2, delayed delivery, open‑ & click‑tracking, bounce detection, and more.
Why Nodemailer?​
Zero runtime dependencies– the entire implementation lives in one audited package.
Security first– avoids known RCE vectors that have affected other Node.js mailers.
Unicode everywhere– send any characters, including emoji 💪.
Cross‑platform– no native addons, works the same on Linux, macOS, and Windows (great for Azure).
HTML e‑mailswithplain‑text fallbacksout of the box.
Attachments&embedded imageswithout pain.
Out‑of‑the‑boxTLS/STARTTLSencryption.
Multipletransports(SMTP, Sendmail, SES, streams, and more).
DKIMsigning &OAuth2authentication.
Proxy supportfor restricted networks.
Plugin APIfor advanced message manipulation.
Built‑in test accounts fromEthereal.emailfor local development.
Requirements​
Node.js ≥ 6.0.0(async/await examples require ≥ 8.0.0).
No other system libraries, services, or build tools are needed.
Quick‑start​
Create a transporter.Use SMTP or another supported transport.
Compose a message.Define sender, recipient(s), subject, and content.
Send itwithtransporter.sendMail().
transporter.sendMail()
Example (using an Ethereal test account)​
constnodemailer=require("nodemailer");// Create a test account or replace with real credentials.consttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// true for 465, false for other portsauth:{user:"maddison53@ethereal.email",pass:"jn7jnAPss4f63QBp6D",},});// Wrap in an async IIFE so we can use await.(async()=>{constinfo=awaittransporter.sendMail({from:'"Maddison Foo Koch" <maddison53@ethereal.email>',to:"bar@example.com, baz@example.com",subject:"Hello ✔",text:"Hello world?",// plain‑text bodyhtml:"<b>Hello world?</b>",// HTML body});console.log("Message sent:",info.messageId);})();
constnodemailer=require("nodemailer");// Create a test account or replace with real credentials.consttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// true for 465, false for other portsauth:{user:"maddison53@ethereal.email",pass:"jn7jnAPss4f63QBp6D",},});// Wrap in an async IIFE so we can use await.(async()=>{constinfo=awaittransporter.sendMail({from:'"Maddison Foo Koch" <maddison53@ethereal.email>',to:"bar@example.com, baz@example.com",subject:"Hello ✔",text:"Hello world?",// plain‑text bodyhtml:"<b>Hello world?</b>",// HTML body});console.log("Message sent:",info.messageId);})();
Tip:Ethereal generates a URL for every message so you can view the rendered email in your browser — perfect for development.
Source & license​
Nodemailer is MIT‑licensed open source. Browse the code onGitHub.
Made with ❤️ byAndris Reinman. Logo bySven Kristjansen.
Why Nodemailer?
Requirements
Quick‑startExample (using an Ethereal test account)
Example (using an Ethereal test account)
Source & license



===== https://nodemailer.com/#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Nodemailer
Nodemailer
Send e-mails with Node.JS – easy as cake! ✉️
Nodemailer makes sending email from a Node.js application straightforward and secure, without pulling in a single runtime dependency.
npm install nodemailer
npm install nodemailer
EmailEngineis a self‑hosted email gateway that lets you make REST calls to IMAP & SMTP accounts, receive webhooks for mailbox changes, and send email with extras such as OAuth2, delayed delivery, open‑ & click‑tracking, bounce detection, and more.
Why Nodemailer?​
Zero runtime dependencies– the entire implementation lives in one audited package.
Security first– avoids known RCE vectors that have affected other Node.js mailers.
Unicode everywhere– send any characters, including emoji 💪.
Cross‑platform– no native addons, works the same on Linux, macOS, and Windows (great for Azure).
HTML e‑mailswithplain‑text fallbacksout of the box.
Attachments&embedded imageswithout pain.
Out‑of‑the‑boxTLS/STARTTLSencryption.
Multipletransports(SMTP, Sendmail, SES, streams, and more).
DKIMsigning &OAuth2authentication.
Proxy supportfor restricted networks.
Plugin APIfor advanced message manipulation.
Built‑in test accounts fromEthereal.emailfor local development.
Requirements​
Node.js ≥ 6.0.0(async/await examples require ≥ 8.0.0).
No other system libraries, services, or build tools are needed.
Quick‑start​
Create a transporter.Use SMTP or another supported transport.
Compose a message.Define sender, recipient(s), subject, and content.
Send itwithtransporter.sendMail().
transporter.sendMail()
Example (using an Ethereal test account)​
constnodemailer=require("nodemailer");// Create a test account or replace with real credentials.consttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// true for 465, false for other portsauth:{user:"maddison53@ethereal.email",pass:"jn7jnAPss4f63QBp6D",},});// Wrap in an async IIFE so we can use await.(async()=>{constinfo=awaittransporter.sendMail({from:'"Maddison Foo Koch" <maddison53@ethereal.email>',to:"bar@example.com, baz@example.com",subject:"Hello ✔",text:"Hello world?",// plain‑text bodyhtml:"<b>Hello world?</b>",// HTML body});console.log("Message sent:",info.messageId);})();
constnodemailer=require("nodemailer");// Create a test account or replace with real credentials.consttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// true for 465, false for other portsauth:{user:"maddison53@ethereal.email",pass:"jn7jnAPss4f63QBp6D",},});// Wrap in an async IIFE so we can use await.(async()=>{constinfo=awaittransporter.sendMail({from:'"Maddison Foo Koch" <maddison53@ethereal.email>',to:"bar@example.com, baz@example.com",subject:"Hello ✔",text:"Hello world?",// plain‑text bodyhtml:"<b>Hello world?</b>",// HTML body});console.log("Message sent:",info.messageId);})();
Tip:Ethereal generates a URL for every message so you can view the rendered email in your browser — perfect for development.
Source & license​
Nodemailer is MIT‑licensed open source. Browse the code onGitHub.
Made with ❤️ byAndris Reinman. Logo bySven Kristjansen.
Why Nodemailer?
Requirements
Quick‑startExample (using an Ethereal test account)
Example (using an Ethereal test account)
Source & license



===== https://nodemailer.com/usage =====

Nodemailer
UsageUsing Gmail
Using Gmail
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Usage
Usage
This page shows how to get Nodemailer up and running quickly, then walks through the most common tasks you’ll perform: creating atransporterand sending a message.
Installation​
Add Nodemailer to your project:
npm install nodemailer
npm install nodemailer
Create a transporter​
Every email you send goes through atransporter—an object that knows how to deliver messages to your chosen email service.
constnodemailer=require("nodemailer");// Create a transporter for SMTPconsttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,secure:false,// upgrade later with STARTTLSauth:{user:process.env.SMTP_USER,pass:process.env.SMTP_PASS,},});
constnodemailer=require("nodemailer");// Create a transporter for SMTPconsttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,secure:false,// upgrade later with STARTTLSauth:{user:process.env.SMTP_USER,pass:process.env.SMTP_PASS,},});
createTransport(transport[, defaults])returns a reusable transporter instance.
createTransport(transport[, defaults])
"smtp://user:pass@smtp.example.com:587"
Create the transporteronceand reuse it. Transporter creation opens network sockets and performs authentication; doing this for every email adds needless overhead.
Other transport types​
SMTP– see theSMTP guidefor all available options.
Plugins– Nodemailer can deliver through anything that exposes asend(mail, callback)interface. See thetransport plugin docs.
send(mail, callback)
Verify the connection (optional)​
Before you start sending, you can check that Nodemailer can connect to your SMTP server:
awaittransporter.verify();console.log("Server is ready to take our messages");
awaittransporter.verify();console.log("Server is ready to take our messages");
Send a message​
Once you have a transporter, send an email withtransporter.sendMail(message[, callback]).
transporter.sendMail(message[, callback])
(async()=>{try{constinfo=awaittransporter.sendMail({from:'"Example Team" <team@example.com>',// sender addressto:"alice@example.com, bob@example.com",// list of receiverssubject:"Hello",// Subject linetext:"Hello world?",// plain text bodyhtml:"<b>Hello world?</b>",// html body});console.log("Message sent: %s",info.messageId);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}catch(err){console.error("Error while sending mail",err);}})();
(async()=>{try{constinfo=awaittransporter.sendMail({from:'"Example Team" <team@example.com>',// sender addressto:"alice@example.com, bob@example.com",// list of receiverssubject:"Hello",// Subject linetext:"Hello world?",// plain text bodyhtml:"<b>Hello world?</b>",// html body});console.log("Message sent: %s",info.messageId);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}catch(err){console.error("Error while sending mail",err);}})();
Parameters​
(err, info) => {}
sendMail
Theinfoobject returned by most transports contains:
info
messageId
envelope
accepted
rejected
pending
response
If a message has multiple recipients it is consideredsentas long asat least oneaddress was accepted.
Installation
Create a transporterOther transport types
Other transport types
Verify the connection (optional)
Send a messageParameters
Parameters



===== https://nodemailer.com/usage#__docusaurus_skipToContent_fallback =====

Nodemailer
UsageUsing Gmail
Using Gmail
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Usage
Usage
This page shows how to get Nodemailer up and running quickly, then walks through the most common tasks you’ll perform: creating atransporterand sending a message.
Installation​
Add Nodemailer to your project:
npm install nodemailer
npm install nodemailer
Create a transporter​
Every email you send goes through atransporter—an object that knows how to deliver messages to your chosen email service.
constnodemailer=require("nodemailer");// Create a transporter for SMTPconsttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,secure:false,// upgrade later with STARTTLSauth:{user:process.env.SMTP_USER,pass:process.env.SMTP_PASS,},});
constnodemailer=require("nodemailer");// Create a transporter for SMTPconsttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,secure:false,// upgrade later with STARTTLSauth:{user:process.env.SMTP_USER,pass:process.env.SMTP_PASS,},});
createTransport(transport[, defaults])returns a reusable transporter instance.
createTransport(transport[, defaults])
"smtp://user:pass@smtp.example.com:587"
Create the transporteronceand reuse it. Transporter creation opens network sockets and performs authentication; doing this for every email adds needless overhead.
Other transport types​
SMTP– see theSMTP guidefor all available options.
Plugins– Nodemailer can deliver through anything that exposes asend(mail, callback)interface. See thetransport plugin docs.
send(mail, callback)
Verify the connection (optional)​
Before you start sending, you can check that Nodemailer can connect to your SMTP server:
awaittransporter.verify();console.log("Server is ready to take our messages");
awaittransporter.verify();console.log("Server is ready to take our messages");
Send a message​
Once you have a transporter, send an email withtransporter.sendMail(message[, callback]).
transporter.sendMail(message[, callback])
(async()=>{try{constinfo=awaittransporter.sendMail({from:'"Example Team" <team@example.com>',// sender addressto:"alice@example.com, bob@example.com",// list of receiverssubject:"Hello",// Subject linetext:"Hello world?",// plain text bodyhtml:"<b>Hello world?</b>",// html body});console.log("Message sent: %s",info.messageId);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}catch(err){console.error("Error while sending mail",err);}})();
(async()=>{try{constinfo=awaittransporter.sendMail({from:'"Example Team" <team@example.com>',// sender addressto:"alice@example.com, bob@example.com",// list of receiverssubject:"Hello",// Subject linetext:"Hello world?",// plain text bodyhtml:"<b>Hello world?</b>",// html body});console.log("Message sent: %s",info.messageId);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}catch(err){console.error("Error while sending mail",err);}})();
Parameters​
(err, info) => {}
sendMail
Theinfoobject returned by most transports contains:
info
messageId
envelope
accepted
rejected
pending
response
If a message has multiple recipients it is consideredsentas long asat least oneaddress was accepted.
Installation
Create a transporterOther transport types
Other transport types
Verify the connection (optional)
Send a messageParameters
Parameters



===== https://nodemailer.com/usage/using-gmail =====

Nodemailer
UsageUsing Gmail
Using Gmail
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Usage
Using Gmail
Using Gmail
TL;DRFor new projects, useOAuth 2.0(or an App Password if you already have Google 2‑Step Verification turned on). “Less Secure App” access was permanently disabled by Google onMay 30 2022.
Gmail is still the quickest way to send a test email with Nodemailer, but it isnotthe most resilient choice for production workloads. Gmail is designed for humans, not automated services, and its login heuristics are aggressive. When Google detects something that looks like account‑hijacking (for example, your production server running from a different country than your laptop) it will simply block the SMTP connection rather than deliver the mail.
Below we cover the three supported authentication methods, the Gmail sending limits, and some caveats that often trip developers up.
1. Choose an authentication method​
OAuth 2.0 (recommended)​
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({service:"gmail",auth:{type:"OAuth2",user:"me@gmail.com",clientId:process.env.GOOGLE_CLIENT_ID,clientSecret:process.env.GOOGLE_CLIENT_SECRET,refreshToken:process.env.GOOGLE_REFRESH_TOKEN,},});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({service:"gmail",auth:{type:"OAuth2",user:"me@gmail.com",clientId:process.env.GOOGLE_CLIENT_ID,clientSecret:process.env.GOOGLE_CLIENT_SECRET,refreshToken:process.env.GOOGLE_REFRESH_TOKEN,},});
OAuth 2.0 avoids password handling altogether. You perform a one‑time consent flow, store therefresh_token, and Nodemailer silently refreshes access tokens when needed.
refresh_token
See the dedicated guide ➡️SMTP / OAuth 2.0for a step‑by‑step walkthrough.
App Password (requires 2‑Step Verification)​
If the Google account already has 2‑Step Verification, you can generate a 16‑characterApp Passwordand use it like a normal SMTP password:
consttransporter=nodemailer.createTransport({service:"gmail",auth:{user:"me@gmail.com",pass:process.env.GOOGLE_APP_PASSWORD,},});
consttransporter=nodemailer.createTransport({service:"gmail",auth:{user:"me@gmail.com",pass:process.env.GOOGLE_APP_PASSWORD,},});
App Passwordsbypass most of Google’s heuristics, but Google may still block traffic from unusual locations or IP ranges.
2. Gmail quirks to keep in mind​
Gmail rewrites theFrom:header​
Gmailalwayssets the authenticated account address as the sender. If you authenticate asfoo@example.comand passbar@example.comin thefromfield, Gmail will silently replace it withfoo@example.com. Usealiasesor a Google WorkspaceSend Asaddress if you need a different visible sender.
foo@example.com
bar@example.com
from
foo@example.com
Daily sending limits​
Personal GmailUp to500recipients per rolling 24‑hour period.
Google WorkspaceUp to2 000recipients per rolling 24‑hour period.
A single e‑mail counts once per unique recipient, so a message with oneTo:and oneCc:address counts astwo.
Exceeding these limits will result in SMTP error454 4.7.0“Too many recipients”until the quota resets.
3. Production alternatives​
For predictable delivery and higher volume you will want to move to a specialist SMTP provider (SendGrid, Postmark, Amazon SES, etc.). Most offer free tiers (~200–300 e‑mails/day) similar to Gmail but without the login heuristics, sender‑address rewrite, or recipient caps.
Troubleshooting checklist​
Check the Google Account ‘Security > Recent activity’ pageto see if Google is blocking the login attempt.
If usingOAuth 2.0, verify that therefresh_tokenis still valid and that the OAuth consent screen is in “Production” status.
refresh_token
If using anApp Password, confirm that 2‑Step Verification is still enabled and that the App Password has not been revoked.
Make sure the server’s clock is in sync (OAuth tokens are time‑sensitive).
Try sending from the same IP range manually (e.g. usingopenssl s_client -connect smtp.gmail.com:465) to reproduce the error.
openssl s_client -connect smtp.gmail.com:465
1. Choose an authentication methodOAuth 2.0 (recommended)App Password (requires 2‑Step Verification)
OAuth 2.0 (recommended)
App Password (requires 2‑Step Verification)
2. Gmail quirks to keep in mindGmail rewrites theFrom:headerDaily sending limits
Gmail rewrites theFrom:header
Daily sending limits
3. Production alternatives
Troubleshooting checklist



===== https://nodemailer.com/usage/using-gmail#__docusaurus_skipToContent_fallback =====

Nodemailer
UsageUsing Gmail
Using Gmail
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Usage
Using Gmail
Using Gmail
TL;DRFor new projects, useOAuth 2.0(or an App Password if you already have Google 2‑Step Verification turned on). “Less Secure App” access was permanently disabled by Google onMay 30 2022.
Gmail is still the quickest way to send a test email with Nodemailer, but it isnotthe most resilient choice for production workloads. Gmail is designed for humans, not automated services, and its login heuristics are aggressive. When Google detects something that looks like account‑hijacking (for example, your production server running from a different country than your laptop) it will simply block the SMTP connection rather than deliver the mail.
Below we cover the three supported authentication methods, the Gmail sending limits, and some caveats that often trip developers up.
1. Choose an authentication method​
OAuth 2.0 (recommended)​
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({service:"gmail",auth:{type:"OAuth2",user:"me@gmail.com",clientId:process.env.GOOGLE_CLIENT_ID,clientSecret:process.env.GOOGLE_CLIENT_SECRET,refreshToken:process.env.GOOGLE_REFRESH_TOKEN,},});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({service:"gmail",auth:{type:"OAuth2",user:"me@gmail.com",clientId:process.env.GOOGLE_CLIENT_ID,clientSecret:process.env.GOOGLE_CLIENT_SECRET,refreshToken:process.env.GOOGLE_REFRESH_TOKEN,},});
OAuth 2.0 avoids password handling altogether. You perform a one‑time consent flow, store therefresh_token, and Nodemailer silently refreshes access tokens when needed.
refresh_token
See the dedicated guide ➡️SMTP / OAuth 2.0for a step‑by‑step walkthrough.
App Password (requires 2‑Step Verification)​
If the Google account already has 2‑Step Verification, you can generate a 16‑characterApp Passwordand use it like a normal SMTP password:
consttransporter=nodemailer.createTransport({service:"gmail",auth:{user:"me@gmail.com",pass:process.env.GOOGLE_APP_PASSWORD,},});
consttransporter=nodemailer.createTransport({service:"gmail",auth:{user:"me@gmail.com",pass:process.env.GOOGLE_APP_PASSWORD,},});
App Passwordsbypass most of Google’s heuristics, but Google may still block traffic from unusual locations or IP ranges.
2. Gmail quirks to keep in mind​
Gmail rewrites theFrom:header​
Gmailalwayssets the authenticated account address as the sender. If you authenticate asfoo@example.comand passbar@example.comin thefromfield, Gmail will silently replace it withfoo@example.com. Usealiasesor a Google WorkspaceSend Asaddress if you need a different visible sender.
foo@example.com
bar@example.com
from
foo@example.com
Daily sending limits​
Personal GmailUp to500recipients per rolling 24‑hour period.
Google WorkspaceUp to2 000recipients per rolling 24‑hour period.
A single e‑mail counts once per unique recipient, so a message with oneTo:and oneCc:address counts astwo.
Exceeding these limits will result in SMTP error454 4.7.0“Too many recipients”until the quota resets.
3. Production alternatives​
For predictable delivery and higher volume you will want to move to a specialist SMTP provider (SendGrid, Postmark, Amazon SES, etc.). Most offer free tiers (~200–300 e‑mails/day) similar to Gmail but without the login heuristics, sender‑address rewrite, or recipient caps.
Troubleshooting checklist​
Check the Google Account ‘Security > Recent activity’ pageto see if Google is blocking the login attempt.
If usingOAuth 2.0, verify that therefresh_tokenis still valid and that the OAuth consent screen is in “Production” status.
refresh_token
If using anApp Password, confirm that 2‑Step Verification is still enabled and that the App Password has not been revoked.
Make sure the server’s clock is in sync (OAuth tokens are time‑sensitive).
Try sending from the same IP range manually (e.g. usingopenssl s_client -connect smtp.gmail.com:465) to reproduce the error.
openssl s_client -connect smtp.gmail.com:465
1. Choose an authentication methodOAuth 2.0 (recommended)App Password (requires 2‑Step Verification)
OAuth 2.0 (recommended)
App Password (requires 2‑Step Verification)
2. Gmail quirks to keep in mindGmail rewrites theFrom:headerDaily sending limits
Gmail rewrites theFrom:header
Daily sending limits
3. Production alternatives
Troubleshooting checklist



===== https://nodemailer.com/message =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Message configuration
The following are the possible fields of an email message:
Common fields​
from- The email address of the sender. All email addresses can be plain'sender@server.com'or formatted'"Sender Name" <sender@server.com>', seeAddress objectfor details
'sender@server.com'
'"Sender Name" <sender@server.com>'
to- Comma separated list or an array of recipients email addresses that will appear on theTo:field
cc- Comma separated list or an array of recipients email addresses that will appear on theCc:field
bcc- Comma separated list or an array of recipients email addresses that will appear on theBcc:field
subject- The subject of the email
text- The plaintext version of the message as a Unicode string, Buffer, Stream or an attachment-like object ({path: '/var/data/...'})
{path: '/var/data/...'}
html- The HTML version of the message as a Unicode string, Buffer, Stream or an attachment-like object ({path: 'http://...'})
{path: 'http://...'}
attachments- An array of attachment objects (seeUsing attachmentsfor details). Attachments can be used forembedding imagesas well.
A large majority of emails sent look a lot like this, using only a few basic fields:
varmessage={from:"sender@server.com",to:"receiver@sender.com",subject:"Message title",text:"Plaintext version of the message",html:"<p>HTML version of the message</p>",};
varmessage={from:"sender@server.com",to:"receiver@sender.com",subject:"Message title",text:"Plaintext version of the message",html:"<p>HTML version of the message</p>",};
More advanced fields​
sender- An email address that will appear on theSender:field (always preferfromif you're not sure which one to use)
replyTo- An email address that will appear on theReply-To:field
inReplyTo- The Message-ID this message is replying to
references- Message-ID list (an array or space separated string)
envelope- optional SMTP envelope, if auto-generated envelope is not suitable (seeSMTP envelopefor details)
attachDataUrls– if true then convertdata:images in the HTML content of this message to embedded attachments
watchHtml- Apple Watch specific HTML version of the message. Latest watches have no problems rendering text/html content so watchHtml is most probably never seen by the recipient
amp- AMP4EMAIL specific HTML version of the message, same usage as withtextandhtml. See AMP examplebelowfor usage orthis blogpostfor sending and rendering
text
html
icalEvent– iCalendar event to use as an alternative. See detailshere
alternatives- An array of alternative text contents (in addition to text and html parts) (seeUsing alternative contentfor details)
encoding- identifies encoding for text/html strings (defaults to 'utf-8', other values are 'hex' and 'base64')
raw- existing MIME message to use instead of generating a new one. See detailshere
textEncoding- force content-transfer-encoding for text values (eitherquoted-printableorbase64). By default the best option is detected (for lots of ascii usequoted-printable, otherwisebase64)
priority- Sets message importance headers, either'high','normal'(default) or'low'.
headers- An object or array of additional header fields (e.g.{"X-Key-Name": "key value"}or[{key: "X-Key-Name", value: "val1"}, {key: "X-Key-Name", value: "val2"}]). Read more about custom headershere
{"X-Key-Name": "key value"}
[{key: "X-Key-Name", value: "val1"}, {key: "X-Key-Name", value: "val2"}]
messageId- optional Message-Id value, random value will be generated if not set
date- optional Date value, current UTC string will be used if not set
list- helper for setting List-* headers (see morehere)
disableFileAccessif true, then does not allow to use files as content. Use it when you want to use JSON data from untrusted source as the email. If an attachment or message node tries to fetch something from a file the sending returns an error. If this field is also set in the transport options, then the value in mail data is ignored
disableUrlAccessif true, then does not allow to use URLs as content. If this field is also set in the transport options, then the value in mail data is ignored
varmessage={...,headers:{'My-Custom-Header':'header value'},date:newDate('2000-01-01 00:00:00')};
varmessage={...,headers:{'My-Custom-Header':'header value'},date:newDate('2000-01-01 00:00:00')};
varhtmlstream=fs.createReadStream("content.html");transport.sendMail({html:htmlstream},function(err){if(err){// check if htmlstream is still open and close it to clean up}});
varhtmlstream=fs.createReadStream("content.html");transport.sendMail({html:htmlstream},function(err){if(err){// check if htmlstream is still open and close it to clean up}});
letmessage={from:"Nodemailer <example@nodemailer.com>",to:"Nodemailer <example@nodemailer.com>",subject:"AMP4EMAIL message",text:"For clients with plaintext support only",html:"<p>For clients that do not support AMP4EMAIL or amp content is not valid</p>",amp:`<!doctype html><html ⚡4email><head><meta charset="utf-8"><style amp4email-boilerplate>body{visibility:hidden}</style><script async src="https://cdn.ampproject.org/v0.js"></script><script async custom-element="amp-anim" src="https://cdn.ampproject.org/v0/amp-anim-0.1.js"></script></head><body><p>Image: <amp-img src="https://cldup.com/P0b1bUmEet.png" width="16" height="16"/></p><p>GIF (requires "amp-anim" script in header):<br/><amp-anim src="https://cldup.com/D72zpdwI-i.gif" width="500" height="350"/></p></body></html>`,};
letmessage={from:"Nodemailer <example@nodemailer.com>",to:"Nodemailer <example@nodemailer.com>",subject:"AMP4EMAIL message",text:"For clients with plaintext support only",html:"<p>For clients that do not support AMP4EMAIL or amp content is not valid</p>",amp:`<!doctype html><html ⚡4email><head><meta charset="utf-8"><style amp4email-boilerplate>body{visibility:hidden}</style><script async src="https://cdn.ampproject.org/v0.js"></script><script async custom-element="amp-anim" src="https://cdn.ampproject.org/v0/amp-anim-0.1.js"></script></head><body><p>Image: <amp-img src="https://cldup.com/P0b1bUmEet.png" width="16" height="16"/></p><p>GIF (requires "amp-anim" script in header):<br/><amp-anim src="https://cldup.com/D72zpdwI-i.gif" width="500" height="350"/></p></body></html>`,};
Common fields
More advanced fields



===== https://nodemailer.com/message#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Message configuration
The following are the possible fields of an email message:
Common fields​
from- The email address of the sender. All email addresses can be plain'sender@server.com'or formatted'"Sender Name" <sender@server.com>', seeAddress objectfor details
'sender@server.com'
'"Sender Name" <sender@server.com>'
to- Comma separated list or an array of recipients email addresses that will appear on theTo:field
cc- Comma separated list or an array of recipients email addresses that will appear on theCc:field
bcc- Comma separated list or an array of recipients email addresses that will appear on theBcc:field
subject- The subject of the email
text- The plaintext version of the message as a Unicode string, Buffer, Stream or an attachment-like object ({path: '/var/data/...'})
{path: '/var/data/...'}
html- The HTML version of the message as a Unicode string, Buffer, Stream or an attachment-like object ({path: 'http://...'})
{path: 'http://...'}
attachments- An array of attachment objects (seeUsing attachmentsfor details). Attachments can be used forembedding imagesas well.
A large majority of emails sent look a lot like this, using only a few basic fields:
varmessage={from:"sender@server.com",to:"receiver@sender.com",subject:"Message title",text:"Plaintext version of the message",html:"<p>HTML version of the message</p>",};
varmessage={from:"sender@server.com",to:"receiver@sender.com",subject:"Message title",text:"Plaintext version of the message",html:"<p>HTML version of the message</p>",};
More advanced fields​
sender- An email address that will appear on theSender:field (always preferfromif you're not sure which one to use)
replyTo- An email address that will appear on theReply-To:field
inReplyTo- The Message-ID this message is replying to
references- Message-ID list (an array or space separated string)
envelope- optional SMTP envelope, if auto-generated envelope is not suitable (seeSMTP envelopefor details)
attachDataUrls– if true then convertdata:images in the HTML content of this message to embedded attachments
watchHtml- Apple Watch specific HTML version of the message. Latest watches have no problems rendering text/html content so watchHtml is most probably never seen by the recipient
amp- AMP4EMAIL specific HTML version of the message, same usage as withtextandhtml. See AMP examplebelowfor usage orthis blogpostfor sending and rendering
text
html
icalEvent– iCalendar event to use as an alternative. See detailshere
alternatives- An array of alternative text contents (in addition to text and html parts) (seeUsing alternative contentfor details)
encoding- identifies encoding for text/html strings (defaults to 'utf-8', other values are 'hex' and 'base64')
raw- existing MIME message to use instead of generating a new one. See detailshere
textEncoding- force content-transfer-encoding for text values (eitherquoted-printableorbase64). By default the best option is detected (for lots of ascii usequoted-printable, otherwisebase64)
priority- Sets message importance headers, either'high','normal'(default) or'low'.
headers- An object or array of additional header fields (e.g.{"X-Key-Name": "key value"}or[{key: "X-Key-Name", value: "val1"}, {key: "X-Key-Name", value: "val2"}]). Read more about custom headershere
{"X-Key-Name": "key value"}
[{key: "X-Key-Name", value: "val1"}, {key: "X-Key-Name", value: "val2"}]
messageId- optional Message-Id value, random value will be generated if not set
date- optional Date value, current UTC string will be used if not set
list- helper for setting List-* headers (see morehere)
disableFileAccessif true, then does not allow to use files as content. Use it when you want to use JSON data from untrusted source as the email. If an attachment or message node tries to fetch something from a file the sending returns an error. If this field is also set in the transport options, then the value in mail data is ignored
disableUrlAccessif true, then does not allow to use URLs as content. If this field is also set in the transport options, then the value in mail data is ignored
varmessage={...,headers:{'My-Custom-Header':'header value'},date:newDate('2000-01-01 00:00:00')};
varmessage={...,headers:{'My-Custom-Header':'header value'},date:newDate('2000-01-01 00:00:00')};
varhtmlstream=fs.createReadStream("content.html");transport.sendMail({html:htmlstream},function(err){if(err){// check if htmlstream is still open and close it to clean up}});
varhtmlstream=fs.createReadStream("content.html");transport.sendMail({html:htmlstream},function(err){if(err){// check if htmlstream is still open and close it to clean up}});
letmessage={from:"Nodemailer <example@nodemailer.com>",to:"Nodemailer <example@nodemailer.com>",subject:"AMP4EMAIL message",text:"For clients with plaintext support only",html:"<p>For clients that do not support AMP4EMAIL or amp content is not valid</p>",amp:`<!doctype html><html ⚡4email><head><meta charset="utf-8"><style amp4email-boilerplate>body{visibility:hidden}</style><script async src="https://cdn.ampproject.org/v0.js"></script><script async custom-element="amp-anim" src="https://cdn.ampproject.org/v0/amp-anim-0.1.js"></script></head><body><p>Image: <amp-img src="https://cldup.com/P0b1bUmEet.png" width="16" height="16"/></p><p>GIF (requires "amp-anim" script in header):<br/><amp-anim src="https://cldup.com/D72zpdwI-i.gif" width="500" height="350"/></p></body></html>`,};
letmessage={from:"Nodemailer <example@nodemailer.com>",to:"Nodemailer <example@nodemailer.com>",subject:"AMP4EMAIL message",text:"For clients with plaintext support only",html:"<p>For clients that do not support AMP4EMAIL or amp content is not valid</p>",amp:`<!doctype html><html ⚡4email><head><meta charset="utf-8"><style amp4email-boilerplate>body{visibility:hidden}</style><script async src="https://cdn.ampproject.org/v0.js"></script><script async custom-element="amp-anim" src="https://cdn.ampproject.org/v0/amp-anim-0.1.js"></script></head><body><p>Image: <amp-img src="https://cldup.com/P0b1bUmEet.png" width="16" height="16"/></p><p>GIF (requires "amp-anim" script in header):<br/><amp-anim src="https://cldup.com/D72zpdwI-i.gif" width="500" height="350"/></p></body></html>`,};
Common fields
More advanced fields



===== https://nodemailer.com/message/attachments =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Attachments
Attachments
Use theattachmentsoption of themessage objectto attach files.
attachments
An attachment is an object inside theattachmentsarray. You can attachas many files as you need.
attachments
filename
string
content
string | Buffer | Stream
path
string
href
string
httpHeaders
object
href
{ authorization: 'Bearer …' }
contentType
string
filename
contentDisposition
string
'attachment'
cid
string
<img src="cid:my-logo"/>
encoding
string
content
'base64'
'hex'
headers
object
raw
string
Preferpath,href, or aStreamwhen attaching large files so that Nodemailer can stream data without loading it all into memory.
path
href
Stream
Examples​
constfs=require("fs");// inside a message objectattachments:[// 1. Plain text{filename:"hello.txt",content:"Hello world!",},// 2. Binary (Buffer){filename:"buffer.txt",content:Buffer.from("Hello world!","utf8"),},// 3. Local file (streamed){filename:"report.pdf",path:"/absolute/path/to/report.pdf",},// 4. Implicit filename & type (derived from path){path:"/absolute/path/to/image.png",},// 5. Readable stream{filename:"notes.txt",content:fs.createReadStream("./notes.txt"),},// 6. Custom content‑type{filename:"data.bin",content:Buffer.from("deadbeef","hex"),contentType:"application/octet-stream",},// 7. Remote file{filename:"license.txt",href:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE",},// 8. Base64‑encoded string{filename:"photo.jpg",content:"/9j/4AAQSkZJRgABAQAAAQABAAD…",// truncatedencoding:"base64",},// 9. Data URI{path:"data:text/plain;base64,SGVsbG8gd29ybGQ=",},// 10. Pre‑built MIME node{raw:["Content-Type: text/plain; charset=utf-8",'Content-Disposition: attachment; filename="greeting.txt"',"","Hello world!"].join("\r\n"),},];
constfs=require("fs");// inside a message objectattachments:[// 1. Plain text{filename:"hello.txt",content:"Hello world!",},// 2. Binary (Buffer){filename:"buffer.txt",content:Buffer.from("Hello world!","utf8"),},// 3. Local file (streamed){filename:"report.pdf",path:"/absolute/path/to/report.pdf",},// 4. Implicit filename & type (derived from path){path:"/absolute/path/to/image.png",},// 5. Readable stream{filename:"notes.txt",content:fs.createReadStream("./notes.txt"),},// 6. Custom content‑type{filename:"data.bin",content:Buffer.from("deadbeef","hex"),contentType:"application/octet-stream",},// 7. Remote file{filename:"license.txt",href:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE",},// 8. Base64‑encoded string{filename:"photo.jpg",content:"/9j/4AAQSkZJRgABAQAAAQABAAD…",// truncatedencoding:"base64",},// 9. Data URI{path:"data:text/plain;base64,SGVsbG8gd29ybGQ=",},// 10. Pre‑built MIME node{raw:["Content-Type: text/plain; charset=utf-8",'Content-Disposition: attachment; filename="greeting.txt"',"","Hello world!"].join("\r\n"),},];
Embedding images​
To embed an image inside the HTML part of the email, set acidon the attachment and reference that CID in the HTML:
cid
attachments:[{filename:'logo.png',path:'./assets/logo.png',cid:'logo@nodemailer'}],html:'<p><img src="cid:logo@nodemailer" alt="Nodemailer logo"></p>'
attachments:[{filename:'logo.png',path:'./assets/logo.png',cid:'logo@nodemailer'}],html:'<p><img src="cid:logo@nodemailer" alt="Nodemailer logo"></p>'
Examples
Embedding images



===== https://nodemailer.com/message/attachments#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Attachments
Attachments
Use theattachmentsoption of themessage objectto attach files.
attachments
An attachment is an object inside theattachmentsarray. You can attachas many files as you need.
attachments
filename
string
content
string | Buffer | Stream
path
string
href
string
httpHeaders
object
href
{ authorization: 'Bearer …' }
contentType
string
filename
contentDisposition
string
'attachment'
cid
string
<img src="cid:my-logo"/>
encoding
string
content
'base64'
'hex'
headers
object
raw
string
Preferpath,href, or aStreamwhen attaching large files so that Nodemailer can stream data without loading it all into memory.
path
href
Stream
Examples​
constfs=require("fs");// inside a message objectattachments:[// 1. Plain text{filename:"hello.txt",content:"Hello world!",},// 2. Binary (Buffer){filename:"buffer.txt",content:Buffer.from("Hello world!","utf8"),},// 3. Local file (streamed){filename:"report.pdf",path:"/absolute/path/to/report.pdf",},// 4. Implicit filename & type (derived from path){path:"/absolute/path/to/image.png",},// 5. Readable stream{filename:"notes.txt",content:fs.createReadStream("./notes.txt"),},// 6. Custom content‑type{filename:"data.bin",content:Buffer.from("deadbeef","hex"),contentType:"application/octet-stream",},// 7. Remote file{filename:"license.txt",href:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE",},// 8. Base64‑encoded string{filename:"photo.jpg",content:"/9j/4AAQSkZJRgABAQAAAQABAAD…",// truncatedencoding:"base64",},// 9. Data URI{path:"data:text/plain;base64,SGVsbG8gd29ybGQ=",},// 10. Pre‑built MIME node{raw:["Content-Type: text/plain; charset=utf-8",'Content-Disposition: attachment; filename="greeting.txt"',"","Hello world!"].join("\r\n"),},];
constfs=require("fs");// inside a message objectattachments:[// 1. Plain text{filename:"hello.txt",content:"Hello world!",},// 2. Binary (Buffer){filename:"buffer.txt",content:Buffer.from("Hello world!","utf8"),},// 3. Local file (streamed){filename:"report.pdf",path:"/absolute/path/to/report.pdf",},// 4. Implicit filename & type (derived from path){path:"/absolute/path/to/image.png",},// 5. Readable stream{filename:"notes.txt",content:fs.createReadStream("./notes.txt"),},// 6. Custom content‑type{filename:"data.bin",content:Buffer.from("deadbeef","hex"),contentType:"application/octet-stream",},// 7. Remote file{filename:"license.txt",href:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE",},// 8. Base64‑encoded string{filename:"photo.jpg",content:"/9j/4AAQSkZJRgABAQAAAQABAAD…",// truncatedencoding:"base64",},// 9. Data URI{path:"data:text/plain;base64,SGVsbG8gd29ybGQ=",},// 10. Pre‑built MIME node{raw:["Content-Type: text/plain; charset=utf-8",'Content-Disposition: attachment; filename="greeting.txt"',"","Hello world!"].join("\r\n"),},];
Embedding images​
To embed an image inside the HTML part of the email, set acidon the attachment and reference that CID in the HTML:
cid
attachments:[{filename:'logo.png',path:'./assets/logo.png',cid:'logo@nodemailer'}],html:'<p><img src="cid:logo@nodemailer" alt="Nodemailer logo"></p>'
attachments:[{filename:'logo.png',path:'./assets/logo.png',cid:'logo@nodemailer'}],html:'<p><img src="cid:logo@nodemailer" alt="Nodemailer logo"></p>'
Examples
Embedding images



===== https://nodemailer.com/message/alternatives =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Alternatives
Alternatives
In addition to plain‑text and HTML bodies, you can embedalternative representationsof the same content—for example, Markdown or a calendar invite. The email client chooses the representation that best fits the recipient’s environment. Alternatives are most often used for calendar events and other machine‑readable formats.
icalEvent
If you want to send a calendar event, consider theicalEventoption instead. SeeCalendar eventsfor details.
icalEvent
How alternatives differ from attachments​
Alternative objects accept exactly the same fields asattachment objects. The only difference is where Nodemailer places them in the MIME tree:
multipart/mixed
multipart/related
multipart/alternative
Usage​
constmessage={// ...html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmessage={// ...html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
You can includeas manyalternative bodies as you need. Place the most preferred version last—the majority of clients read the list from top to bottom and render the last format they understand.
How alternatives differ from attachments
Usage



===== https://nodemailer.com/message/alternatives#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Alternatives
Alternatives
In addition to plain‑text and HTML bodies, you can embedalternative representationsof the same content—for example, Markdown or a calendar invite. The email client chooses the representation that best fits the recipient’s environment. Alternatives are most often used for calendar events and other machine‑readable formats.
icalEvent
If you want to send a calendar event, consider theicalEventoption instead. SeeCalendar eventsfor details.
icalEvent
How alternatives differ from attachments​
Alternative objects accept exactly the same fields asattachment objects. The only difference is where Nodemailer places them in the MIME tree:
multipart/mixed
multipart/related
multipart/alternative
Usage​
constmessage={// ...html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmessage={// ...html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
You can includeas manyalternative bodies as you need. Place the most preferred version last—the majority of clients read the list from top to bottom and render the last format they understand.
How alternatives differ from attachments
Usage



===== https://nodemailer.com/message/addresses =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Address object
Address object
Email address values in Nodemailer can be provided inthree interchangeable formats. You can freely mix these formats in any address field (from,to,cc,bcc,replyTo, etc.).
from
to
cc
bcc
replyTo
1. Plain address​
"foobar@example.com";
"foobar@example.com";
2. Formatted address (display name + email)​
Includes full Unicode support for the display name:
"Ноде Майлер <foobar@example.com>";
"Ноде Майлер <foobar@example.com>";
All address fields are comma‑separated lists. If the display name itself contains a comma (or any other special character), wrap the name indouble quotes:
'"Майлер, Ноде" <foobar@example.com>';
'"Майлер, Ноде" <foobar@example.com>';
3. Address object​
Let Nodemailer handle the formatting for you—just provide a plain object withnameandaddressproperties:
name
address
{name:'Майлер, Ноде',address:'foobar@example.com'}
{name:'Майлер, Ноде',address:'foobar@example.com'}
Mixing formats & using arrays​
Every address field acceptsanyof the following:
a single address (any of the three formats above)
a comma‑separated string of addresses
an array of addresses
an array that contains comma‑separated stringsand/oraddress objects
// Example message object (CommonJS)constmessage={from:'"Example Sender" <sender@example.com>',to:'foobar@example.com, "Ноде Майлер" <bar@example.com>, "Name, User" <baz@example.com>',cc:["first@example.com",'"Ноде Майлер" <second@example.com>','"Name, User" <third@example.com>'],bcc:["hidden@example.com",{name:"Майлер, Ноде",address:"another@example.com",},],};
// Example message object (CommonJS)constmessage={from:'"Example Sender" <sender@example.com>',to:'foobar@example.com, "Ноде Майлер" <bar@example.com>, "Name, User" <baz@example.com>',cc:["first@example.com",'"Ноде Майлер" <second@example.com>','"Name, User" <third@example.com>'],bcc:["hidden@example.com",{name:"Майлер, Ноде",address:"another@example.com",},],};
Internationalized domains​
Unicode domain names (IDNs) are welcome—Nodemailer automatically converts them toPunycodebehind the scenes:
'"Unicode Domain" <info@müriaad-polüteism.info>';
'"Unicode Domain" <info@müriaad-polüteism.info>';
Quick send example​
constnodemailer=require("nodemailer");(async()=>{consttransport=nodemailer.createTransport({host:"smtp.example.com",port:587,auth:{user:"smtp-user",pass:"smtp-pass",},});awaittransport.sendMail({from:'"Example Sender" <sender@example.com>',to:["recipient@example.com",{name:"Nodemailer User",address:"user@example.com"}],subject:"Hello from Nodemailer",text:"This demonstrates the different address formats.",});})();
constnodemailer=require("nodemailer");(async()=>{consttransport=nodemailer.createTransport({host:"smtp.example.com",port:587,auth:{user:"smtp-user",pass:"smtp-pass",},});awaittransport.sendMail({from:'"Example Sender" <sender@example.com>',to:["recipient@example.com",{name:"Nodemailer User",address:"user@example.com"}],subject:"Hello from Nodemailer",text:"This demonstrates the different address formats.",});})();
1. Plain address
2. Formatted address (display name + email)
3. Address object
Mixing formats & using arrays
Internationalized domainsQuick send example
Quick send example



===== https://nodemailer.com/message/addresses#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Address object
Address object
Email address values in Nodemailer can be provided inthree interchangeable formats. You can freely mix these formats in any address field (from,to,cc,bcc,replyTo, etc.).
from
to
cc
bcc
replyTo
1. Plain address​
"foobar@example.com";
"foobar@example.com";
2. Formatted address (display name + email)​
Includes full Unicode support for the display name:
"Ноде Майлер <foobar@example.com>";
"Ноде Майлер <foobar@example.com>";
All address fields are comma‑separated lists. If the display name itself contains a comma (or any other special character), wrap the name indouble quotes:
'"Майлер, Ноде" <foobar@example.com>';
'"Майлер, Ноде" <foobar@example.com>';
3. Address object​
Let Nodemailer handle the formatting for you—just provide a plain object withnameandaddressproperties:
name
address
{name:'Майлер, Ноде',address:'foobar@example.com'}
{name:'Майлер, Ноде',address:'foobar@example.com'}
Mixing formats & using arrays​
Every address field acceptsanyof the following:
a single address (any of the three formats above)
a comma‑separated string of addresses
an array of addresses
an array that contains comma‑separated stringsand/oraddress objects
// Example message object (CommonJS)constmessage={from:'"Example Sender" <sender@example.com>',to:'foobar@example.com, "Ноде Майлер" <bar@example.com>, "Name, User" <baz@example.com>',cc:["first@example.com",'"Ноде Майлер" <second@example.com>','"Name, User" <third@example.com>'],bcc:["hidden@example.com",{name:"Майлер, Ноде",address:"another@example.com",},],};
// Example message object (CommonJS)constmessage={from:'"Example Sender" <sender@example.com>',to:'foobar@example.com, "Ноде Майлер" <bar@example.com>, "Name, User" <baz@example.com>',cc:["first@example.com",'"Ноде Майлер" <second@example.com>','"Name, User" <third@example.com>'],bcc:["hidden@example.com",{name:"Майлер, Ноде",address:"another@example.com",},],};
Internationalized domains​
Unicode domain names (IDNs) are welcome—Nodemailer automatically converts them toPunycodebehind the scenes:
'"Unicode Domain" <info@müriaad-polüteism.info>';
'"Unicode Domain" <info@müriaad-polüteism.info>';
Quick send example​
constnodemailer=require("nodemailer");(async()=>{consttransport=nodemailer.createTransport({host:"smtp.example.com",port:587,auth:{user:"smtp-user",pass:"smtp-pass",},});awaittransport.sendMail({from:'"Example Sender" <sender@example.com>',to:["recipient@example.com",{name:"Nodemailer User",address:"user@example.com"}],subject:"Hello from Nodemailer",text:"This demonstrates the different address formats.",});})();
constnodemailer=require("nodemailer");(async()=>{consttransport=nodemailer.createTransport({host:"smtp.example.com",port:587,auth:{user:"smtp-user",pass:"smtp-pass",},});awaittransport.sendMail({from:'"Example Sender" <sender@example.com>',to:["recipient@example.com",{name:"Nodemailer User",address:"user@example.com"}],subject:"Hello from Nodemailer",text:"This demonstrates the different address formats.",});})();
1. Plain address
2. Formatted address (display name + email)
3. Address object
Mixing formats & using arrays
Internationalized domainsQuick send example
Quick send example



===== https://nodemailer.com/message/calendar-events =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Calendar events
Calendar events
Nodemailer can embed an iCalendar (.ics) file in an email so that calendar‑aware clients — Gmail, Outlook, Apple Mail, and others — showAdd to calendarorAccept / Declinecontrols directly inside the message.
.ics
Nodemailer onlyattachesthe calendar file. It doesnotbuild the iCalendar content for you. To generate valid.icstext, use a helper such asical‑generatororicsand pass its output to Nodemailer.
.ics
icalEventmessage option​
icalEvent
Attach the calendar file by adding anicalEventobject to the message you pass totransporter.sendMail():
icalEvent
transporter.sendMail()
letmessage={/* ...from, to, subject, etc. */icalEvent:{/* options */},};
letmessage={/* ...from, to, subject, etc. */icalEvent:{/* options */},};
method
string
'PUBLISH'
'REQUEST'
'REPLY'
'CANCEL'
filename
string
'invite.ics'
content
string | Buffer | Stream
path
string
.ics
href
string
encoding
string
'base64'
'hex'
Provideexactly oneofcontent,path, orhref.
content
path
href
Calendar messages are fragile: mixing them with extra file attachments or complex alternative bodies often confuses email clients. For maximum compatibility keep the email totext,html, and a singleicalEvent— nothing else.
Examples​
1 · Send aREQUESTevent from a string​
constappointment=`\BEGIN:VCALENDAR\r\n\PRODID:-//ACME/DesktopCalendar//EN\r\n\METHOD:REQUEST\r\n\...END:VCALENDAR`;letmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Appointment",text:"Please see the attached appointment",icalEvent:{filename:"invitation.ics",method:"REQUEST",content:appointment,},};
constappointment=`\BEGIN:VCALENDAR\r\n\PRODID:-//ACME/DesktopCalendar//EN\r\n\METHOD:REQUEST\r\n\...END:VCALENDAR`;letmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Appointment",text:"Please see the attached appointment",icalEvent:{filename:"invitation.ics",method:"REQUEST",content:appointment,},};
2 · Send aPUBLISHevent loaded from a file​
letmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Appointment",text:"Please see the attached appointment",icalEvent:{method:"PUBLISH",path:"/absolute/path/to/invite.ics",},};
letmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Appointment",text:"Please see the attached appointment",icalEvent:{method:"PUBLISH",path:"/absolute/path/to/invite.ics",},};
3 · Send aCANCELevent fetched from a URL​
letmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Appointment cancelled",text:"The appointment has been cancelled. See details in the attached calendar update.",icalEvent:{method:"CANCEL",href:"https://www.example.com/events/123/cancel.ics",},};
letmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Appointment cancelled",text:"The appointment has been cancelled. See details in the attached calendar update.",icalEvent:{method:"CANCEL",href:"https://www.example.com/events/123/cancel.ics",},};
For a complete runnable example, combine themessageobject above withnodemailer.createTransport()and calltransporter.sendMail().
message
nodemailer.createTransport()
transporter.sendMail()
icalEventmessage option
icalEvent
Examples1 · Send aREQUESTevent from a string2 · Send aPUBLISHevent loaded from a file3 · Send aCANCELevent fetched from a URL
1 · Send aREQUESTevent from a string
2 · Send aPUBLISHevent loaded from a file
3 · Send aCANCELevent fetched from a URL



===== https://nodemailer.com/message/calendar-events#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Calendar events
Calendar events
Nodemailer can embed an iCalendar (.ics) file in an email so that calendar‑aware clients — Gmail, Outlook, Apple Mail, and others — showAdd to calendarorAccept / Declinecontrols directly inside the message.
.ics
Nodemailer onlyattachesthe calendar file. It doesnotbuild the iCalendar content for you. To generate valid.icstext, use a helper such asical‑generatororicsand pass its output to Nodemailer.
.ics
icalEventmessage option​
icalEvent
Attach the calendar file by adding anicalEventobject to the message you pass totransporter.sendMail():
icalEvent
transporter.sendMail()
letmessage={/* ...from, to, subject, etc. */icalEvent:{/* options */},};
letmessage={/* ...from, to, subject, etc. */icalEvent:{/* options */},};
method
string
'PUBLISH'
'REQUEST'
'REPLY'
'CANCEL'
filename
string
'invite.ics'
content
string | Buffer | Stream
path
string
.ics
href
string
encoding
string
'base64'
'hex'
Provideexactly oneofcontent,path, orhref.
content
path
href
Calendar messages are fragile: mixing them with extra file attachments or complex alternative bodies often confuses email clients. For maximum compatibility keep the email totext,html, and a singleicalEvent— nothing else.
Examples​
1 · Send aREQUESTevent from a string​
constappointment=`\BEGIN:VCALENDAR\r\n\PRODID:-//ACME/DesktopCalendar//EN\r\n\METHOD:REQUEST\r\n\...END:VCALENDAR`;letmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Appointment",text:"Please see the attached appointment",icalEvent:{filename:"invitation.ics",method:"REQUEST",content:appointment,},};
constappointment=`\BEGIN:VCALENDAR\r\n\PRODID:-//ACME/DesktopCalendar//EN\r\n\METHOD:REQUEST\r\n\...END:VCALENDAR`;letmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Appointment",text:"Please see the attached appointment",icalEvent:{filename:"invitation.ics",method:"REQUEST",content:appointment,},};
2 · Send aPUBLISHevent loaded from a file​
letmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Appointment",text:"Please see the attached appointment",icalEvent:{method:"PUBLISH",path:"/absolute/path/to/invite.ics",},};
letmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Appointment",text:"Please see the attached appointment",icalEvent:{method:"PUBLISH",path:"/absolute/path/to/invite.ics",},};
3 · Send aCANCELevent fetched from a URL​
letmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Appointment cancelled",text:"The appointment has been cancelled. See details in the attached calendar update.",icalEvent:{method:"CANCEL",href:"https://www.example.com/events/123/cancel.ics",},};
letmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Appointment cancelled",text:"The appointment has been cancelled. See details in the attached calendar update.",icalEvent:{method:"CANCEL",href:"https://www.example.com/events/123/cancel.ics",},};
For a complete runnable example, combine themessageobject above withnodemailer.createTransport()and calltransporter.sendMail().
message
nodemailer.createTransport()
transporter.sendMail()
icalEventmessage option
icalEvent
Examples1 · Send aREQUESTevent from a string2 · Send aPUBLISHevent loaded from a file3 · Send aCANCELevent fetched from a URL
1 · Send aREQUESTevent from a string
2 · Send aPUBLISHevent loaded from a file
3 · Send aCANCELevent fetched from a URL



===== https://nodemailer.com/message/embedded-images =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Embedded images
Embedded images
You can embed images directly inside the HTML body by attaching them and referring to them with thecid:URL scheme.
cid:
Add the image toattachments.
Set acid(Content‑ID) that is unique within the message.
Reference the image in your HTML (or CSS) withcid:<cid>.
cid:<cid>
cid:
Using a Content‑ID lets the email client display the image even when it blocks external images, because the file travels inside the message itself.
cid
Thecidmust beglobally uniquewithin the message. A good pattern is to append a domain you control, e.g.logo.12345@example.com.
logo.12345@example.com
constmessage={from:"Alice <alice@example.com>",to:"Bob <bob@example.com>",subject:"Inline image test",html:'Embedded image: <img src="cid:logo@example.com" alt="logo"/>',attachments:[{filename:"logo.png",path:"/path/to/logo.png",cid:"logo@example.com",// same cid value as in the html img src},],};
constmessage={from:"Alice <alice@example.com>",to:"Bob <bob@example.com>",subject:"Inline image test",html:'Embedded image: <img src="cid:logo@example.com" alt="logo"/>',attachments:[{filename:"logo.png",path:"/path/to/logo.png",cid:"logo@example.com",// same cid value as in the html img src},],};
constfs=require("fs");constmessage={// ...html:'<img src="cid:screenshot@example.com"/>',attachments:[{filename:"screenshot.png",content:fs.readFileSync("/tmp/screenshot.png"),cid:"screenshot@example.com",},],};
constfs=require("fs");constmessage={// ...html:'<img src="cid:screenshot@example.com"/>',attachments:[{filename:"screenshot.png",content:fs.readFileSync("/tmp/screenshot.png"),cid:"screenshot@example.com",},],};
html:`<h1>Monthly report</h1><img src="cid:chart@example.com" alt="Chart"/><img src="cid:badge@example.com" alt="Badge"/>`,attachments:[{filename:'chart.png',path:'./chart.png',cid:'chart@example.com'},{filename:'badge.png',path:'./badge.png',cid:'badge@example.com'}]
html:`<h1>Monthly report</h1><img src="cid:chart@example.com" alt="Chart"/><img src="cid:badge@example.com" alt="Badge"/>`,attachments:[{filename:'chart.png',path:'./chart.png',cid:'chart@example.com'},{filename:'badge.png',path:'./badge.png',cid:'badge@example.com'}]



===== https://nodemailer.com/message/embedded-images#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Embedded images
Embedded images
You can embed images directly inside the HTML body by attaching them and referring to them with thecid:URL scheme.
cid:
Add the image toattachments.
Set acid(Content‑ID) that is unique within the message.
Reference the image in your HTML (or CSS) withcid:<cid>.
cid:<cid>
cid:
Using a Content‑ID lets the email client display the image even when it blocks external images, because the file travels inside the message itself.
cid
Thecidmust beglobally uniquewithin the message. A good pattern is to append a domain you control, e.g.logo.12345@example.com.
logo.12345@example.com
constmessage={from:"Alice <alice@example.com>",to:"Bob <bob@example.com>",subject:"Inline image test",html:'Embedded image: <img src="cid:logo@example.com" alt="logo"/>',attachments:[{filename:"logo.png",path:"/path/to/logo.png",cid:"logo@example.com",// same cid value as in the html img src},],};
constmessage={from:"Alice <alice@example.com>",to:"Bob <bob@example.com>",subject:"Inline image test",html:'Embedded image: <img src="cid:logo@example.com" alt="logo"/>',attachments:[{filename:"logo.png",path:"/path/to/logo.png",cid:"logo@example.com",// same cid value as in the html img src},],};
constfs=require("fs");constmessage={// ...html:'<img src="cid:screenshot@example.com"/>',attachments:[{filename:"screenshot.png",content:fs.readFileSync("/tmp/screenshot.png"),cid:"screenshot@example.com",},],};
constfs=require("fs");constmessage={// ...html:'<img src="cid:screenshot@example.com"/>',attachments:[{filename:"screenshot.png",content:fs.readFileSync("/tmp/screenshot.png"),cid:"screenshot@example.com",},],};
html:`<h1>Monthly report</h1><img src="cid:chart@example.com" alt="Chart"/><img src="cid:badge@example.com" alt="Badge"/>`,attachments:[{filename:'chart.png',path:'./chart.png',cid:'chart@example.com'},{filename:'badge.png',path:'./badge.png',cid:'badge@example.com'}]
html:`<h1>Monthly report</h1><img src="cid:chart@example.com" alt="Chart"/><img src="cid:badge@example.com" alt="Badge"/>`,attachments:[{filename:'chart.png',path:'./chart.png',cid:'chart@example.com'},{filename:'badge.png',path:'./badge.png',cid:'badge@example.com'}]



===== https://nodemailer.com/message/list-headers =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
List headers
List headers
AddingRFC 2369List-*headers(such asList‑Help,List‑Unsubscribe, etc.) lets mailing‑list recipients quickly discover helpful actions provided by email clients. Nodemailer exposes alistmessage option so you can define these headers declaratively instead of hand‑crafting raw header lines.
List-*
List‑Help
List‑Unsubscribe
list
How it works​
Pass alistobject totransporter.sendMail(). Each key in that object becomes the correspondingList-*header name (case‑insensitive). For example,helpbecomes theList-Helpheader.
list
transporter.sendMail()
List-*
help
List-Help
Value formats​
string
<…>
{ url, comment }
Array< string | { url, comment } >
List-*
Array<Array<…>>
List-*values are inserted verbatim—lines aren’t folded and strings aren’t encoded. Stick to ASCII characters and be prepared for lengthy header lines.
List-*
Complete example​
constnodemailer=require("nodemailer");// 1. Create a transport (replace with your configuration)consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,auth:{user:"username",pass:"password",},});// 2. Send a message with various List-* headersasyncfunctionsendListMessage(){awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"List Message",text:"I hope no‑one unsubscribes from this list!",list:{// List-Help: <mailto:admin@example.com?subject=help>help:"admin@example.com?subject=help",// List-Unsubscribe: <http://example.com> (Comment)unsubscribe:{url:"http://example.com",comment:"Comment",},// List-Subscribe: <mailto:admin@example.com?subject=subscribe>// List-Subscribe: <http://example.com> (Subscribe)subscribe:["admin@example.com?subject=subscribe",{url:"http://example.com",comment:"Subscribe",},],// List-Post: <http://example.com/post>, <mailto:admin@example.com?subject=post> (Post)post:[["http://example.com/post",{url:"admin@example.com?subject=post",comment:"Post",},],],},});console.log("List message sent ✔");}sendListMessage().catch(console.error);
constnodemailer=require("nodemailer");// 1. Create a transport (replace with your configuration)consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,auth:{user:"username",pass:"password",},});// 2. Send a message with various List-* headersasyncfunctionsendListMessage(){awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"List Message",text:"I hope no‑one unsubscribes from this list!",list:{// List-Help: <mailto:admin@example.com?subject=help>help:"admin@example.com?subject=help",// List-Unsubscribe: <http://example.com> (Comment)unsubscribe:{url:"http://example.com",comment:"Comment",},// List-Subscribe: <mailto:admin@example.com?subject=subscribe>// List-Subscribe: <http://example.com> (Subscribe)subscribe:["admin@example.com?subject=subscribe",{url:"http://example.com",comment:"Subscribe",},],// List-Post: <http://example.com/post>, <mailto:admin@example.com?subject=post> (Post)post:[["http://example.com/post",{url:"admin@example.com?subject=post",comment:"Post",},],],},});console.log("List message sent ✔");}sendListMessage().catch(console.error);
Resulting headers (excerpt)​
List-Help: <mailto:admin@example.com?subject=help>List-Unsubscribe: <http://example.com> (Comment)List-Subscribe: <mailto:admin@example.com?subject=subscribe>List-Subscribe: <http://example.com> (Subscribe)List-Post: <http://example.com/post>, <mailto:admin@example.com?subject=post> (Post)
List-Help: <mailto:admin@example.com?subject=help>List-Unsubscribe: <http://example.com> (Comment)List-Subscribe: <mailto:admin@example.com?subject=subscribe>List-Subscribe: <http://example.com> (Subscribe)List-Post: <http://example.com/post>, <mailto:admin@example.com?subject=post> (Post)
How it worksValue formats
Value formats
Complete exampleResulting headers (excerpt)
Resulting headers (excerpt)



===== https://nodemailer.com/message/list-headers#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
List headers
List headers
AddingRFC 2369List-*headers(such asList‑Help,List‑Unsubscribe, etc.) lets mailing‑list recipients quickly discover helpful actions provided by email clients. Nodemailer exposes alistmessage option so you can define these headers declaratively instead of hand‑crafting raw header lines.
List-*
List‑Help
List‑Unsubscribe
list
How it works​
Pass alistobject totransporter.sendMail(). Each key in that object becomes the correspondingList-*header name (case‑insensitive). For example,helpbecomes theList-Helpheader.
list
transporter.sendMail()
List-*
help
List-Help
Value formats​
string
<…>
{ url, comment }
Array< string | { url, comment } >
List-*
Array<Array<…>>
List-*values are inserted verbatim—lines aren’t folded and strings aren’t encoded. Stick to ASCII characters and be prepared for lengthy header lines.
List-*
Complete example​
constnodemailer=require("nodemailer");// 1. Create a transport (replace with your configuration)consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,auth:{user:"username",pass:"password",},});// 2. Send a message with various List-* headersasyncfunctionsendListMessage(){awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"List Message",text:"I hope no‑one unsubscribes from this list!",list:{// List-Help: <mailto:admin@example.com?subject=help>help:"admin@example.com?subject=help",// List-Unsubscribe: <http://example.com> (Comment)unsubscribe:{url:"http://example.com",comment:"Comment",},// List-Subscribe: <mailto:admin@example.com?subject=subscribe>// List-Subscribe: <http://example.com> (Subscribe)subscribe:["admin@example.com?subject=subscribe",{url:"http://example.com",comment:"Subscribe",},],// List-Post: <http://example.com/post>, <mailto:admin@example.com?subject=post> (Post)post:[["http://example.com/post",{url:"admin@example.com?subject=post",comment:"Post",},],],},});console.log("List message sent ✔");}sendListMessage().catch(console.error);
constnodemailer=require("nodemailer");// 1. Create a transport (replace with your configuration)consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,auth:{user:"username",pass:"password",},});// 2. Send a message with various List-* headersasyncfunctionsendListMessage(){awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"List Message",text:"I hope no‑one unsubscribes from this list!",list:{// List-Help: <mailto:admin@example.com?subject=help>help:"admin@example.com?subject=help",// List-Unsubscribe: <http://example.com> (Comment)unsubscribe:{url:"http://example.com",comment:"Comment",},// List-Subscribe: <mailto:admin@example.com?subject=subscribe>// List-Subscribe: <http://example.com> (Subscribe)subscribe:["admin@example.com?subject=subscribe",{url:"http://example.com",comment:"Subscribe",},],// List-Post: <http://example.com/post>, <mailto:admin@example.com?subject=post> (Post)post:[["http://example.com/post",{url:"admin@example.com?subject=post",comment:"Post",},],],},});console.log("List message sent ✔");}sendListMessage().catch(console.error);
Resulting headers (excerpt)​
List-Help: <mailto:admin@example.com?subject=help>List-Unsubscribe: <http://example.com> (Comment)List-Subscribe: <mailto:admin@example.com?subject=subscribe>List-Subscribe: <http://example.com> (Subscribe)List-Post: <http://example.com/post>, <mailto:admin@example.com?subject=post> (Post)
List-Help: <mailto:admin@example.com?subject=help>List-Unsubscribe: <http://example.com> (Comment)List-Subscribe: <mailto:admin@example.com?subject=subscribe>List-Subscribe: <http://example.com> (Subscribe)List-Post: <http://example.com/post>, <mailto:admin@example.com?subject=post> (Post)
How it worksValue formats
Value formats
Complete exampleResulting headers (excerpt)
Resulting headers (excerpt)



===== https://nodemailer.com/message/custom-headers =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Custom headers
Custom headers
Nodemailer generates all mandatory headers for you, so in day‑to‑day usage you rarely need to touch them.
When youdohave to add or override headers—either at themessage levelor for a singleattachment / alternative—use theheadersproperty.
headers
headers— an object whose key–value pairs become raw message headers.Keys are converted to their canonical header name (x-my-key➜X-My-Key).Values are encoded (non‑ASCII →mime‑word) and long lines are wrapped to max‑78 bytes unless you opt out withprepared.
headers— an object whose key–value pairs become raw message headers.
headers
Keys are converted to their canonical header name (x-my-key➜X-My-Key).
x-my-key
X-My-Key
Values are encoded (non‑ASCII →mime‑word) and long lines are wrapped to max‑78 bytes unless you opt out withprepared.
prepared
Donotsetprotected headerssuch asFrom,To,Subject,Date,Message-ID, or MIME boundary headers—Nodemailer will ignore or overwrite them.
From
To
Subject
Date
Message-ID
Examples​
1. Add simple custom headers​
constmessage={// other fields …headers:{"x-my-key":"header value","x-another-key":"another value",},};/*Results in:X-My-Key: header valueX-Another-Key: another value*/
constmessage={// other fields …headers:{"x-my-key":"header value","x-another-key":"another value",},};/*Results in:X-My-Key: header valueX-Another-Key: another value*/
2. Repeat the same header key​
Provide anArrayto create multiple header lines with thesame key:
Array
constmessage={// …headers:{"x-my-key":["value for row 1","value for row 2","value for row 3"],},};/*X-My-Key: value for row 1X-My-Key: value for row 2X-My-Key: value for row 3*/
constmessage={// …headers:{"x-my-key":["value for row 1","value for row 2","value for row 3"],},};/*X-My-Key: value for row 1X-My-Key: value for row 2X-My-Key: value for row 3*/
3. Bypass Nodemailer’s encoding & folding​
Setprepared: trueif you already took care of encoding / line‑wrapping yourself and want Nodemailer to pass the value throughverbatim.
prepared: true
constmessage={// …headers:{"x-processed":"a really long header or value with non‑ascii 🚀","x-unprocessed":{prepared:true,value:"a really long header or value with non‑ascii 🚀",},},};/*X-Processed: a really long header or value with non‑ascii =?UTF-8?Q?=F0=9F=9A=80?=X-Unprocessed: a really long header or value with non‑ascii 🚀*/
constmessage={// …headers:{"x-processed":"a really long header or value with non‑ascii 🚀","x-unprocessed":{prepared:true,value:"a really long header or value with non‑ascii 🚀",},},};/*X-Processed: a really long header or value with non‑ascii =?UTF-8?Q?=F0=9F=9A=80?=X-Unprocessed: a really long header or value with non‑ascii 🚀*/
4. Headers on an attachment​
headersis available inside any attachment or alternative object:
headers
constmessage={// …attachments:[{filename:"report.csv",content:csvBuffer,headers:{"x-report-id":"2025‑Q1",},},],};
constmessage={// …attachments:[{filename:"report.csv",content:csvBuffer,headers:{"x-report-id":"2025‑Q1",},},],};
Examples1. Add simple custom headers2. Repeat the same header key3. Bypass Nodemailer’s encoding & folding4. Headers on an attachment
1. Add simple custom headers
2. Repeat the same header key
3. Bypass Nodemailer’s encoding & folding
4. Headers on an attachment



===== https://nodemailer.com/message/custom-headers#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Custom headers
Custom headers
Nodemailer generates all mandatory headers for you, so in day‑to‑day usage you rarely need to touch them.
When youdohave to add or override headers—either at themessage levelor for a singleattachment / alternative—use theheadersproperty.
headers
headers— an object whose key–value pairs become raw message headers.Keys are converted to their canonical header name (x-my-key➜X-My-Key).Values are encoded (non‑ASCII →mime‑word) and long lines are wrapped to max‑78 bytes unless you opt out withprepared.
headers— an object whose key–value pairs become raw message headers.
headers
Keys are converted to their canonical header name (x-my-key➜X-My-Key).
x-my-key
X-My-Key
Values are encoded (non‑ASCII →mime‑word) and long lines are wrapped to max‑78 bytes unless you opt out withprepared.
prepared
Donotsetprotected headerssuch asFrom,To,Subject,Date,Message-ID, or MIME boundary headers—Nodemailer will ignore or overwrite them.
From
To
Subject
Date
Message-ID
Examples​
1. Add simple custom headers​
constmessage={// other fields …headers:{"x-my-key":"header value","x-another-key":"another value",},};/*Results in:X-My-Key: header valueX-Another-Key: another value*/
constmessage={// other fields …headers:{"x-my-key":"header value","x-another-key":"another value",},};/*Results in:X-My-Key: header valueX-Another-Key: another value*/
2. Repeat the same header key​
Provide anArrayto create multiple header lines with thesame key:
Array
constmessage={// …headers:{"x-my-key":["value for row 1","value for row 2","value for row 3"],},};/*X-My-Key: value for row 1X-My-Key: value for row 2X-My-Key: value for row 3*/
constmessage={// …headers:{"x-my-key":["value for row 1","value for row 2","value for row 3"],},};/*X-My-Key: value for row 1X-My-Key: value for row 2X-My-Key: value for row 3*/
3. Bypass Nodemailer’s encoding & folding​
Setprepared: trueif you already took care of encoding / line‑wrapping yourself and want Nodemailer to pass the value throughverbatim.
prepared: true
constmessage={// …headers:{"x-processed":"a really long header or value with non‑ascii 🚀","x-unprocessed":{prepared:true,value:"a really long header or value with non‑ascii 🚀",},},};/*X-Processed: a really long header or value with non‑ascii =?UTF-8?Q?=F0=9F=9A=80?=X-Unprocessed: a really long header or value with non‑ascii 🚀*/
constmessage={// …headers:{"x-processed":"a really long header or value with non‑ascii 🚀","x-unprocessed":{prepared:true,value:"a really long header or value with non‑ascii 🚀",},},};/*X-Processed: a really long header or value with non‑ascii =?UTF-8?Q?=F0=9F=9A=80?=X-Unprocessed: a really long header or value with non‑ascii 🚀*/
4. Headers on an attachment​
headersis available inside any attachment or alternative object:
headers
constmessage={// …attachments:[{filename:"report.csv",content:csvBuffer,headers:{"x-report-id":"2025‑Q1",},},],};
constmessage={// …attachments:[{filename:"report.csv",content:csvBuffer,headers:{"x-report-id":"2025‑Q1",},},],};
Examples1. Add simple custom headers2. Repeat the same header key3. Bypass Nodemailer’s encoding & folding4. Headers on an attachment
1. Add simple custom headers
2. Repeat the same header key
3. Bypass Nodemailer’s encoding & folding
4. Headers on an attachment



===== https://nodemailer.com/message/custom-source =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Custom source
Custom source
When you already have a fully‑formatted RFC 822/EML message—perhaps because it was composed elsewhere or fetched from storage—you can hand it to Nodemailer verbatim with therawoption. Nodemailer will bypass its normal MIME generation and deliver exactly what you supply.
You can userawat three levels:
Whole message— supply a single RFC 822 document.
Per alternative— supply atext/plain,text/html, or other MIME alternative that you built yourself.
text/plain
text/html
Per attachment— supply an attachment body, complete with its own headers.
When you userawfor theentiremessage, you must also setenvelope.fromandenvelope.toso that the SMTP transaction has the correct sender and recipients. These values arenotextracted from the raw source.
envelope.from
envelope.to
Examples​
1. String as the entire message​
constmessage={envelope:{from:"sender@example.com",to:["recipient@example.com"],},raw:`From: sender@example.comTo: recipient@example.comSubject: Hello worldHello world!`,};
constmessage={envelope:{from:"sender@example.com",to:["recipient@example.com"],},raw:`From: sender@example.comTo: recipient@example.comSubject: Hello worldHello world!`,};
Nodemailer will normalise new‑lines for you, so plain\nis fine.
\n
2. EML file as the entire message​
constmessage={envelope:{from:"sender@example.com",to:["recipient@example.com"],},raw:{path:"/path/to/message.eml",// absolute or relative to process.cwd()},};
constmessage={envelope:{from:"sender@example.com",to:["recipient@example.com"],},raw:{path:"/path/to/message.eml",// absolute or relative to process.cwd()},};
3. String as an attachment​
Whenrawis used insideattachments[], includeallof the MIME headers yourself. Nodemailerdoes notaddContent‑Type,Content‑Disposition, or any other headers.
attachments[]
Content‑Type
Content‑Disposition
constmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Custom attachment",attachments:[{raw:`Content-Type: text/plainContent-Disposition: attachment; filename="notes.txt"Attached text file`,},],};
constmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Custom attachment",attachments:[{raw:`Content-Type: text/plainContent-Disposition: attachment; filename="notes.txt"Attached text file`,},],};
Examples1. String as the entire message2. EML file as the entire message3. String as an attachment
1. String as the entire message
2. EML file as the entire message
3. String as an attachment



===== https://nodemailer.com/message/custom-source#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configurationAttachmentsAlternativesAddress objectCalendar eventsEmbedded imagesList headersCustom headersCustom source
Attachments
Alternatives
Address object
Calendar events
Embedded images
List headers
Custom headers
Custom source
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Message configuration
Custom source
Custom source
When you already have a fully‑formatted RFC 822/EML message—perhaps because it was composed elsewhere or fetched from storage—you can hand it to Nodemailer verbatim with therawoption. Nodemailer will bypass its normal MIME generation and deliver exactly what you supply.
You can userawat three levels:
Whole message— supply a single RFC 822 document.
Per alternative— supply atext/plain,text/html, or other MIME alternative that you built yourself.
text/plain
text/html
Per attachment— supply an attachment body, complete with its own headers.
When you userawfor theentiremessage, you must also setenvelope.fromandenvelope.toso that the SMTP transaction has the correct sender and recipients. These values arenotextracted from the raw source.
envelope.from
envelope.to
Examples​
1. String as the entire message​
constmessage={envelope:{from:"sender@example.com",to:["recipient@example.com"],},raw:`From: sender@example.comTo: recipient@example.comSubject: Hello worldHello world!`,};
constmessage={envelope:{from:"sender@example.com",to:["recipient@example.com"],},raw:`From: sender@example.comTo: recipient@example.comSubject: Hello worldHello world!`,};
Nodemailer will normalise new‑lines for you, so plain\nis fine.
\n
2. EML file as the entire message​
constmessage={envelope:{from:"sender@example.com",to:["recipient@example.com"],},raw:{path:"/path/to/message.eml",// absolute or relative to process.cwd()},};
constmessage={envelope:{from:"sender@example.com",to:["recipient@example.com"],},raw:{path:"/path/to/message.eml",// absolute or relative to process.cwd()},};
3. String as an attachment​
Whenrawis used insideattachments[], includeallof the MIME headers yourself. Nodemailerdoes notaddContent‑Type,Content‑Disposition, or any other headers.
attachments[]
Content‑Type
Content‑Disposition
constmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Custom attachment",attachments:[{raw:`Content-Type: text/plainContent-Disposition: attachment; filename="notes.txt"Attached text file`,},],};
constmessage={from:"sender@example.com",to:"recipient@example.com",subject:"Custom attachment",attachments:[{raw:`Content-Type: text/plainContent-Disposition: attachment; filename="notes.txt"Attached text file`,},],};
Examples1. String as the entire message2. EML file as the entire message3. String as an attachment
1. String as the entire message
2. EML file as the entire message
3. String as an attachment



===== https://nodemailer.com/smtp =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
SMTP transport
SMTP is the main transport in Nodemailer for delivering messages. SMTP is also the protocol used between different email hosts, so it's truly universal. Almost every email delivery provider supports SMTP-based sending, even when they advertise API‑based sending as the primary option. APIs can offer more features, but they also introduce vendor lock‑in. With SMTP you can usually swap providers by changing only the configuration object or connection URL.
Creating a transport​
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport(options[,defaults]);
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport(options[,defaults]);
options– object that defines the connection (detailed below).
options
defaults– object merged into every message object (for example, you can set a commonfromaddress).
defaults
You can also pass a connection URL instead of an options object. Use thesmtp:orsmtps:protocol in the URL.
constpoolConfig="smtps://username:password@smtp.example.com/?pool=true";consttransporter=nodemailer.createTransport(poolConfig);
constpoolConfig="smtps://username:password@smtp.example.com/?pool=true";consttransporter=nodemailer.createTransport(poolConfig);
General options​
host
string
"localhost"
port
number
587
465
secure: true
secure
boolean
false
true
service
string
"gmail"
host
port
secure
auth
object
authMethod
string
"PLAIN"
Nodemailer resolves thehostvalue withdns.resolve(). If you pointhostto an IP address that isnotresolvable (for example, it is defined in/etc/hosts), also settls.servernameto the real hostname. TLS validation continues to work even though a DNS lookup is skipped.
host
dns.resolve()
host
tls.servername
TLS options​
secure
boolean
false
tls
object
TLSSocket
{ rejectUnauthorized: true }
tls.servername
string
host
ignoreTLS
boolean
false
requireTLS
boolean
false
Settingsecure: falsedoesnotnecessarily mean you are sending in plaintext—most servers automatically upgrade to TLS via theSTARTTLScommand. Nodemailer follows the server’s lead unlessignoreTLSis set.
secure: false
ignoreTLS
Connection options​
name
HELO
EHLO
localAddress
connectionTimeout
greetingTimeout
socketTimeout
dnsTimeout
Debug options​
logger
object
boolean
true
false
debug
boolean
true
Custom logger
If you want to use some specific logger, you can wrap it into Nodemailer-compatible logger object.
constsmtpLogger={};// Set up logger wrapperfor(letlevelof['trace','debug','info','warn','error','fatal']){smtpLogger[level]=(data,message,...args)=>{if(args&&args.length){message=util.format(message,...args);}data.msg=message;data.src='nodemailer';if(typeofpinoLogger[level]==='function'){pinoLogger[level](data);}else{pinoLogger.debug(data);}};}nodemailer.createTransport({...,logger:smtpLogger})
constsmtpLogger={};// Set up logger wrapperfor(letlevelof['trace','debug','info','warn','error','fatal']){smtpLogger[level]=(data,message,...args)=>{if(args&&args.length){message=util.format(message,...args);}data.msg=message;data.src='nodemailer';if(typeofpinoLogger[level]==='function'){pinoLogger[level](data);}else{pinoLogger.debug(data);}};}nodemailer.createTransport({...,logger:smtpLogger})
Security options​
disableFileAccess
boolean
disableUrlAccess
boolean
Pooling options​
SeePooled SMTPfor the complete list. The most important flag is:
pool
boolean
Proxy options​
All SMTP transports support proxies. Read more inUsing proxies.
Examples​
1. Single connection​
A new SMTP connection is created for every message:
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,secure:false,// upgrade later with STARTTLSauth:{user:"username",pass:"password",},});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,secure:false,// upgrade later with STARTTLSauth:{user:"username",pass:"password",},});
2. Pooled connections​
Keep a pool of connections open against an SMTP server on port 465:
consttransporter=nodemailer.createTransport({pool:true,host:"smtp.example.com",port:465,secure:true,// use TLSauth:{user:"username",pass:"password",},});
consttransporter=nodemailer.createTransport({pool:true,host:"smtp.example.com",port:465,secure:true,// use TLSauth:{user:"username",pass:"password",},});
3. Allow self‑signed certificates​
Connect to a TLS server that uses a self‑signed or otherwise invalid certificate:
consttransporter=nodemailer.createTransport({host:"my.smtp.host",port:465,secure:true,auth:{user:"username",pass:"pass",},tls:{// do not fail on invalid certsrejectUnauthorized:false,},});
consttransporter=nodemailer.createTransport({host:"my.smtp.host",port:465,secure:true,auth:{user:"username",pass:"pass",},tls:{// do not fail on invalid certsrejectUnauthorized:false,},});
Authentication​
If theauthobject is omitted, Nodemailer treats the connection as already authenticated.
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,});
Login​
auth:{type:"login",// defaultuser:"username",pass:"password",}
auth:{type:"login",// defaultuser:"username",pass:"password",}
OAuth 2.0​
auth:{type:"oauth2",user:"user@example.com",accessToken:"generated_access_token",expires:1484314697598,}
auth:{type:"oauth2",user:"user@example.com",accessToken:"generated_access_token",expires:1484314697598,}
See the dedicatedOAuth 2.0 guidefor details, or implement acustom authentication handlerif your protocol is not natively supported (see theNTLM handlerfor an example).
Verifying the configuration​
Usetransporter.verify()to make sure the SMTP configuration works.
transporter.verify()
// Promise style (Node.js 8+)try{awaittransporter.verify();console.log("Server is ready to take our messages");}catch(err){console.error("Verification failed",err);}// Callback styletransporter.verify((error,success)=>{if(error){console.error(error);}else{console.log("Server is ready to take our messages");}});
// Promise style (Node.js 8+)try{awaittransporter.verify();console.log("Server is ready to take our messages");}catch(err){console.error("Verification failed",err);}// Callback styletransporter.verify((error,success)=>{if(error){console.error(error);}else{console.log("Server is ready to take our messages");}});
verify()checks DNS resolution, the TCP handshake, and authentication. It doesnotvalidate whether the service allows a specific envelopeFromaddress—that depends on the server configuration.
verify()
Creating a transportGeneral optionsTLS optionsConnection optionsDebug optionsSecurity optionsPooling optionsProxy options
General options
TLS options
Connection options
Debug options
Security options
Pooling options
Proxy options
Examples1. Single connection2. Pooled connections3. Allow self‑signed certificates
1. Single connection
2. Pooled connections
3. Allow self‑signed certificates
AuthenticationLoginOAuth 2.0
Login
OAuth 2.0
Verifying the configuration



===== https://nodemailer.com/smtp#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
SMTP transport
SMTP is the main transport in Nodemailer for delivering messages. SMTP is also the protocol used between different email hosts, so it's truly universal. Almost every email delivery provider supports SMTP-based sending, even when they advertise API‑based sending as the primary option. APIs can offer more features, but they also introduce vendor lock‑in. With SMTP you can usually swap providers by changing only the configuration object or connection URL.
Creating a transport​
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport(options[,defaults]);
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport(options[,defaults]);
options– object that defines the connection (detailed below).
options
defaults– object merged into every message object (for example, you can set a commonfromaddress).
defaults
You can also pass a connection URL instead of an options object. Use thesmtp:orsmtps:protocol in the URL.
constpoolConfig="smtps://username:password@smtp.example.com/?pool=true";consttransporter=nodemailer.createTransport(poolConfig);
constpoolConfig="smtps://username:password@smtp.example.com/?pool=true";consttransporter=nodemailer.createTransport(poolConfig);
General options​
host
string
"localhost"
port
number
587
465
secure: true
secure
boolean
false
true
service
string
"gmail"
host
port
secure
auth
object
authMethod
string
"PLAIN"
Nodemailer resolves thehostvalue withdns.resolve(). If you pointhostto an IP address that isnotresolvable (for example, it is defined in/etc/hosts), also settls.servernameto the real hostname. TLS validation continues to work even though a DNS lookup is skipped.
host
dns.resolve()
host
tls.servername
TLS options​
secure
boolean
false
tls
object
TLSSocket
{ rejectUnauthorized: true }
tls.servername
string
host
ignoreTLS
boolean
false
requireTLS
boolean
false
Settingsecure: falsedoesnotnecessarily mean you are sending in plaintext—most servers automatically upgrade to TLS via theSTARTTLScommand. Nodemailer follows the server’s lead unlessignoreTLSis set.
secure: false
ignoreTLS
Connection options​
name
HELO
EHLO
localAddress
connectionTimeout
greetingTimeout
socketTimeout
dnsTimeout
Debug options​
logger
object
boolean
true
false
debug
boolean
true
Custom logger
If you want to use some specific logger, you can wrap it into Nodemailer-compatible logger object.
constsmtpLogger={};// Set up logger wrapperfor(letlevelof['trace','debug','info','warn','error','fatal']){smtpLogger[level]=(data,message,...args)=>{if(args&&args.length){message=util.format(message,...args);}data.msg=message;data.src='nodemailer';if(typeofpinoLogger[level]==='function'){pinoLogger[level](data);}else{pinoLogger.debug(data);}};}nodemailer.createTransport({...,logger:smtpLogger})
constsmtpLogger={};// Set up logger wrapperfor(letlevelof['trace','debug','info','warn','error','fatal']){smtpLogger[level]=(data,message,...args)=>{if(args&&args.length){message=util.format(message,...args);}data.msg=message;data.src='nodemailer';if(typeofpinoLogger[level]==='function'){pinoLogger[level](data);}else{pinoLogger.debug(data);}};}nodemailer.createTransport({...,logger:smtpLogger})
Security options​
disableFileAccess
boolean
disableUrlAccess
boolean
Pooling options​
SeePooled SMTPfor the complete list. The most important flag is:
pool
boolean
Proxy options​
All SMTP transports support proxies. Read more inUsing proxies.
Examples​
1. Single connection​
A new SMTP connection is created for every message:
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,secure:false,// upgrade later with STARTTLSauth:{user:"username",pass:"password",},});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,secure:false,// upgrade later with STARTTLSauth:{user:"username",pass:"password",},});
2. Pooled connections​
Keep a pool of connections open against an SMTP server on port 465:
consttransporter=nodemailer.createTransport({pool:true,host:"smtp.example.com",port:465,secure:true,// use TLSauth:{user:"username",pass:"password",},});
consttransporter=nodemailer.createTransport({pool:true,host:"smtp.example.com",port:465,secure:true,// use TLSauth:{user:"username",pass:"password",},});
3. Allow self‑signed certificates​
Connect to a TLS server that uses a self‑signed or otherwise invalid certificate:
consttransporter=nodemailer.createTransport({host:"my.smtp.host",port:465,secure:true,auth:{user:"username",pass:"pass",},tls:{// do not fail on invalid certsrejectUnauthorized:false,},});
consttransporter=nodemailer.createTransport({host:"my.smtp.host",port:465,secure:true,auth:{user:"username",pass:"pass",},tls:{// do not fail on invalid certsrejectUnauthorized:false,},});
Authentication​
If theauthobject is omitted, Nodemailer treats the connection as already authenticated.
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,});
Login​
auth:{type:"login",// defaultuser:"username",pass:"password",}
auth:{type:"login",// defaultuser:"username",pass:"password",}
OAuth 2.0​
auth:{type:"oauth2",user:"user@example.com",accessToken:"generated_access_token",expires:1484314697598,}
auth:{type:"oauth2",user:"user@example.com",accessToken:"generated_access_token",expires:1484314697598,}
See the dedicatedOAuth 2.0 guidefor details, or implement acustom authentication handlerif your protocol is not natively supported (see theNTLM handlerfor an example).
Verifying the configuration​
Usetransporter.verify()to make sure the SMTP configuration works.
transporter.verify()
// Promise style (Node.js 8+)try{awaittransporter.verify();console.log("Server is ready to take our messages");}catch(err){console.error("Verification failed",err);}// Callback styletransporter.verify((error,success)=>{if(error){console.error(error);}else{console.log("Server is ready to take our messages");}});
// Promise style (Node.js 8+)try{awaittransporter.verify();console.log("Server is ready to take our messages");}catch(err){console.error("Verification failed",err);}// Callback styletransporter.verify((error,success)=>{if(error){console.error(error);}else{console.log("Server is ready to take our messages");}});
verify()checks DNS resolution, the TCP handshake, and authentication. It doesnotvalidate whether the service allows a specific envelopeFromaddress—that depends on the server configuration.
verify()
Creating a transportGeneral optionsTLS optionsConnection optionsDebug optionsSecurity optionsPooling optionsProxy options
General options
TLS options
Connection options
Debug options
Security options
Pooling options
Proxy options
Examples1. Single connection2. Pooled connections3. Allow self‑signed certificates
1. Single connection
2. Pooled connections
3. Allow self‑signed certificates
AuthenticationLoginOAuth 2.0
Login
OAuth 2.0
Verifying the configuration



===== https://nodemailer.com/smtp/envelope =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
SMTP envelope
SMTP envelope
When Nodemailer delivers an email over SMTP it sendstwo distinct layersof information:
Message headersthat your email client shows (From:,To:, etc.).
From:
To:
SMTP envelope commands(MAIL FROM,RCPT TO) that the SMTP server actually uses to route and return the message.
MAIL FROM
RCPT TO
By default, Nodemailerbuilds the envelope automaticallyfrom thefrom,to,cc, andbccheader fields. 
If you need fine‑grained control—for example to implementVERP, to set a dedicated bounce address, or to send a message to recipients that you donotreveal in the headers—you can override the defaults with theenvelopeproperty.
from
to
cc
bcc
envelope
Theenvelopeproperty​
envelope
{envelope:{from:'bounce+12345@example.com',// becomes MAIL FROM:to:[// becomes RCPT TO:'alice@example.com','Bob <bob@example.net>']}}
{envelope:{from:'bounce+12345@example.com',// becomes MAIL FROM:to:[// becomes RCPT TO:'alice@example.com','Bob <bob@example.net>']}}
from
string
MAIL FROM
to
string | string[]
RCPT TO
cc
string | string[]
to
bcc
string | string[]
to
Any address format that Nodemailer supports—plain,Name <address>pairs, or international (UTF‑8) domains—can be used here.
Name <address>
Complete example​
constnodemailer=require("nodemailer");asyncfunctionmain(){// Create a transport. Replace with your own transport options.consttransport=nodemailer.createTransport({sendmail:true,});constinfo=awaittransport.sendMail({from:"Mailer <mailer@example.com>",// Header From:to:"Daemon <daemon@example.com>",// Header To:envelope:{from:"bounce+12345@example.com",// MAIL FROM:to:[// RCPT TO:"daemon@example.com","mailer@example.com",],},subject:"Custom SMTP envelope",text:"Hello!",});console.log("Envelope used:",info.envelope);// => { from: 'bounce+12345@example.com', to: [ 'daemon@example.com', 'mailer@example.com' ] }}main().catch(console.error);
constnodemailer=require("nodemailer");asyncfunctionmain(){// Create a transport. Replace with your own transport options.consttransport=nodemailer.createTransport({sendmail:true,});constinfo=awaittransport.sendMail({from:"Mailer <mailer@example.com>",// Header From:to:"Daemon <daemon@example.com>",// Header To:envelope:{from:"bounce+12345@example.com",// MAIL FROM:to:[// RCPT TO:"daemon@example.com","mailer@example.com",],},subject:"Custom SMTP envelope",text:"Hello!",});console.log("Envelope used:",info.envelope);// => { from: 'bounce+12345@example.com', to: [ 'daemon@example.com', 'mailer@example.com' ] }}main().catch(console.error);
The object returned bysendMail()always includes anenvelopeproperty. It containsfrom(a string) andto(an array). When sending, Nodemailer mergesallrecipients fromto,cc, andbccinto that singletoarray.
sendMail()
envelope
from
to
to
cc
bcc
to
When should I override the envelope?​
VERP or bounce management– route bounces to a unique per‑message address.
Mailing lists– deliver the same message to many recipients while hiding the list in the header.
Different return‑path– use one domain in the headers but another for bounce processing.
If you do not have a specific reason, let Nodemailer generate the envelope automatically.
TheenvelopepropertyComplete exampleWhen should I override the envelope?
envelope
Complete example
When should I override the envelope?



===== https://nodemailer.com/smtp/envelope#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
SMTP envelope
SMTP envelope
When Nodemailer delivers an email over SMTP it sendstwo distinct layersof information:
Message headersthat your email client shows (From:,To:, etc.).
From:
To:
SMTP envelope commands(MAIL FROM,RCPT TO) that the SMTP server actually uses to route and return the message.
MAIL FROM
RCPT TO
By default, Nodemailerbuilds the envelope automaticallyfrom thefrom,to,cc, andbccheader fields. 
If you need fine‑grained control—for example to implementVERP, to set a dedicated bounce address, or to send a message to recipients that you donotreveal in the headers—you can override the defaults with theenvelopeproperty.
from
to
cc
bcc
envelope
Theenvelopeproperty​
envelope
{envelope:{from:'bounce+12345@example.com',// becomes MAIL FROM:to:[// becomes RCPT TO:'alice@example.com','Bob <bob@example.net>']}}
{envelope:{from:'bounce+12345@example.com',// becomes MAIL FROM:to:[// becomes RCPT TO:'alice@example.com','Bob <bob@example.net>']}}
from
string
MAIL FROM
to
string | string[]
RCPT TO
cc
string | string[]
to
bcc
string | string[]
to
Any address format that Nodemailer supports—plain,Name <address>pairs, or international (UTF‑8) domains—can be used here.
Name <address>
Complete example​
constnodemailer=require("nodemailer");asyncfunctionmain(){// Create a transport. Replace with your own transport options.consttransport=nodemailer.createTransport({sendmail:true,});constinfo=awaittransport.sendMail({from:"Mailer <mailer@example.com>",// Header From:to:"Daemon <daemon@example.com>",// Header To:envelope:{from:"bounce+12345@example.com",// MAIL FROM:to:[// RCPT TO:"daemon@example.com","mailer@example.com",],},subject:"Custom SMTP envelope",text:"Hello!",});console.log("Envelope used:",info.envelope);// => { from: 'bounce+12345@example.com', to: [ 'daemon@example.com', 'mailer@example.com' ] }}main().catch(console.error);
constnodemailer=require("nodemailer");asyncfunctionmain(){// Create a transport. Replace with your own transport options.consttransport=nodemailer.createTransport({sendmail:true,});constinfo=awaittransport.sendMail({from:"Mailer <mailer@example.com>",// Header From:to:"Daemon <daemon@example.com>",// Header To:envelope:{from:"bounce+12345@example.com",// MAIL FROM:to:[// RCPT TO:"daemon@example.com","mailer@example.com",],},subject:"Custom SMTP envelope",text:"Hello!",});console.log("Envelope used:",info.envelope);// => { from: 'bounce+12345@example.com', to: [ 'daemon@example.com', 'mailer@example.com' ] }}main().catch(console.error);
The object returned bysendMail()always includes anenvelopeproperty. It containsfrom(a string) andto(an array). When sending, Nodemailer mergesallrecipients fromto,cc, andbccinto that singletoarray.
sendMail()
envelope
from
to
to
cc
bcc
to
When should I override the envelope?​
VERP or bounce management– route bounces to a unique per‑message address.
Mailing lists– deliver the same message to many recipients while hiding the list in the header.
Different return‑path– use one domain in the headers but another for bounce processing.
If you do not have a specific reason, let Nodemailer generate the envelope automatically.
TheenvelopepropertyComplete exampleWhen should I override the envelope?
envelope
Complete example
When should I override the envelope?



===== https://nodemailer.com/smtp/pooled =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
Pooled SMTP Connections
Pooled SMTP Connections
UsingpooledSMTP connections keeps a fixed number of TCP/TLS connections open to the SMTP server and re‑uses them for every message. This dramatically reduces TLS hand‑shake latency and is perfect when either
you need to blast out alargebatch of e‑mails, or
your provider caps the number of parallel connections you’re allowed to use.
Quick example​
constnodemailer=require("nodemailer");/*** One shared transporter for your whole process.* The transporter will automatically open up to `maxConnections`* sockets and keep them warm.*/consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,pool:true,// ♻️  enable connection poolingmaxConnections:5,// optional – defaults to 5maxMessages:100,// optional – defaults to 100auth:{user:process.env.SMTP_USER,pass:process.env.SMTP_PASS,},});// Somewhere in your code – *do not* create a new transporter each timeawaittransporter.sendMail({from:"Newsletters <noreply@example.com>",to:"alice@example.com",subject:"Hello pooled world",text:"Hi Alice! 👋",});
constnodemailer=require("nodemailer");/*** One shared transporter for your whole process.* The transporter will automatically open up to `maxConnections`* sockets and keep them warm.*/consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,pool:true,// ♻️  enable connection poolingmaxConnections:5,// optional – defaults to 5maxMessages:100,// optional – defaults to 100auth:{user:process.env.SMTP_USER,pass:process.env.SMTP_PASS,},});// Somewhere in your code – *do not* create a new transporter each timeawaittransporter.sendMail({from:"Newsletters <noreply@example.com>",to:"alice@example.com",subject:"Hello pooled world",text:"Hi Alice! 👋",});
Transport options​
pool
boolean
false
maxConnections
number
5
maxMessages
number
100
The following options aredeprecatedand will be removed in a future major release:
rateDelta– size of the time window (ms) used for rate limiting (default:1000).
rateDelta
1000
rateLimit– how many messages may be sent during onerateDeltawindow. The limit is shared betweenallpooled connections.
rateLimit
rateDelta
Runtime helpers​
transporter.isIdle()→boolean​
transporter.isIdle()
boolean
Returnstrueif at least one connection slot is free.
true
transporter.close()​
transporter.close()
Closesallactive connections immediately and drains the message queue. Idle connections are normally closed automatically aftersocketTimeout, so calling this manually is rarely required.
socketTimeout
// Graceful shutdownprocess.on("SIGTERM",async()=>{awaittransporter.close();process.exit(0);});
// Graceful shutdownprocess.on("SIGTERM",async()=>{awaittransporter.close();process.exit(0);});
Event:idle​
idle
The transporter emits anidleevent whenever a connection slot becomes available. This allows you to implementpush‑stylesenders that pull messages from an external queue only when Nodemailer is ready for them:
idle
const{getNextMessage}=require("./messageQueue");transporter.on("idle",async()=>{while(transporter.isIdle()){constmessage=awaitgetNextMessage();if(!message)return;// queue is emptytry{awaittransporter.sendMail(message);}catch(err){console.error("❌  Failed to send",err);}}});
const{getNextMessage}=require("./messageQueue");transporter.on("idle",async()=>{while(transporter.isIdle()){constmessage=awaitgetNextMessage();if(!message)return;// queue is emptytry{awaittransporter.sendMail(message);}catch(err){console.error("❌  Failed to send",err);}}});
Best practices​
Create one transporterandreuse it– every newcreateTransport()call spawns itsownpool.
createTransport()
AdjustmaxConnectionsandmaxMessagesto match the policy of your SMTP provider.
maxConnections
maxMessages
Handle back‑pressureusing theidleevent instead of pushing thousands of messages into memory.
idle
Close the poolon graceful shutdown so that your process exits promptly.
Quick example
Transport options
Runtime helperstransporter.isIdle()→booleantransporter.close()
transporter.isIdle()→boolean
transporter.isIdle()
boolean
transporter.close()
transporter.close()
Event:idleBest practices
idle
Best practices



===== https://nodemailer.com/smtp/pooled#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
Pooled SMTP Connections
Pooled SMTP Connections
UsingpooledSMTP connections keeps a fixed number of TCP/TLS connections open to the SMTP server and re‑uses them for every message. This dramatically reduces TLS hand‑shake latency and is perfect when either
you need to blast out alargebatch of e‑mails, or
your provider caps the number of parallel connections you’re allowed to use.
Quick example​
constnodemailer=require("nodemailer");/*** One shared transporter for your whole process.* The transporter will automatically open up to `maxConnections`* sockets and keep them warm.*/consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,pool:true,// ♻️  enable connection poolingmaxConnections:5,// optional – defaults to 5maxMessages:100,// optional – defaults to 100auth:{user:process.env.SMTP_USER,pass:process.env.SMTP_PASS,},});// Somewhere in your code – *do not* create a new transporter each timeawaittransporter.sendMail({from:"Newsletters <noreply@example.com>",to:"alice@example.com",subject:"Hello pooled world",text:"Hi Alice! 👋",});
constnodemailer=require("nodemailer");/*** One shared transporter for your whole process.* The transporter will automatically open up to `maxConnections`* sockets and keep them warm.*/consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,pool:true,// ♻️  enable connection poolingmaxConnections:5,// optional – defaults to 5maxMessages:100,// optional – defaults to 100auth:{user:process.env.SMTP_USER,pass:process.env.SMTP_PASS,},});// Somewhere in your code – *do not* create a new transporter each timeawaittransporter.sendMail({from:"Newsletters <noreply@example.com>",to:"alice@example.com",subject:"Hello pooled world",text:"Hi Alice! 👋",});
Transport options​
pool
boolean
false
maxConnections
number
5
maxMessages
number
100
The following options aredeprecatedand will be removed in a future major release:
rateDelta– size of the time window (ms) used for rate limiting (default:1000).
rateDelta
1000
rateLimit– how many messages may be sent during onerateDeltawindow. The limit is shared betweenallpooled connections.
rateLimit
rateDelta
Runtime helpers​
transporter.isIdle()→boolean​
transporter.isIdle()
boolean
Returnstrueif at least one connection slot is free.
true
transporter.close()​
transporter.close()
Closesallactive connections immediately and drains the message queue. Idle connections are normally closed automatically aftersocketTimeout, so calling this manually is rarely required.
socketTimeout
// Graceful shutdownprocess.on("SIGTERM",async()=>{awaittransporter.close();process.exit(0);});
// Graceful shutdownprocess.on("SIGTERM",async()=>{awaittransporter.close();process.exit(0);});
Event:idle​
idle
The transporter emits anidleevent whenever a connection slot becomes available. This allows you to implementpush‑stylesenders that pull messages from an external queue only when Nodemailer is ready for them:
idle
const{getNextMessage}=require("./messageQueue");transporter.on("idle",async()=>{while(transporter.isIdle()){constmessage=awaitgetNextMessage();if(!message)return;// queue is emptytry{awaittransporter.sendMail(message);}catch(err){console.error("❌  Failed to send",err);}}});
const{getNextMessage}=require("./messageQueue");transporter.on("idle",async()=>{while(transporter.isIdle()){constmessage=awaitgetNextMessage();if(!message)return;// queue is emptytry{awaittransporter.sendMail(message);}catch(err){console.error("❌  Failed to send",err);}}});
Best practices​
Create one transporterandreuse it– every newcreateTransport()call spawns itsownpool.
createTransport()
AdjustmaxConnectionsandmaxMessagesto match the policy of your SMTP provider.
maxConnections
maxMessages
Handle back‑pressureusing theidleevent instead of pushing thousands of messages into memory.
idle
Close the poolon graceful shutdown so that your process exits promptly.
Quick example
Transport options
Runtime helperstransporter.isIdle()→booleantransporter.close()
transporter.isIdle()→boolean
transporter.isIdle()
boolean
transporter.close()
transporter.close()
Event:idleBest practices
idle
Best practices



===== https://nodemailer.com/smtp/testing =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
Testing SMTP
Testing SMTP
When you need to exercise the email‑sending paths of your application in a development or continuous‑integration environment, youmust notaccidentally spam real inboxes. Instead of routing all mail to a single hard‑coded test address, point your code at amail‑catcherservice: it accepts messages over SMTP exactly like a production provider, butneverdelivers them. It just stores the messages so that you can open or download them later.
Nodemailer ships with first‑class support forEthereal Email— a free, open‑source mail‑catcher designed for test environments. You can either
provision an account on the flywithcreateTestAccount, or
createTestAccount
create a persistent test mailboxfrom the Ethereal dashboard.
If you would rather stay completely offline you can preview messages locally withforwardemail/email‑templates(it renders every message in your browser and iOS simulator viapreview-email).
Quick‑start​
Install Nodemailer if you have not done so yet:
npm install nodemailer
npm install nodemailer
1. Spin up a throw‑away Ethereal account​
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
Ethereal automatically deletes an account after48 hours of inactivity. Save the generated credentials somewhere if you want to inspect the messages later via the dashboard.
2. Switch transports per environment​
You only need one place in your code base that knows which SMTP credentials to use. Everything else just callscreateTransport().
createTransport()
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
Your application code can treat the transporter as a black box:
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
3. Inspect the message​
WhensendMailresolves (or its callback fires), the returnedinfoobject contains everything you need to locate the message inside Ethereal:
sendMail
info
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
You can also openMessages → Inboxin Ethereal’s dashboard and browse around.
Below is what a captured message looks like in the Ethereal UI.
Quick‑start1. Spin up a throw‑away Ethereal account2. Switch transports per environment3. Inspect the message
1. Spin up a throw‑away Ethereal account
2. Switch transports per environment
3. Inspect the message



===== https://nodemailer.com/smtp/testing#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
Testing SMTP
Testing SMTP
When you need to exercise the email‑sending paths of your application in a development or continuous‑integration environment, youmust notaccidentally spam real inboxes. Instead of routing all mail to a single hard‑coded test address, point your code at amail‑catcherservice: it accepts messages over SMTP exactly like a production provider, butneverdelivers them. It just stores the messages so that you can open or download them later.
Nodemailer ships with first‑class support forEthereal Email— a free, open‑source mail‑catcher designed for test environments. You can either
provision an account on the flywithcreateTestAccount, or
createTestAccount
create a persistent test mailboxfrom the Ethereal dashboard.
If you would rather stay completely offline you can preview messages locally withforwardemail/email‑templates(it renders every message in your browser and iOS simulator viapreview-email).
Quick‑start​
Install Nodemailer if you have not done so yet:
npm install nodemailer
npm install nodemailer
1. Spin up a throw‑away Ethereal account​
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
Ethereal automatically deletes an account after48 hours of inactivity. Save the generated credentials somewhere if you want to inspect the messages later via the dashboard.
2. Switch transports per environment​
You only need one place in your code base that knows which SMTP credentials to use. Everything else just callscreateTransport().
createTransport()
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
Your application code can treat the transporter as a black box:
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
3. Inspect the message​
WhensendMailresolves (or its callback fires), the returnedinfoobject contains everything you need to locate the message inside Ethereal:
sendMail
info
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
You can also openMessages → Inboxin Ethereal’s dashboard and browse around.
Below is what a captured message looks like in the Ethereal UI.
Quick‑start1. Spin up a throw‑away Ethereal account2. Switch transports per environment3. Inspect the message
1. Spin up a throw‑away Ethereal account
2. Switch transports per environment
3. Inspect the message



===== https://nodemailer.com/smtp/oauth2 =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
OAuth2
OAuth2
OAuth2 lets your application use short‑lived access tokens instead of passwords. Tokens are scoped, revocable, and regenerable, so a leaked token causes far less harm than a leaked password.
Provider‑agnostic OAuth2 authentication
Gmail‑specific helpers
Managing OAuth2 app credentials is painful. LetEmailEnginehandle them for you. Once an account is registered with EmailEngine, you can point Nodemailer to EmailEngine and skip all authentication completely. Read morehere.
Provider‑agnostic OAuth2 authentication​
Use this method when the SMTP server accepts a plain username + access token pair. No client secrets or refresh tokens are involved.
auth– authentication objecttype–'OAuth2'user– e‑mail address (required)accessToken– access token (required)expires– UNIX timestamp whenaccessTokenexpires (optional)
auth– authentication object
type–'OAuth2'
'OAuth2'
user– e‑mail address (required)
accessToken– access token (required)
expires– UNIX timestamp whenaccessTokenexpires (optional)
Token scopes• Gmail – request the token with thehttps://mail.google.com/scope
• Outlook – request the token with thehttps://outlook.office.com/SMTP.Sendscope
https://mail.google.com/
https://outlook.office.com/SMTP.Send
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",},});
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",},});
Normal (non‑pooled) transports can overrideauthper‑message. Create the transport once and pass different tokens insendMailoptions as needed.
Gmail‑specific helpers​
The sections below cover Gmail‑only flows that Nodemailer can automate for you.
Your app requests consent from the user and receives arefreshToken. Nodemailer uses this token to generate freshaccessTokens when needed.
auth– authentication objecttype–'OAuth2'user– e‑mail address (required)clientId– OAuth2 client ID (required)clientSecret– OAuth2 client secret (required)refreshToken– refresh token (required)accessToken– access token (optional; Nodemailer auto‑refreshes if missing or expired)expires– UNIX expiration timestamp foraccessToken(optional)accessUrl– custom token endpoint (optional; defaults to Gmail)
auth– authentication object
type–'OAuth2'
'OAuth2'
user– e‑mail address (required)
clientId– OAuth2 client ID (required)
clientSecret– OAuth2 client secret (required)
refreshToken– refresh token (required)
accessToken– access token (optional; Nodemailer auto‑refreshes if missing or expired)
expires– UNIX expiration timestamp foraccessToken(optional)
accessUrl– custom token endpoint (optional; defaults to Gmail)
Use a Google service account to impersonate a user. No interactive consent is required.
auth– authentication objecttype–'OAuth2'user– e‑mail address to send as (required)serviceClient– service accountclient_id(required)privateKey– service account private key (required)
auth– authentication object
type–'OAuth2'
'OAuth2'
user– e‑mail address to send as (required)
serviceClient– service accountclient_id(required)
privateKey– service account private key (required)
Register anoauth2_provision_cbcallback that returns a token whenever Nodemailer needs one.
oauth2_provision_cb
transporter.set("oauth2_provision_cb",(user,renew,cb)=>{consttoken=userTokens[user];if(!token)returncb(newError("Unknown user"));cb(null,token);});
transporter.set("oauth2_provision_cb",(user,renew,cb)=>{consttoken=userTokens[user];if(!token)returncb(newError("Unknown user"));cb(null,token);});
Listen for thetokenevent to persist newly generated tokens.
token
transporter.on("token",(t)=>{console.log("User:",t.user);console.log("New access token:",t.accessToken);console.log("Expires at:",newDate(t.expires));});
transporter.on("token",(t)=>{console.log("User:",t.user);console.log("New access token:",t.accessToken);console.log("Expires at:",newDate(t.expires));});
Authenticate with an existing token
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",},});
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",},});
Custom handler– token returned by your own service
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com"},});transporter.set("oauth2_provision_cb",(user,renew,cb)=>{cb(null,userTokens[user]);});
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com"},});transporter.set("oauth2_provision_cb",(user,renew,cb)=>{cb(null,userTokens[user]);});
Full 3‑legged setup– Nodemailer refreshes tokens automatically
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",clientId:"000000000000-xxx.apps.googleusercontent.com",clientSecret:"XxxxxXXxX0xxxxxxxx0XXxX0",refreshToken:"1/XXxXxsss-xxxXXXXXxXxx0XXXxxXXx0x00xxx",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",expires:1484314697598,},});
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",clientId:"000000000000-xxx.apps.googleusercontent.com",clientSecret:"XxxxxXXxX0xxxxxxxx0XXxX0",refreshToken:"1/XXxXxsss-xxxXXXXXxXxx0XXXxxXXx0x00xxx",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",expires:1484314697598,},});
Service account– token re‑generated via 2LO
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",serviceClient:"113600000000000000000",privateKey:"-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBg...",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",expires:1484314697598,},});
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",serviceClient:"113600000000000000000",privateKey:"-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBg...",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",expires:1484314697598,},});
Per‑message auth– single transport, many users
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",clientId:"000000000000-xxx.apps.googleusercontent.com",clientSecret:"XxxxxXXxX0xxxxxxxx0XXxX0",},});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Message",text:"I hope this message gets through!",auth:{user:"user@example.com",refreshToken:"1/XXxXxsss-xxxXXXXXxXxx0XXXxxXXx0x00xxx",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",expires:1484314697598,},});
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",clientId:"000000000000-xxx.apps.googleusercontent.com",clientSecret:"XxxxxXXxX0xxxxxxxx0XXxX0",},});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Message",text:"I hope this message gets through!",auth:{user:"user@example.com",refreshToken:"1/XXxXxsss-xxxXXXXXxXxx0XXXxxXXx0x00xxx",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",expires:1484314697598,},});
Per‑message auth does not work with pooled transports.
Gmail SMTP requires thehttps://mail.google.com/scope – ensure your token has it.
https://mail.google.com/
Gmail API access must be enabled for your Client ID in Google API Manager.
Provider‑agnostic OAuth2 authentication
Gmail‑specific helpers



===== https://nodemailer.com/smtp/oauth2#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
OAuth2
OAuth2
OAuth2 lets your application use short‑lived access tokens instead of passwords. Tokens are scoped, revocable, and regenerable, so a leaked token causes far less harm than a leaked password.
Provider‑agnostic OAuth2 authentication
Gmail‑specific helpers
Managing OAuth2 app credentials is painful. LetEmailEnginehandle them for you. Once an account is registered with EmailEngine, you can point Nodemailer to EmailEngine and skip all authentication completely. Read morehere.
Provider‑agnostic OAuth2 authentication​
Use this method when the SMTP server accepts a plain username + access token pair. No client secrets or refresh tokens are involved.
auth– authentication objecttype–'OAuth2'user– e‑mail address (required)accessToken– access token (required)expires– UNIX timestamp whenaccessTokenexpires (optional)
auth– authentication object
type–'OAuth2'
'OAuth2'
user– e‑mail address (required)
accessToken– access token (required)
expires– UNIX timestamp whenaccessTokenexpires (optional)
Token scopes• Gmail – request the token with thehttps://mail.google.com/scope
• Outlook – request the token with thehttps://outlook.office.com/SMTP.Sendscope
https://mail.google.com/
https://outlook.office.com/SMTP.Send
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",},});
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",},});
Normal (non‑pooled) transports can overrideauthper‑message. Create the transport once and pass different tokens insendMailoptions as needed.
Gmail‑specific helpers​
The sections below cover Gmail‑only flows that Nodemailer can automate for you.
Your app requests consent from the user and receives arefreshToken. Nodemailer uses this token to generate freshaccessTokens when needed.
auth– authentication objecttype–'OAuth2'user– e‑mail address (required)clientId– OAuth2 client ID (required)clientSecret– OAuth2 client secret (required)refreshToken– refresh token (required)accessToken– access token (optional; Nodemailer auto‑refreshes if missing or expired)expires– UNIX expiration timestamp foraccessToken(optional)accessUrl– custom token endpoint (optional; defaults to Gmail)
auth– authentication object
type–'OAuth2'
'OAuth2'
user– e‑mail address (required)
clientId– OAuth2 client ID (required)
clientSecret– OAuth2 client secret (required)
refreshToken– refresh token (required)
accessToken– access token (optional; Nodemailer auto‑refreshes if missing or expired)
expires– UNIX expiration timestamp foraccessToken(optional)
accessUrl– custom token endpoint (optional; defaults to Gmail)
Use a Google service account to impersonate a user. No interactive consent is required.
auth– authentication objecttype–'OAuth2'user– e‑mail address to send as (required)serviceClient– service accountclient_id(required)privateKey– service account private key (required)
auth– authentication object
type–'OAuth2'
'OAuth2'
user– e‑mail address to send as (required)
serviceClient– service accountclient_id(required)
privateKey– service account private key (required)
Register anoauth2_provision_cbcallback that returns a token whenever Nodemailer needs one.
oauth2_provision_cb
transporter.set("oauth2_provision_cb",(user,renew,cb)=>{consttoken=userTokens[user];if(!token)returncb(newError("Unknown user"));cb(null,token);});
transporter.set("oauth2_provision_cb",(user,renew,cb)=>{consttoken=userTokens[user];if(!token)returncb(newError("Unknown user"));cb(null,token);});
Listen for thetokenevent to persist newly generated tokens.
token
transporter.on("token",(t)=>{console.log("User:",t.user);console.log("New access token:",t.accessToken);console.log("Expires at:",newDate(t.expires));});
transporter.on("token",(t)=>{console.log("User:",t.user);console.log("New access token:",t.accessToken);console.log("Expires at:",newDate(t.expires));});
Authenticate with an existing token
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",},});
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",},});
Custom handler– token returned by your own service
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com"},});transporter.set("oauth2_provision_cb",(user,renew,cb)=>{cb(null,userTokens[user]);});
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com"},});transporter.set("oauth2_provision_cb",(user,renew,cb)=>{cb(null,userTokens[user]);});
Full 3‑legged setup– Nodemailer refreshes tokens automatically
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",clientId:"000000000000-xxx.apps.googleusercontent.com",clientSecret:"XxxxxXXxX0xxxxxxxx0XXxX0",refreshToken:"1/XXxXxsss-xxxXXXXXxXxx0XXXxxXXx0x00xxx",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",expires:1484314697598,},});
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",clientId:"000000000000-xxx.apps.googleusercontent.com",clientSecret:"XxxxxXXxX0xxxxxxxx0XXxX0",refreshToken:"1/XXxXxsss-xxxXXXXXxXxx0XXXxxXXx0x00xxx",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",expires:1484314697598,},});
Service account– token re‑generated via 2LO
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",serviceClient:"113600000000000000000",privateKey:"-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBg...",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",expires:1484314697598,},});
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",user:"user@example.com",serviceClient:"113600000000000000000",privateKey:"-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBg...",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",expires:1484314697598,},});
Per‑message auth– single transport, many users
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",clientId:"000000000000-xxx.apps.googleusercontent.com",clientSecret:"XxxxxXXxX0xxxxxxxx0XXxX0",},});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Message",text:"I hope this message gets through!",auth:{user:"user@example.com",refreshToken:"1/XXxXxsss-xxxXXXXXxXxx0XXXxxXXx0x00xxx",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",expires:1484314697598,},});
lettransporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{type:"OAuth2",clientId:"000000000000-xxx.apps.googleusercontent.com",clientSecret:"XxxxxXXxX0xxxxxxxx0XXxX0",},});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Message",text:"I hope this message gets through!",auth:{user:"user@example.com",refreshToken:"1/XXxXxsss-xxxXXXXXxXxx0XXXxxXXx0x00xxx",accessToken:"ya29.Xx_XX0xxxxx-xX0X0XxXXxXxXXXxX0x",expires:1484314697598,},});
Per‑message auth does not work with pooled transports.
Gmail SMTP requires thehttps://mail.google.com/scope – ensure your token has it.
https://mail.google.com/
Gmail API access must be enabled for your Client ID in Google API Manager.
Provider‑agnostic OAuth2 authentication
Gmail‑specific helpers



===== https://nodemailer.com/smtp/well-known-services =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
Well-Known Services
Well-Known Services
Nodemailer ships with connection presets for many popular SMTP providers.
Instead of looking up each provider’s SMTP host name, port and security settings
you can pass a singleservicestring when you create a transport.
Nodemailer will fill in the rest for you.
service
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({service:"Gmail",// any id from the table below, case insensitiveauth:{user:process.env.SMTP_USER,pass:process.env.SMTP_PASS,},});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({service:"Gmail",// any id from the table below, case insensitiveauth:{user:process.env.SMTP_USER,pass:process.env.SMTP_PASS,},});
Internallyserviceis just a shortcut – you can always supplyhost,port,secureand other options yourself. If something changes or your provider is
missing you can open a pull‑request against theservices.jsonfile
or bypass this feature entirely and set the connection details manually.
service
host
port
secure
Most major providers require OAuth 2 or application‑specific
passwords. The presets only configure the server connection; you are still
responsible for using the correct authentication mechanism.
List of built‑in services​
List of built‑in services



===== https://nodemailer.com/smtp/well-known-services#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
Well-Known Services
Well-Known Services
Nodemailer ships with connection presets for many popular SMTP providers.
Instead of looking up each provider’s SMTP host name, port and security settings
you can pass a singleservicestring when you create a transport.
Nodemailer will fill in the rest for you.
service
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({service:"Gmail",// any id from the table below, case insensitiveauth:{user:process.env.SMTP_USER,pass:process.env.SMTP_PASS,},});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({service:"Gmail",// any id from the table below, case insensitiveauth:{user:process.env.SMTP_USER,pass:process.env.SMTP_PASS,},});
Internallyserviceis just a shortcut – you can always supplyhost,port,secureand other options yourself. If something changes or your provider is
missing you can open a pull‑request against theservices.jsonfile
or bypass this feature entirely and set the connection details manually.
service
host
port
secure
Most major providers require OAuth 2 or application‑specific
passwords. The presets only configure the server connection; you are still
responsible for using the correct authentication mechanism.
List of built‑in services​
List of built‑in services



===== https://nodemailer.com/smtp/customauth =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
Custom authentication
Custom authentication
Nodemailer’s SMTP transport can be extended withcustom authentication mechanismsthat are not supported out of the box.
When do I need a custom handler?​
If the server advertises an authentication keyword that Nodemailer does not recognise, you need to teach Nodemailer how to complete the exchange. For example, when the server replies with:
250‑AUTH LOGIN PLAIN MY‑CUSTOM‑METHOD
250‑AUTH LOGIN PLAIN MY‑CUSTOM‑METHOD
Nodemailer already understandsLOGINandPLAIN, but has no idea whatMY‑CUSTOM‑METHODis. By providing a handler named exactly after that keyword you enable Nodemailer to use it.
If several mechanisms are available you canforceNodemailer to use yours by settingauth.methodto the same identifier.
auth.method
Defining a handler​
Add acustomAuthmap to the transporter options. Each key is the mechanism name and each value is a function that performs the exchange.
customAuth
constnodemailer=require("nodemailer");asyncfunctionmyCustomMethod(ctx){// Build and send a single AUTH command (dummy example – adapt to your spec)constresponse=awaitctx.sendCommand("AUTH MY-CUSTOM-METHOD "+Buffer.from(ctx.auth.credentials.pass).toString("base64"));// Check server replyif(response.status<200||response.status>=300){thrownewError("Authentication failed: "+response.text);}}consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,auth:{type:"custom",// tells Nodemailer we are using a custom handlermethod:"MY-CUSTOM-METHOD",// forces this exact mechanismuser:"username",pass:"verysecret",},customAuth:{"MY-CUSTOM-METHOD":myCustomMethod,},});
constnodemailer=require("nodemailer");asyncfunctionmyCustomMethod(ctx){// Build and send a single AUTH command (dummy example – adapt to your spec)constresponse=awaitctx.sendCommand("AUTH MY-CUSTOM-METHOD "+Buffer.from(ctx.auth.credentials.pass).toString("base64"));// Check server replyif(response.status<200||response.status>=300){thrownewError("Authentication failed: "+response.text);}}consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,auth:{type:"custom",// tells Nodemailer we are using a custom handlermethod:"MY-CUSTOM-METHOD",// forces this exact mechanismuser:"username",pass:"verysecret",},customAuth:{"MY-CUSTOM-METHOD":myCustomMethod,},});
Handler signature​
(ctx:HandlerContext)=>Promise<void>|void
(ctx:HandlerContext)=>Promise<void>|void
You get acontext object(ctx) and you either:
ctx
return a Promise that resolves on success or rejects on error,or
callctx.resolve()/ctx.reject(err)manually.
ctx.resolve()
ctx.reject(err)
ctx.auth​
ctx.auth
ctx.auth– the fullauthobject you passed tocreateTransport()
ctx.auth
auth
createTransport()
ctx.auth.credentials– convenient alias for{ user, pass, options }
ctx.auth.credentials
{ user, pass, options }
ctx.sendCommand(command)​
ctx.sendCommand(command)
Sends a raw SMTP command and returns a Promise with the parsed reply:
status
235
code
2.7.0
text
response
235 2.7.0 Authentication successful
A callback style is also supported:ctx.sendCommand(cmd, (err, info) => { … }).
ctx.sendCommand(cmd, (err, info) => { … })
Passing additional parameters​
Need more thanuserandpass? Add anoptionsobject – it will be available viactx.auth.credentials.options.
options
ctx.auth.credentials.options
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,auth:{type:"custom",method:"MY-CUSTOM-METHOD",user:"username",pass:"verysecret",options:{clientId:"verysecret",applicationId:"my-app",},},customAuth:{"MY-CUSTOM-METHOD":async(ctx)=>{consttoken=awaitgenerateSecretTokenSomehow(ctx.auth.credentials.options.clientId,ctx.auth.credentials.options.applicationId);awaitctx.sendCommand("AUTH MY-CUSTOM-METHOD "+token);},},});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,auth:{type:"custom",method:"MY-CUSTOM-METHOD",user:"username",pass:"verysecret",options:{clientId:"verysecret",applicationId:"my-app",},},customAuth:{"MY-CUSTOM-METHOD":async(ctx)=>{consttoken=awaitgenerateSecretTokenSomehow(ctx.auth.credentials.options.clientId,ctx.auth.credentials.options.applicationId);awaitctx.sendCommand("AUTH MY-CUSTOM-METHOD "+token);},},});
Community‑provided handlers​
nodemailer‑ntlm‑auth
nodemailer‑cram‑md5
When do I need a custom handler?
Defining a handlerHandler signaturectx.authctx.sendCommand(command)
Handler signature
ctx.auth
ctx.auth
ctx.sendCommand(command)
ctx.sendCommand(command)
Passing additional parameters
Community‑provided handlers



===== https://nodemailer.com/smtp/customauth#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
Custom authentication
Custom authentication
Nodemailer’s SMTP transport can be extended withcustom authentication mechanismsthat are not supported out of the box.
When do I need a custom handler?​
If the server advertises an authentication keyword that Nodemailer does not recognise, you need to teach Nodemailer how to complete the exchange. For example, when the server replies with:
250‑AUTH LOGIN PLAIN MY‑CUSTOM‑METHOD
250‑AUTH LOGIN PLAIN MY‑CUSTOM‑METHOD
Nodemailer already understandsLOGINandPLAIN, but has no idea whatMY‑CUSTOM‑METHODis. By providing a handler named exactly after that keyword you enable Nodemailer to use it.
If several mechanisms are available you canforceNodemailer to use yours by settingauth.methodto the same identifier.
auth.method
Defining a handler​
Add acustomAuthmap to the transporter options. Each key is the mechanism name and each value is a function that performs the exchange.
customAuth
constnodemailer=require("nodemailer");asyncfunctionmyCustomMethod(ctx){// Build and send a single AUTH command (dummy example – adapt to your spec)constresponse=awaitctx.sendCommand("AUTH MY-CUSTOM-METHOD "+Buffer.from(ctx.auth.credentials.pass).toString("base64"));// Check server replyif(response.status<200||response.status>=300){thrownewError("Authentication failed: "+response.text);}}consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,auth:{type:"custom",// tells Nodemailer we are using a custom handlermethod:"MY-CUSTOM-METHOD",// forces this exact mechanismuser:"username",pass:"verysecret",},customAuth:{"MY-CUSTOM-METHOD":myCustomMethod,},});
constnodemailer=require("nodemailer");asyncfunctionmyCustomMethod(ctx){// Build and send a single AUTH command (dummy example – adapt to your spec)constresponse=awaitctx.sendCommand("AUTH MY-CUSTOM-METHOD "+Buffer.from(ctx.auth.credentials.pass).toString("base64"));// Check server replyif(response.status<200||response.status>=300){thrownewError("Authentication failed: "+response.text);}}consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,auth:{type:"custom",// tells Nodemailer we are using a custom handlermethod:"MY-CUSTOM-METHOD",// forces this exact mechanismuser:"username",pass:"verysecret",},customAuth:{"MY-CUSTOM-METHOD":myCustomMethod,},});
Handler signature​
(ctx:HandlerContext)=>Promise<void>|void
(ctx:HandlerContext)=>Promise<void>|void
You get acontext object(ctx) and you either:
ctx
return a Promise that resolves on success or rejects on error,or
callctx.resolve()/ctx.reject(err)manually.
ctx.resolve()
ctx.reject(err)
ctx.auth​
ctx.auth
ctx.auth– the fullauthobject you passed tocreateTransport()
ctx.auth
auth
createTransport()
ctx.auth.credentials– convenient alias for{ user, pass, options }
ctx.auth.credentials
{ user, pass, options }
ctx.sendCommand(command)​
ctx.sendCommand(command)
Sends a raw SMTP command and returns a Promise with the parsed reply:
status
235
code
2.7.0
text
response
235 2.7.0 Authentication successful
A callback style is also supported:ctx.sendCommand(cmd, (err, info) => { … }).
ctx.sendCommand(cmd, (err, info) => { … })
Passing additional parameters​
Need more thanuserandpass? Add anoptionsobject – it will be available viactx.auth.credentials.options.
options
ctx.auth.credentials.options
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,auth:{type:"custom",method:"MY-CUSTOM-METHOD",user:"username",pass:"verysecret",options:{clientId:"verysecret",applicationId:"my-app",},},customAuth:{"MY-CUSTOM-METHOD":async(ctx)=>{consttoken=awaitgenerateSecretTokenSomehow(ctx.auth.credentials.options.clientId,ctx.auth.credentials.options.applicationId);awaitctx.sendCommand("AUTH MY-CUSTOM-METHOD "+token);},},});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,auth:{type:"custom",method:"MY-CUSTOM-METHOD",user:"username",pass:"verysecret",options:{clientId:"verysecret",applicationId:"my-app",},},customAuth:{"MY-CUSTOM-METHOD":async(ctx)=>{consttoken=awaitgenerateSecretTokenSomehow(ctx.auth.credentials.options.clientId,ctx.auth.credentials.options.applicationId);awaitctx.sendCommand("AUTH MY-CUSTOM-METHOD "+token);},},});
Community‑provided handlers​
nodemailer‑ntlm‑auth
nodemailer‑cram‑md5
When do I need a custom handler?
Defining a handlerHandler signaturectx.authctx.sendCommand(command)
Handler signature
ctx.auth
ctx.auth
ctx.sendCommand(command)
ctx.sendCommand(command)
Passing additional parameters
Community‑provided handlers



===== https://nodemailer.com/smtp/proxies =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
Proxy support
Proxy support
Nodemailer can connect to an SMTP serverthrough an outbound proxy. Out of the box it understandsHTTP CONNECTproxies. ForSOCKS4/4a/5and any other schemes you can either:
Install the community‑maintainedsockspackage and let Nodemailer do the rest.
socks
Provide your own proxy handler function.
Quick start​
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:"http://proxy.example.test:3128",// ← HTTP proxy URL});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:"http://proxy.example.test:3128",// ← HTTP proxy URL});
Set theproxyoption to a valid URL string. Nodemailer parses the URL and decides how to tunnel the connection.
proxy
HTTP CONNECT proxies​
HTTP proxies are fully supportedwithout additional dependencies. Just pass their URL in theproxyoption:
proxy
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:process.env.HTTP_PROXY,// or HTTPS_PROXY});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:process.env.HTTP_PROXY,// or HTTPS_PROXY});
SOCKS proxies​
Support for SOCKS4, SOCKS4a and SOCKS5 isnot bundledto keep Nodemailer lean. Install thesockspackage in your project and register it with the transporter:
socks
npm install socks --save
npm install socks --save
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:"socks5://127.0.0.1:1080",});transporter.set("proxy_socks_module",require("socks"));
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:"socks5://127.0.0.1:1080",});transporter.set("proxy_socks_module",require("socks"));
Supported URL protocols​
socks4:
socks4a:
socks5:
socks:
Local testing with SSH​
Create an ad‑hoc SOCKS5 proxy that forwards all traffic through an SSH server:
ssh -N -D 0.0.0.0:1080 user@remote.host
ssh -N -D 0.0.0.0:1080 user@remote.host
Then setproxy: "socks5://localhost:1080".
proxy: "socks5://localhost:1080"
Custom proxy handlers​
Need a special authentication flow or a corporate proxy that speaks a proprietary protocol? Provide your own socket‑creation logic:
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:"myproxy://127.0.0.1:9999",});// Register a handler for the "myproxy:" URL schemetransporter.set("proxy_handler_myproxy",(proxy,options,done)=>{constnet=require("net");console.log(`Proxy host=%s port=%s`,proxy.hostname,proxy.port);constsocket=net.connect(proxy.port,proxy.hostname,()=>{// ...hand‑shake with your proxy here...// Return the socket to Nodemailerdone(null,{connection:socket});});});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:"myproxy://127.0.0.1:9999",});// Register a handler for the "myproxy:" URL schemetransporter.set("proxy_handler_myproxy",(proxy,options,done)=>{constnet=require("net");console.log(`Proxy host=%s port=%s`,proxy.hostname,proxy.port);constsocket=net.connect(proxy.port,proxy.hostname,()=>{// ...hand‑shake with your proxy here...// Return the socket to Nodemailerdone(null,{connection:socket});});});
If the proxy socket isalready encrypted(e.g. you connected withtls.connect()), setsecured: trueso Nodemailer skips its own STARTTLS upgrade:
tls.connect()
secured: true
consttls=require("tls");transporter.set("proxy_handler_myproxys",(proxy,options,done)=>{constsocket=tls.connect(proxy.port,proxy.hostname,()=>{done(null,{connection:socket,secured:true});});});
consttls=require("tls");transporter.set("proxy_handler_myproxys",(proxy,options,done)=>{constsocket=tls.connect(proxy.port,proxy.hostname,()=>{done(null,{connection:socket,secured:true});});});
Quick start
HTTP CONNECT proxies
SOCKS proxiesSupported URL protocolsLocal testing with SSH
Supported URL protocols
Local testing with SSH
Custom proxy handlers



===== https://nodemailer.com/smtp/proxies#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
Proxy support
Proxy support
Nodemailer can connect to an SMTP serverthrough an outbound proxy. Out of the box it understandsHTTP CONNECTproxies. ForSOCKS4/4a/5and any other schemes you can either:
Install the community‑maintainedsockspackage and let Nodemailer do the rest.
socks
Provide your own proxy handler function.
Quick start​
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:"http://proxy.example.test:3128",// ← HTTP proxy URL});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:"http://proxy.example.test:3128",// ← HTTP proxy URL});
Set theproxyoption to a valid URL string. Nodemailer parses the URL and decides how to tunnel the connection.
proxy
HTTP CONNECT proxies​
HTTP proxies are fully supportedwithout additional dependencies. Just pass their URL in theproxyoption:
proxy
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:process.env.HTTP_PROXY,// or HTTPS_PROXY});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:process.env.HTTP_PROXY,// or HTTPS_PROXY});
SOCKS proxies​
Support for SOCKS4, SOCKS4a and SOCKS5 isnot bundledto keep Nodemailer lean. Install thesockspackage in your project and register it with the transporter:
socks
npm install socks --save
npm install socks --save
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:"socks5://127.0.0.1:1080",});transporter.set("proxy_socks_module",require("socks"));
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:"socks5://127.0.0.1:1080",});transporter.set("proxy_socks_module",require("socks"));
Supported URL protocols​
socks4:
socks4a:
socks5:
socks:
Local testing with SSH​
Create an ad‑hoc SOCKS5 proxy that forwards all traffic through an SSH server:
ssh -N -D 0.0.0.0:1080 user@remote.host
ssh -N -D 0.0.0.0:1080 user@remote.host
Then setproxy: "socks5://localhost:1080".
proxy: "socks5://localhost:1080"
Custom proxy handlers​
Need a special authentication flow or a corporate proxy that speaks a proprietary protocol? Provide your own socket‑creation logic:
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:"myproxy://127.0.0.1:9999",});// Register a handler for the "myproxy:" URL schemetransporter.set("proxy_handler_myproxy",(proxy,options,done)=>{constnet=require("net");console.log(`Proxy host=%s port=%s`,proxy.hostname,proxy.port);constsocket=net.connect(proxy.port,proxy.hostname,()=>{// ...hand‑shake with your proxy here...// Return the socket to Nodemailerdone(null,{connection:socket});});});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,proxy:"myproxy://127.0.0.1:9999",});// Register a handler for the "myproxy:" URL schemetransporter.set("proxy_handler_myproxy",(proxy,options,done)=>{constnet=require("net");console.log(`Proxy host=%s port=%s`,proxy.hostname,proxy.port);constsocket=net.connect(proxy.port,proxy.hostname,()=>{// ...hand‑shake with your proxy here...// Return the socket to Nodemailerdone(null,{connection:socket});});});
If the proxy socket isalready encrypted(e.g. you connected withtls.connect()), setsecured: trueso Nodemailer skips its own STARTTLS upgrade:
tls.connect()
secured: true
consttls=require("tls");transporter.set("proxy_handler_myproxys",(proxy,options,done)=>{constsocket=tls.connect(proxy.port,proxy.hostname,()=>{done(null,{connection:socket,secured:true});});});
consttls=require("tls");transporter.set("proxy_handler_myproxys",(proxy,options,done)=>{constsocket=tls.connect(proxy.port,proxy.hostname,()=>{done(null,{connection:socket,secured:true});});});
Quick start
HTTP CONNECT proxies
SOCKS proxiesSupported URL protocolsLocal testing with SSH
Supported URL protocols
Local testing with SSH
Custom proxy handlers



===== https://nodemailer.com/smtp/dsn =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
Delivery Status Notifications (DSN)
Delivery Status Notifications (DSN)
The SMTPDelivery Status Notification(DSN) extension (defined inRFC 3461) isoptional. Your outbound SMTP servicemusthave the extension enabled for DSN requests to take effect.
If your SMTP service supports DSN, you can ask Nodemailer to request a bounce‑report (failure), delay notice, or success confirmation for any individual message. You do so by adding adsnobject to the message options passed totransporter.sendMail().
dsn
transporter.sendMail()
dsnobject fields​
dsn
id
string
return
'headers' | 'full'
notify
string | string[]
'never'
'success'
'failure'
'delay'
'never'
recipient
string
Non‑xtextstrings are escaped automatically by Nodemailer.
Examples​
1. Success notifications only​
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,secure:false,auth:{user:"smtp-user",pass:"smtp-pass",},});awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Message",text:"I hope this message gets read!",dsn:{id:"msg-123",return:"headers",notify:"success",recipient:"sender@example.com",},});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,secure:false,auth:{user:"smtp-user",pass:"smtp-pass",},});awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Message",text:"I hope this message gets read!",dsn:{id:"msg-123",return:"headers",notify:"success",recipient:"sender@example.com",},});
2. Failureanddelay notifications​
awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Message",text:"I hope this message gets read!",dsn:{id:"msg-124",return:"headers",notify:["failure","delay"],recipient:"sender@example.com",},});
awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Message",text:"I hope this message gets read!",dsn:{id:"msg-124",return:"headers",notify:["failure","delay"],recipient:"sender@example.com",},});
3. Opting out of DSN entirely​
If you explicitly donotwant DSN reports, passnotify: 'never'.
notify: 'never'
awaittransporter.sendMail({/* ... */dsn:{notify:"never",},});
awaittransporter.sendMail({/* ... */dsn:{notify:"never",},});
Troubleshooting​
No DSN received?Double‑check that your SMTP provider advertises theDSNcapability in itsEHLOresponse and that you are not forcing a downgrade to the legacyHELOcommand.
DSN
EHLO
HELO
Provider‑specific quirks.Some ESPs accept only a subset of DSN options or rewrite the recipient address. Consult your provider’s documentation if delivery reports seem incomplete.
dsnobject fields
dsn
Examples1. Success notifications only2. Failureanddelay notifications3. Opting out of DSN entirely
1. Success notifications only
2. Failureanddelay notifications
3. Opting out of DSN entirely
Troubleshooting



===== https://nodemailer.com/smtp/dsn#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transportSMTP envelopePooled SMTP ConnectionsTesting SMTPOAuth2Well-Known ServicesCustom authenticationProxy supportDelivery Status Notifications (DSN)
SMTP envelope
Pooled SMTP Connections
Testing SMTP
OAuth2
Well-Known Services
Custom authentication
Proxy support
Delivery Status Notifications (DSN)
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
SMTP transport
Delivery Status Notifications (DSN)
Delivery Status Notifications (DSN)
The SMTPDelivery Status Notification(DSN) extension (defined inRFC 3461) isoptional. Your outbound SMTP servicemusthave the extension enabled for DSN requests to take effect.
If your SMTP service supports DSN, you can ask Nodemailer to request a bounce‑report (failure), delay notice, or success confirmation for any individual message. You do so by adding adsnobject to the message options passed totransporter.sendMail().
dsn
transporter.sendMail()
dsnobject fields​
dsn
id
string
return
'headers' | 'full'
notify
string | string[]
'never'
'success'
'failure'
'delay'
'never'
recipient
string
Non‑xtextstrings are escaped automatically by Nodemailer.
Examples​
1. Success notifications only​
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,secure:false,auth:{user:"smtp-user",pass:"smtp-pass",},});awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Message",text:"I hope this message gets read!",dsn:{id:"msg-123",return:"headers",notify:"success",recipient:"sender@example.com",},});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:587,secure:false,auth:{user:"smtp-user",pass:"smtp-pass",},});awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Message",text:"I hope this message gets read!",dsn:{id:"msg-123",return:"headers",notify:"success",recipient:"sender@example.com",},});
2. Failureanddelay notifications​
awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Message",text:"I hope this message gets read!",dsn:{id:"msg-124",return:"headers",notify:["failure","delay"],recipient:"sender@example.com",},});
awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Message",text:"I hope this message gets read!",dsn:{id:"msg-124",return:"headers",notify:["failure","delay"],recipient:"sender@example.com",},});
3. Opting out of DSN entirely​
If you explicitly donotwant DSN reports, passnotify: 'never'.
notify: 'never'
awaittransporter.sendMail({/* ... */dsn:{notify:"never",},});
awaittransporter.sendMail({/* ... */dsn:{notify:"never",},});
Troubleshooting​
No DSN received?Double‑check that your SMTP provider advertises theDSNcapability in itsEHLOresponse and that you are not forcing a downgrade to the legacyHELOcommand.
DSN
EHLO
HELO
Provider‑specific quirks.Some ESPs accept only a subset of DSN options or rewrite the recipient address. Consult your provider’s documentation if delivery reports seem incomplete.
dsnobject fields
dsn
Examples1. Success notifications only2. Failureanddelay notifications3. Opting out of DSN entirely
1. Success notifications only
2. Failureanddelay notifications
3. Opting out of DSN entirely
Troubleshooting



===== https://nodemailer.com/transports =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transportsSendmail transportSES transportStream transport
Sendmail transport
SES transport
Stream transport
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Other transports
Other transports
Nodemailer ships with a fully‑featuredSMTP transportenabled by default, but you’re byno meanslimited to SMTP. Atransportis simply the mechanism Nodemailer uses to hand off a fully‑constructed email message—whether that’s piping intosendmail, posting to an HTTPS API, or any other delivery strategy.
sendmail
This page lists the transports that are bundled with Nodemailer as well as popular community transports. You can also roll your own by following thetransport API documentation.
Example: Amazon SES transport​
Below is a minimal example that delivers mail throughAmazon SESusing the built‑in SES transport. It wraps the officialAWS SDK v3client under the hood.
npm install nodemailer @aws-sdk/client-sesv2
npm install nodemailer @aws-sdk/client-sesv2
constnodemailer=require("nodemailer");const{SESv2Client,SendEmailCommand}=require("@aws-sdk/client-sesv2");constsesClient=newSESv2Client({});consttransporter=nodemailer.createTransport({SES:{sesClient,SendEmailCommand},});(async()=>{awaittransporter.sendMail({from:"you@example.com",to:"friend@example.net",subject:"Hello from SES",text:"This message was sent with Nodemailer & Amazon SES!",});})();
constnodemailer=require("nodemailer");const{SESv2Client,SendEmailCommand}=require("@aws-sdk/client-sesv2");constsesClient=newSESv2Client({});consttransporter=nodemailer.createTransport({SES:{sesClient,SendEmailCommand},});(async()=>{awaittransporter.sendMail({from:"you@example.com",to:"friend@example.net",subject:"Hello from SES",text:"This message was sent with Nodemailer & Amazon SES!",});})();
Available transports​
Bundled (built‑in) transports​
sendmail
Community transports​
These transports live in separate NPM packages maintained by the community. Install them withnpm installand pass their exported function tonodemailer.createTransport().
npm install
nodemailer.createTransport()
Mailtrap– Deliver messages to your Mailtrap inbox for safe testing (npm)
Mailgun– Send via Mailgun’s HTTP API (npm)
Custom– Implement business‑specific logic by authoringyour own transport
Heads‑upThird‑party transports are not maintained by the Nodemailer team. Check each project’s README for installation and usage instructions.
Transport‑agnostic options​
While each transport defines its own configuration object, the following options are recognised byalltransports:
attachDataUrls
Boolean
data:
disableFileAccess
Boolean
disableUrlAccess
Boolean
normalizeHeaderKey(key)
Function
Example: Amazon SES transport
Available transportsBundled (built‑in) transportsCommunity transports
Bundled (built‑in) transports
Community transports
Transport‑agnostic options



===== https://nodemailer.com/transports#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transportsSendmail transportSES transportStream transport
Sendmail transport
SES transport
Stream transport
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Other transports
Other transports
Nodemailer ships with a fully‑featuredSMTP transportenabled by default, but you’re byno meanslimited to SMTP. Atransportis simply the mechanism Nodemailer uses to hand off a fully‑constructed email message—whether that’s piping intosendmail, posting to an HTTPS API, or any other delivery strategy.
sendmail
This page lists the transports that are bundled with Nodemailer as well as popular community transports. You can also roll your own by following thetransport API documentation.
Example: Amazon SES transport​
Below is a minimal example that delivers mail throughAmazon SESusing the built‑in SES transport. It wraps the officialAWS SDK v3client under the hood.
npm install nodemailer @aws-sdk/client-sesv2
npm install nodemailer @aws-sdk/client-sesv2
constnodemailer=require("nodemailer");const{SESv2Client,SendEmailCommand}=require("@aws-sdk/client-sesv2");constsesClient=newSESv2Client({});consttransporter=nodemailer.createTransport({SES:{sesClient,SendEmailCommand},});(async()=>{awaittransporter.sendMail({from:"you@example.com",to:"friend@example.net",subject:"Hello from SES",text:"This message was sent with Nodemailer & Amazon SES!",});})();
constnodemailer=require("nodemailer");const{SESv2Client,SendEmailCommand}=require("@aws-sdk/client-sesv2");constsesClient=newSESv2Client({});consttransporter=nodemailer.createTransport({SES:{sesClient,SendEmailCommand},});(async()=>{awaittransporter.sendMail({from:"you@example.com",to:"friend@example.net",subject:"Hello from SES",text:"This message was sent with Nodemailer & Amazon SES!",});})();
Available transports​
Bundled (built‑in) transports​
sendmail
Community transports​
These transports live in separate NPM packages maintained by the community. Install them withnpm installand pass their exported function tonodemailer.createTransport().
npm install
nodemailer.createTransport()
Mailtrap– Deliver messages to your Mailtrap inbox for safe testing (npm)
Mailgun– Send via Mailgun’s HTTP API (npm)
Custom– Implement business‑specific logic by authoringyour own transport
Heads‑upThird‑party transports are not maintained by the Nodemailer team. Check each project’s README for installation and usage instructions.
Transport‑agnostic options​
While each transport defines its own configuration object, the following options are recognised byalltransports:
attachDataUrls
Boolean
data:
disableFileAccess
Boolean
disableUrlAccess
Boolean
normalizeHeaderKey(key)
Function
Example: Amazon SES transport
Available transportsBundled (built‑in) transportsCommunity transports
Bundled (built‑in) transports
Community transports
Transport‑agnostic options



===== https://nodemailer.com/transports/sendmail =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transportsSendmail transportSES transportStream transport
Sendmail transport
SES transport
Stream transport
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Other transports
Sendmail transport
Sendmail transport
TheSendmail transporthands the generated RFC 822 message off to the localsendmail(or compatible) binary by piping it tostdin. Functionally, this is the same mechanism used by PHP'smail()helper.
mail()
Usage​
// CommonJSconstnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({sendmail:true,// enable Sendmail transport});
// CommonJSconstnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({sendmail:true,// enable Sendmail transport});
Settingsendmail: trueactivates the transport. Nodemailer will try to locate the binary automatically (defaults tosendmailin yourPATH). If necessary, you can point Nodemailer to a different binary with thepathoption (see below).
sendmail: true
sendmail
PATH
path
Transport options​
path
String
'sendmail'
newline
'unix'
'windows'
'unix'
\n
\r\n
args
String[]
-i
When no customargsarray is passed Nodemailer will execute
args
sendmail -i -f <from> <to…>
sendmail -i -f <from> <to…>
Withargsprovided the command becomes
args
sendmail -i <args…> <to…>
sendmail -i <args…> <to…>
Response​
Theinfoobject thattransporter.sendMail()yields contains only two properties—sendmailwrites nothing to stdout/stderr:
info
transporter.sendMail()
sendmail
envelope–{ from: 'address', to: ['address', …] }
envelope
{ from: 'address', to: ['address', …] }
messageId– value of the generatedMessage‑IDheader
messageId
Troubleshooting​
If Nodemailer cannot find/usr/bin/sendmail(the default on most Unix systems) make sure the binary is installed and available on yourPATH. Consult your distribution's documentation or theComputer Hope sendmail referencefor installation instructions.
PATH
Examples​
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({sendmail:true,newline:"unix",path:"/usr/sbin/sendmail",});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Test message",text:"I hope this message gets delivered!",},(err,info)=>{if(err){console.error(err);return;}console.log(info.envelope);console.log(info.messageId);});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({sendmail:true,newline:"unix",path:"/usr/sbin/sendmail",});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Test message",text:"I hope this message gets delivered!",},(err,info)=>{if(err){console.error(err);return;}console.log(info.envelope);console.log(info.messageId);});
If you need to pass custom flags—for example, to override the envelope sender—include them via theargsoption:
args
consttransporter=nodemailer.createTransport({sendmail:true,args:["-f","bounce@example.com"],});
consttransporter=nodemailer.createTransport({sendmail:true,args:["-f","bounce@example.com"],});
UsageTransport optionsResponseTroubleshootingExamples
Transport options
Response
Troubleshooting
Examples



===== https://nodemailer.com/transports/sendmail#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transportsSendmail transportSES transportStream transport
Sendmail transport
SES transport
Stream transport
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Other transports
Sendmail transport
Sendmail transport
TheSendmail transporthands the generated RFC 822 message off to the localsendmail(or compatible) binary by piping it tostdin. Functionally, this is the same mechanism used by PHP'smail()helper.
mail()
Usage​
// CommonJSconstnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({sendmail:true,// enable Sendmail transport});
// CommonJSconstnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({sendmail:true,// enable Sendmail transport});
Settingsendmail: trueactivates the transport. Nodemailer will try to locate the binary automatically (defaults tosendmailin yourPATH). If necessary, you can point Nodemailer to a different binary with thepathoption (see below).
sendmail: true
sendmail
PATH
path
Transport options​
path
String
'sendmail'
newline
'unix'
'windows'
'unix'
\n
\r\n
args
String[]
-i
When no customargsarray is passed Nodemailer will execute
args
sendmail -i -f <from> <to…>
sendmail -i -f <from> <to…>
Withargsprovided the command becomes
args
sendmail -i <args…> <to…>
sendmail -i <args…> <to…>
Response​
Theinfoobject thattransporter.sendMail()yields contains only two properties—sendmailwrites nothing to stdout/stderr:
info
transporter.sendMail()
sendmail
envelope–{ from: 'address', to: ['address', …] }
envelope
{ from: 'address', to: ['address', …] }
messageId– value of the generatedMessage‑IDheader
messageId
Troubleshooting​
If Nodemailer cannot find/usr/bin/sendmail(the default on most Unix systems) make sure the binary is installed and available on yourPATH. Consult your distribution's documentation or theComputer Hope sendmail referencefor installation instructions.
PATH
Examples​
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({sendmail:true,newline:"unix",path:"/usr/sbin/sendmail",});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Test message",text:"I hope this message gets delivered!",},(err,info)=>{if(err){console.error(err);return;}console.log(info.envelope);console.log(info.messageId);});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({sendmail:true,newline:"unix",path:"/usr/sbin/sendmail",});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Test message",text:"I hope this message gets delivered!",},(err,info)=>{if(err){console.error(err);return;}console.log(info.envelope);console.log(info.messageId);});
If you need to pass custom flags—for example, to override the envelope sender—include them via theargsoption:
args
consttransporter=nodemailer.createTransport({sendmail:true,args:["-f","bounce@example.com"],});
consttransporter=nodemailer.createTransport({sendmail:true,args:["-f","bounce@example.com"],});
UsageTransport optionsResponseTroubleshootingExamples
Transport options
Response
Troubleshooting
Examples



===== https://nodemailer.com/transports/ses =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transportsSendmail transportSES transportStream transport
Sendmail transport
SES transport
Stream transport
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Other transports
SES transport
SES transport
NodemailerSES transportlets you deliver email throughAmazon Simple Email Service (SES)using the official AWS JavaScript SESv2 Client package@aws-sdk/client‑sesv2.
It is a thin wrapper aroundSendEmailCommandthat preserves the familiartransporter.sendMail()API.
SendEmailCommand
transporter.sendMail()
The SES SDK is not bundled with Nodemailer. Install it explicitly:
npm install @aws-sdk/client-sesv2
npm install @aws-sdk/client-sesv2
Quick start​
constnodemailer=require("nodemailer");const{SESv2Client,SendEmailCommand}=require("@aws-sdk/client-sesv2");// 1. Configure the AWS SDK client (uses default credential chain if omitted)constsesClient=newSESv2Client({region:"us‑east‑1"});// 2. Create a Nodemailer transport that points at SESconsttransporter=nodemailer.createTransport({SES:{sesClient,SendEmailCommand},});// 3. Send the messageconstinfo=awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Hello from Nodemailer + SES",text:"I hope this message gets sent!",// Any SendEmailCommand input can be set under the `ses` key:ses:{ConfigurationSetName:"my‑config‑set",EmailTags:[{Name:"tag_name",Value:"tag_value"}],},});console.log(info.envelope);// { from: ..., to: [...] }console.log(info.messageId);// SES MessageId
constnodemailer=require("nodemailer");const{SESv2Client,SendEmailCommand}=require("@aws-sdk/client-sesv2");// 1. Configure the AWS SDK client (uses default credential chain if omitted)constsesClient=newSESv2Client({region:"us‑east‑1"});// 2. Create a Nodemailer transport that points at SESconsttransporter=nodemailer.createTransport({SES:{sesClient,SendEmailCommand},});// 3. Send the messageconstinfo=awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Hello from Nodemailer + SES",text:"I hope this message gets sent!",// Any SendEmailCommand input can be set under the `ses` key:ses:{ConfigurationSetName:"my‑config‑set",EmailTags:[{Name:"tag_name",Value:"tag_value"}],},});console.log(info.envelope);// { from: ..., to: [...] }console.log(info.messageId);// SES MessageId
You can also use the traditional callback style—transporter.sendMail(mail, cb)—if you prefer.
transporter.sendMail(mail, cb)
Transport options​
Pass anSESobject tocreateTransport()with the followingrequiredkeys:
SES
createTransport()
sesClient
SESv2Client
SendEmailCommand
SendEmailCommand
Message‑level options​
sendMail()accepts an optionalsesproperty.
All keys of this object are merged into the input object passed toSendEmailCommand, so you can set any parameter supported by the operation (for exampleEmailTags,ConfigurationSetName, …).
sendMail()
EmailTags
ConfigurationSetName
Response object​
The promise (or callback) resolves to:
envelope
{ from: 'address', to: ['address'] }
messageId
Troubleshooting​
“User is not authorized to perform: ses:SendEmail”​
Confirm that the IAM principal used by the SDK has theses:SendEmailpermission (seeExample 2).
Make sure theFromaddress (or its domain) isverifiedin the SES console.
Rare: AWS access keys containing non‑alphanumeric characters have been reported to fail—regenerate the keys if permission checks look correct.
Limited functionality:SES transport doesn't support verifying connections anymoresee
“Cannot find module '@aws-sdk/client-sesv2'”​
The SES SDK is not bundled with Nodemailer. Install it explicitly:
npm install @aws-sdk/client-sesv2
npm install @aws-sdk/client-sesv2
Examples​
1. Send a message​
constnodemailer=require("nodemailer");const{SESv2Client,SendEmailCommand}=require("@aws-sdk/client-sesv2");constsesClient=newSESv2Client({region:process.env.AWS_REGION});consttransporter=nodemailer.createTransport({SES:{sesClient,SendEmailCommand},});transporter.sendMail({from:"sender@example.com",to:["recipient@example.com"],subject:"Message via SES transport",text:"I hope this message gets sent!",ses:{EmailTags:[{Name:"tag_name",Value:"tag_value"}],},},(err,info)=>{if(err){console.error(err);return;}console.log(info.envelope);console.log(info.messageId);});
constnodemailer=require("nodemailer");const{SESv2Client,SendEmailCommand}=require("@aws-sdk/client-sesv2");constsesClient=newSESv2Client({region:process.env.AWS_REGION});consttransporter=nodemailer.createTransport({SES:{sesClient,SendEmailCommand},});transporter.sendMail({from:"sender@example.com",to:["recipient@example.com"],subject:"Message via SES transport",text:"I hope this message gets sent!",ses:{EmailTags:[{Name:"tag_name",Value:"tag_value"}],},},(err,info)=>{if(err){console.error(err);return;}console.log(info.envelope);console.log(info.messageId);});
2. Minimal IAM policy​
{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Action":"ses:SendRawEmail","Resource":"*"}]}
{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Action":"ses:SendRawEmail","Resource":"*"}]}
Quick start
Transport options
Message‑level options
Response object
Troubleshooting“User is not authorized to perform: ses:SendEmail”“Cannot find module '@aws-sdk/client-sesv2'”
“User is not authorized to perform: ses:SendEmail”
“Cannot find module '@aws-sdk/client-sesv2'”
Examples1. Send a message2. Minimal IAM policy
1. Send a message
2. Minimal IAM policy



===== https://nodemailer.com/transports/ses#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transportsSendmail transportSES transportStream transport
Sendmail transport
SES transport
Stream transport
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Other transports
SES transport
SES transport
NodemailerSES transportlets you deliver email throughAmazon Simple Email Service (SES)using the official AWS JavaScript SESv2 Client package@aws-sdk/client‑sesv2.
It is a thin wrapper aroundSendEmailCommandthat preserves the familiartransporter.sendMail()API.
SendEmailCommand
transporter.sendMail()
The SES SDK is not bundled with Nodemailer. Install it explicitly:
npm install @aws-sdk/client-sesv2
npm install @aws-sdk/client-sesv2
Quick start​
constnodemailer=require("nodemailer");const{SESv2Client,SendEmailCommand}=require("@aws-sdk/client-sesv2");// 1. Configure the AWS SDK client (uses default credential chain if omitted)constsesClient=newSESv2Client({region:"us‑east‑1"});// 2. Create a Nodemailer transport that points at SESconsttransporter=nodemailer.createTransport({SES:{sesClient,SendEmailCommand},});// 3. Send the messageconstinfo=awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Hello from Nodemailer + SES",text:"I hope this message gets sent!",// Any SendEmailCommand input can be set under the `ses` key:ses:{ConfigurationSetName:"my‑config‑set",EmailTags:[{Name:"tag_name",Value:"tag_value"}],},});console.log(info.envelope);// { from: ..., to: [...] }console.log(info.messageId);// SES MessageId
constnodemailer=require("nodemailer");const{SESv2Client,SendEmailCommand}=require("@aws-sdk/client-sesv2");// 1. Configure the AWS SDK client (uses default credential chain if omitted)constsesClient=newSESv2Client({region:"us‑east‑1"});// 2. Create a Nodemailer transport that points at SESconsttransporter=nodemailer.createTransport({SES:{sesClient,SendEmailCommand},});// 3. Send the messageconstinfo=awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Hello from Nodemailer + SES",text:"I hope this message gets sent!",// Any SendEmailCommand input can be set under the `ses` key:ses:{ConfigurationSetName:"my‑config‑set",EmailTags:[{Name:"tag_name",Value:"tag_value"}],},});console.log(info.envelope);// { from: ..., to: [...] }console.log(info.messageId);// SES MessageId
You can also use the traditional callback style—transporter.sendMail(mail, cb)—if you prefer.
transporter.sendMail(mail, cb)
Transport options​
Pass anSESobject tocreateTransport()with the followingrequiredkeys:
SES
createTransport()
sesClient
SESv2Client
SendEmailCommand
SendEmailCommand
Message‑level options​
sendMail()accepts an optionalsesproperty.
All keys of this object are merged into the input object passed toSendEmailCommand, so you can set any parameter supported by the operation (for exampleEmailTags,ConfigurationSetName, …).
sendMail()
EmailTags
ConfigurationSetName
Response object​
The promise (or callback) resolves to:
envelope
{ from: 'address', to: ['address'] }
messageId
Troubleshooting​
“User is not authorized to perform: ses:SendEmail”​
Confirm that the IAM principal used by the SDK has theses:SendEmailpermission (seeExample 2).
Make sure theFromaddress (or its domain) isverifiedin the SES console.
Rare: AWS access keys containing non‑alphanumeric characters have been reported to fail—regenerate the keys if permission checks look correct.
Limited functionality:SES transport doesn't support verifying connections anymoresee
“Cannot find module '@aws-sdk/client-sesv2'”​
The SES SDK is not bundled with Nodemailer. Install it explicitly:
npm install @aws-sdk/client-sesv2
npm install @aws-sdk/client-sesv2
Examples​
1. Send a message​
constnodemailer=require("nodemailer");const{SESv2Client,SendEmailCommand}=require("@aws-sdk/client-sesv2");constsesClient=newSESv2Client({region:process.env.AWS_REGION});consttransporter=nodemailer.createTransport({SES:{sesClient,SendEmailCommand},});transporter.sendMail({from:"sender@example.com",to:["recipient@example.com"],subject:"Message via SES transport",text:"I hope this message gets sent!",ses:{EmailTags:[{Name:"tag_name",Value:"tag_value"}],},},(err,info)=>{if(err){console.error(err);return;}console.log(info.envelope);console.log(info.messageId);});
constnodemailer=require("nodemailer");const{SESv2Client,SendEmailCommand}=require("@aws-sdk/client-sesv2");constsesClient=newSESv2Client({region:process.env.AWS_REGION});consttransporter=nodemailer.createTransport({SES:{sesClient,SendEmailCommand},});transporter.sendMail({from:"sender@example.com",to:["recipient@example.com"],subject:"Message via SES transport",text:"I hope this message gets sent!",ses:{EmailTags:[{Name:"tag_name",Value:"tag_value"}],},},(err,info)=>{if(err){console.error(err);return;}console.log(info.envelope);console.log(info.messageId);});
2. Minimal IAM policy​
{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Action":"ses:SendRawEmail","Resource":"*"}]}
{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Action":"ses:SendRawEmail","Resource":"*"}]}
Quick start
Transport options
Message‑level options
Response object
Troubleshooting“User is not authorized to perform: ses:SendEmail”“Cannot find module '@aws-sdk/client-sesv2'”
“User is not authorized to perform: ses:SendEmail”
“Cannot find module '@aws-sdk/client-sesv2'”
Examples1. Send a message2. Minimal IAM policy
1. Send a message
2. Minimal IAM policy



===== https://nodemailer.com/transports/stream =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transportsSendmail transportSES transportStream transport
Sendmail transport
SES transport
Stream transport
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Other transports
Stream transport
Stream transport
Stream transport isnota real SMTP transport. Instead of handing the message off to a remote mail server itbuildsthe complete RFC 822 e‑mail and gives it back to you. This makes it perfect for
Testing– inspect the exact bytes that would be sent over the wire, run snapshot tests, or feed the output to another system.
Custom delivery pipelines– run Nodemailer plugins (DKIM, list headers, etc.) and then deliver the message yourself via an in‑house API, store it for audit logging, and so on.
Enabling Stream transport​
Create the transporter just like any other Nodemailer transport, but passstreamTransport: truein the constructor options:
streamTransport: true
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({streamTransport:true,// optional tweaks shown below});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({streamTransport:true,// optional tweaks shown below});
Options​
streamTransport
boolean
buffer
boolean
false
Buffer
Readable
newline
'windows' | 'unix'
'unix'
\r\n
\n
jsonTransport
boolean
false
streamTransport
sendMail()callback signature​
sendMail()
The callback receives(err, info)whereinfocontains:
(err, info)
info
envelope– the SMTP envelope{ from, to }.
envelope
{ from, to }
messageId– theMessage‑IDheader value.
messageId
message– a Node.jsReadablestream (default)oraBuffer/JSON string depending on the options you set.
message
Readable
Buffer
Examples​
1. Stream a message with Windows‑style new‑lines​
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({streamTransport:true,newline:"windows",// CRLF (\r\n)});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Streamed message",text:"This message is streamed using CRLF new‑lines.",},(err,info)=>{if(err)throwerr;console.log(info.envelope);console.log(info.messageId);// Pipe the raw RFC 822 message to STDOUTinfo.message.pipe(process.stdout);});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({streamTransport:true,newline:"windows",// CRLF (\r\n)});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Streamed message",text:"This message is streamed using CRLF new‑lines.",},(err,info)=>{if(err)throwerr;console.log(info.envelope);console.log(info.messageId);// Pipe the raw RFC 822 message to STDOUTinfo.message.pipe(process.stdout);});
2. Return aBufferwith Unix‑style new‑lines​
Buffer
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({streamTransport:true,buffer:true,// return Buffer instead of Streamnewline:"unix",// LF (\n)});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Buffered message",text:"This message is buffered using LF new‑lines.",},(err,info)=>{if(err)throwerr;console.log(info.envelope);console.log(info.messageId);// The complete message is in a single Bufferconsole.log(info.message.toString());});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({streamTransport:true,buffer:true,// return Buffer instead of Streamnewline:"unix",// LF (\n)});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Buffered message",text:"This message is buffered using LF new‑lines.",},(err,info)=>{if(err)throwerr;console.log(info.envelope);console.log(info.messageId);// The complete message is in a single Bufferconsole.log(info.message.toString());});
3. Generate a JSON‑encoded message object (≥ v3.1.0)​
PassjsonTransport: true(and omitstreamTransport). The resultinginfo.messageis a serialized JSON string that you can later feed back to Nodemailer or inspect in your tests. Binary data such as attachments is base64‑encoded.
jsonTransport: true
streamTransport
info.message
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({jsonTransport:true,});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"JSON message",text:"I hope this message gets JSON‑ified!",},(err,info)=>{if(err)throwerr;console.log(info.envelope);console.log(info.messageId);console.log(info.message);// JSON string});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({jsonTransport:true,});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"JSON message",text:"I hope this message gets JSON‑ified!",},(err,info)=>{if(err)throwerr;console.log(info.envelope);console.log(info.messageId);console.log(info.message);// JSON string});
An abbreviated example of the JSON payload:
{"from":{"address":"sender@example.com","name":""},"to":[{"address":"recipient@example.com","name":""}],"subject":"JSON message","text":"I hope this message gets JSON‑ified!","headers":{},"messageId":"<77a3458f-8070-339d-095f-85bb73f3db8e@example.com>"}
{"from":{"address":"sender@example.com","name":""},"to":[{"address":"recipient@example.com","name":""}],"subject":"JSON message","text":"I hope this message gets JSON‑ified!","headers":{},"messageId":"<77a3458f-8070-339d-095f-85bb73f3db8e@example.com>"}
When to choose Stream vs. JSON transport​
streamTransport
jsonTransport
_raw
Enabling Stream transportOptionssendMail()callback signature
Options
sendMail()callback signature
sendMail()
Examples1. Stream a message with Windows‑style new‑lines2. Return aBufferwith Unix‑style new‑lines3. Generate a JSON‑encoded message object (≥ v3.1.0)
1. Stream a message with Windows‑style new‑lines
2. Return aBufferwith Unix‑style new‑lines
Buffer
3. Generate a JSON‑encoded message object (≥ v3.1.0)
When to choose Stream vs. JSON transport



===== https://nodemailer.com/transports/stream#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transportsSendmail transportSES transportStream transport
Sendmail transport
SES transport
Stream transport
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Other transports
Stream transport
Stream transport
Stream transport isnota real SMTP transport. Instead of handing the message off to a remote mail server itbuildsthe complete RFC 822 e‑mail and gives it back to you. This makes it perfect for
Testing– inspect the exact bytes that would be sent over the wire, run snapshot tests, or feed the output to another system.
Custom delivery pipelines– run Nodemailer plugins (DKIM, list headers, etc.) and then deliver the message yourself via an in‑house API, store it for audit logging, and so on.
Enabling Stream transport​
Create the transporter just like any other Nodemailer transport, but passstreamTransport: truein the constructor options:
streamTransport: true
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({streamTransport:true,// optional tweaks shown below});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({streamTransport:true,// optional tweaks shown below});
Options​
streamTransport
boolean
buffer
boolean
false
Buffer
Readable
newline
'windows' | 'unix'
'unix'
\r\n
\n
jsonTransport
boolean
false
streamTransport
sendMail()callback signature​
sendMail()
The callback receives(err, info)whereinfocontains:
(err, info)
info
envelope– the SMTP envelope{ from, to }.
envelope
{ from, to }
messageId– theMessage‑IDheader value.
messageId
message– a Node.jsReadablestream (default)oraBuffer/JSON string depending on the options you set.
message
Readable
Buffer
Examples​
1. Stream a message with Windows‑style new‑lines​
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({streamTransport:true,newline:"windows",// CRLF (\r\n)});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Streamed message",text:"This message is streamed using CRLF new‑lines.",},(err,info)=>{if(err)throwerr;console.log(info.envelope);console.log(info.messageId);// Pipe the raw RFC 822 message to STDOUTinfo.message.pipe(process.stdout);});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({streamTransport:true,newline:"windows",// CRLF (\r\n)});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Streamed message",text:"This message is streamed using CRLF new‑lines.",},(err,info)=>{if(err)throwerr;console.log(info.envelope);console.log(info.messageId);// Pipe the raw RFC 822 message to STDOUTinfo.message.pipe(process.stdout);});
2. Return aBufferwith Unix‑style new‑lines​
Buffer
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({streamTransport:true,buffer:true,// return Buffer instead of Streamnewline:"unix",// LF (\n)});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Buffered message",text:"This message is buffered using LF new‑lines.",},(err,info)=>{if(err)throwerr;console.log(info.envelope);console.log(info.messageId);// The complete message is in a single Bufferconsole.log(info.message.toString());});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({streamTransport:true,buffer:true,// return Buffer instead of Streamnewline:"unix",// LF (\n)});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Buffered message",text:"This message is buffered using LF new‑lines.",},(err,info)=>{if(err)throwerr;console.log(info.envelope);console.log(info.messageId);// The complete message is in a single Bufferconsole.log(info.message.toString());});
3. Generate a JSON‑encoded message object (≥ v3.1.0)​
PassjsonTransport: true(and omitstreamTransport). The resultinginfo.messageis a serialized JSON string that you can later feed back to Nodemailer or inspect in your tests. Binary data such as attachments is base64‑encoded.
jsonTransport: true
streamTransport
info.message
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({jsonTransport:true,});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"JSON message",text:"I hope this message gets JSON‑ified!",},(err,info)=>{if(err)throwerr;console.log(info.envelope);console.log(info.messageId);console.log(info.message);// JSON string});
constnodemailer=require("nodemailer");consttransporter=nodemailer.createTransport({jsonTransport:true,});transporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"JSON message",text:"I hope this message gets JSON‑ified!",},(err,info)=>{if(err)throwerr;console.log(info.envelope);console.log(info.messageId);console.log(info.message);// JSON string});
An abbreviated example of the JSON payload:
{"from":{"address":"sender@example.com","name":""},"to":[{"address":"recipient@example.com","name":""}],"subject":"JSON message","text":"I hope this message gets JSON‑ified!","headers":{},"messageId":"<77a3458f-8070-339d-095f-85bb73f3db8e@example.com>"}
{"from":{"address":"sender@example.com","name":""},"to":[{"address":"recipient@example.com","name":""}],"subject":"JSON message","text":"I hope this message gets JSON‑ified!","headers":{},"messageId":"<77a3458f-8070-339d-095f-85bb73f3db8e@example.com>"}
When to choose Stream vs. JSON transport​
streamTransport
jsonTransport
_raw
Enabling Stream transportOptionssendMail()callback signature
Options
sendMail()callback signature
sendMail()
Examples1. Stream a message with Windows‑style new‑lines2. Return aBufferwith Unix‑style new‑lines3. Generate a JSON‑encoded message object (≥ v3.1.0)
1. Stream a message with Windows‑style new‑lines
2. Return aBufferwith Unix‑style new‑lines
Buffer
3. Generate a JSON‑encoded message object (≥ v3.1.0)
When to choose Stream vs. JSON transport



===== https://nodemailer.com/plugins =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
PluginsCreate plugins
Create plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Plugins
Plugins
Nodemailer is designed to beextensible. You can inject custom logic at three well‑defined phases of a message’s lifecycle:
compile
stream
transport
Prefercompileandstreamplugins for portability. Transport plugins are only required when you need complete control over delivery.
Writing a plugin​
// commonjs — works on Node.js ≥ 6.0.0module.exports=functionmyCompilePlugin(mail,callback){// `mail` is the Nodemailer Mail object// Add or adjust properties before the MIME source is generatedif(!mail.data.text&&mail.data.html){mail.data.text=require("html-to-text").htmlToText(mail.data.html);}callback();// Always invoke the callback (or pass an Error)};
// commonjs — works on Node.js ≥ 6.0.0module.exports=functionmyCompilePlugin(mail,callback){// `mail` is the Nodemailer Mail object// Add or adjust properties before the MIME source is generatedif(!mail.data.text&&mail.data.html){mail.data.text=require("html-to-text").htmlToText(mail.data.html);}callback();// Always invoke the callback (or pass an Error)};
Register the plugin on a transport instance:
constnodemailer=require("nodemailer");consttransport=nodemailer.createTransport({sendmail:true});transport.use("compile",require("./myCompilePlugin"));
constnodemailer=require("nodemailer");consttransport=nodemailer.createTransport({sendmail:true});transport.use("compile",require("./myCompilePlugin"));
Error handling​
If your plugin encounters a fatal problem, pass anErrorobject to the callback:
Error
callback(newError("Template not found"));
callback(newError("Template not found"));
The message willnotbe sent and the error will propagate to the caller’ssendMail()callback/promise.
sendMail()
Public plugins​
A curated selection of community‑maintained plugins:
express‑handlebars– Render Handlebars templates from your Express views directory.https://github.com/yads/nodemailer-express-handlebars
inline‑base64– Convert inline base64‑encoded images to CID attachments.https://github.com/mixmaxhq/nodemailer-plugin-inline-base64
html‑to‑text– Automatically generate a plain‑text version when one is missing.https://github.com/andris9/nodemailer-html-to-text
Looking for something else? Trysearching npm for “nodemailer plugin”.
Need more power? SeeCreating plugins »for a deep dive into the plugin API.
Writing a pluginError handling
Error handling
Public plugins



===== https://nodemailer.com/plugins#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
PluginsCreate plugins
Create plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Plugins
Plugins
Nodemailer is designed to beextensible. You can inject custom logic at three well‑defined phases of a message’s lifecycle:
compile
stream
transport
Prefercompileandstreamplugins for portability. Transport plugins are only required when you need complete control over delivery.
Writing a plugin​
// commonjs — works on Node.js ≥ 6.0.0module.exports=functionmyCompilePlugin(mail,callback){// `mail` is the Nodemailer Mail object// Add or adjust properties before the MIME source is generatedif(!mail.data.text&&mail.data.html){mail.data.text=require("html-to-text").htmlToText(mail.data.html);}callback();// Always invoke the callback (or pass an Error)};
// commonjs — works on Node.js ≥ 6.0.0module.exports=functionmyCompilePlugin(mail,callback){// `mail` is the Nodemailer Mail object// Add or adjust properties before the MIME source is generatedif(!mail.data.text&&mail.data.html){mail.data.text=require("html-to-text").htmlToText(mail.data.html);}callback();// Always invoke the callback (or pass an Error)};
Register the plugin on a transport instance:
constnodemailer=require("nodemailer");consttransport=nodemailer.createTransport({sendmail:true});transport.use("compile",require("./myCompilePlugin"));
constnodemailer=require("nodemailer");consttransport=nodemailer.createTransport({sendmail:true});transport.use("compile",require("./myCompilePlugin"));
Error handling​
If your plugin encounters a fatal problem, pass anErrorobject to the callback:
Error
callback(newError("Template not found"));
callback(newError("Template not found"));
The message willnotbe sent and the error will propagate to the caller’ssendMail()callback/promise.
sendMail()
Public plugins​
A curated selection of community‑maintained plugins:
express‑handlebars– Render Handlebars templates from your Express views directory.https://github.com/yads/nodemailer-express-handlebars
inline‑base64– Convert inline base64‑encoded images to CID attachments.https://github.com/mixmaxhq/nodemailer-plugin-inline-base64
html‑to‑text– Automatically generate a plain‑text version when one is missing.https://github.com/andris9/nodemailer-html-to-text
Looking for something else? Trysearching npm for “nodemailer plugin”.
Need more power? SeeCreating plugins »for a deep dive into the plugin API.
Writing a pluginError handling
Error handling
Public plugins



===== https://nodemailer.com/plugins/create =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
PluginsCreate plugins
Create plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Plugins
Create plugins
Create plugins
Nodemailer exposes three points in the e‑mail delivery pipeline where you can attachplugins:
compile– triggered right after the originalsendMail()input has been received, before any MIME tree has been built. Modifymail.datahere (e.g. tweakhtmlcontents, add headers, etc.).
compile
sendMail()
mail.data
html
stream– triggered after Nodemailer has generated the complete MIME tree butbeforeit starts streaming the raw message. At this stage you can mutate themail.messageobject or inject transform streams that the message is piped through.
stream
mail.message
Transport– the final step where the raw message stream is sent to its destination. Custom transports implement this stage themselves.
Attachingcompileandstreamplugins​
compile
stream
transporter.use(step,pluginFn);
transporter.use(step,pluginFn);
transporter
Object
nodemailer.createTransport()
step
String
'compile'
'stream'
pluginFn
Function(mail, done)
Plugin API​
Every plugin ‑‑ including custom transports ‑‑ receives two arguments:
mail– Details about the message being processed (see below)
mail
done– Callbackfunction (err?)whichmustbe invoked when your plugin finishes (pass anErrorto abort the send)
done
function (err?)
Error
mailobject​
mail
data
compile
stream
sendMail()
message
stream
MimeNode
resolveContent
compile
stream
String
Buffer
mail.resolveContent(obj, key, callback)​
mail.resolveContent(obj, key, callback)
Convert anyNodemailer content type(file path, URL, Stream, Buffer, etc.) into a plainStringorBuffer.
String
Buffer
mail.resolveContent(sourceObject,propertyName,(err,value)=>{if(err)returndone(err);// value is String or Buffer depending on the input type});
mail.resolveContent(sourceObject,propertyName,(err,value)=>{if(err)returndone(err);// value is String or Buffer depending on the input type});
functionplugin(mail,done){mail.resolveContent(mail.data,"html",(err,html)=>{if(err)returndone(err);console.log("HTML contents: %s",html.toString());done();});}
functionplugin(mail,done){mail.resolveContent(mail.data,"html",(err,html)=>{if(err)returndone(err);console.log("HTML contents: %s",html.toString());done();});}
compileplugins​
compile
compilepluginsonlyreceivemail.data;mail.messagedoesnotyet exist. Mutatemail.datafreely and calldone()when finished. Returning an error abortssendMail().
compile
mail.data
mail.message
mail.data
done()
sendMail()
text
html
transporter.use("compile",(mail,done)=>{if(!mail.data.text&&mail.data.html){mail.data.text=mail.data.html.replace(/<[^>]*>/g," ");}done();});
transporter.use("compile",(mail,done)=>{if(!mail.data.text&&mail.data.html){mail.data.text=mail.data.html.replace(/<[^>]*>/g," ");}done();});
streamplugins​
stream
streamplugins are invokedafterthe MIME tree is ready butbeforethe first byte is sent. You can:
stream
Mutatemail.message(e.g. add headers)
mail.message
Pipe the output through additional Transform streams viamail.message.transform()
mail.message.transform()
Editingmail.dataat this stage usually hasno effectunless your custom transport explicitly reads the changed property.
mail.data
Example – replace all tabs with spaces in the outgoing stream​
const{Transform}=require("stream");consttabToSpace=newTransform();tabToSpace._transform=function(chunk,_enc,cb){for(leti=0;i<chunk.length;++i){if(chunk[i]===0x09)chunk[i]=0x20;// 0x09 = TAB, 0x20 = space}this.push(chunk);cb();};transporter.use("stream",(mail,done)=>{mail.message.transform(tabToSpace);done();});
const{Transform}=require("stream");consttabToSpace=newTransform();tabToSpace._transform=function(chunk,_enc,cb){for(leti=0;i<chunk.length;++i){if(chunk[i]===0x09)chunk[i]=0x20;// 0x09 = TAB, 0x20 = space}this.push(chunk);cb();};transporter.use("stream",(mail,done)=>{mail.message.transform(tabToSpace);done();});
Example – log all address fields​
transporter.use("stream",(mail,done)=>{consta=mail.message.getAddresses();console.log("From :",JSON.stringify(a.from));console.log("To   :",JSON.stringify(a.to));console.log("Cc   :",JSON.stringify(a.cc));console.log("Bcc  :",JSON.stringify(a.bcc));done();});
transporter.use("stream",(mail,done)=>{consta=mail.message.getAddresses();console.log("From :",JSON.stringify(a.from));console.log("To   :",JSON.stringify(a.to));console.log("Cc   :",JSON.stringify(a.cc));console.log("Bcc  :",JSON.stringify(a.bcc));done();});
mail.message.transform(transformStream)​
mail.message.transform(transformStream)
Add astream.Transform(or a function returning one) through which the raw message is pipedbeforeit reaches the transport.
stream.Transform
mail.message.getAddresses()​
mail.message.getAddresses()
Returns an object containing parsed addresses fromFrom,Sender,Reply‑To,To,Cc, andBccheaders. Each property is anarrayof{ name, address }. Absent fields are omitted.
{ name, address }
Writing a custom transport​
A transport is simply an object withname,version, and asend(mail, done)method. Provide the object tonodemailer.createTransport()to create a usable transporter.
name
version
send(mail, done)
nodemailer.createTransport()
constnodemailer=require("nodemailer");consttransport={name:require("./package.json").name,// e.g. "SMTP"version:require("./package.json").version,// e.g. "1.0.0"/*** Actually sends the message.*@param{Object}mail– the same `mail` object plugins receive*@param{Function}done– callback `(err, info)`*/send(mail,done){constinput=mail.message.createReadStream();constenvelope=mail.message.getEnvelope();constmessageId=mail.message.messageId();// For demo purposes we just pipe to stdoutinput.pipe(process.stdout);input.on("end",()=>{done(null,{envelope,messageId,});});},/* Optional: close long‑lived connections (e.g. pooled SMTP) */close(){// Clean‑up resources here},/* Optional: report idling state (used by pooling)Should return `true` when the transport has capacity to send more messages. */isIdle(){returntrue;},};consttransporter=nodemailer.createTransport(transport);transporter.sendMail({from:"sender@example.com",to:"receiver@example.com",subject:"Hello",text:"Hello world!",},console.log);
constnodemailer=require("nodemailer");consttransport={name:require("./package.json").name,// e.g. "SMTP"version:require("./package.json").version,// e.g. "1.0.0"/*** Actually sends the message.*@param{Object}mail– the same `mail` object plugins receive*@param{Function}done– callback `(err, info)`*/send(mail,done){constinput=mail.message.createReadStream();constenvelope=mail.message.getEnvelope();constmessageId=mail.message.messageId();// For demo purposes we just pipe to stdoutinput.pipe(process.stdout);input.on("end",()=>{done(null,{envelope,messageId,});});},/* Optional: close long‑lived connections (e.g. pooled SMTP) */close(){// Clean‑up resources here},/* Optional: report idling state (used by pooling)Should return `true` when the transport has capacity to send more messages. */isIdle(){returntrue;},};consttransporter=nodemailer.createTransport(transport);transporter.sendMail({from:"sender@example.com",to:"receiver@example.com",subject:"Hello",text:"Hello world!",},console.log);
Summary​
Decide which stage (compile,stream, or customtransport) best suits your use‑case.
compile
stream
Write a plugin function receiving(mail, done)and attach it withtransporter.use()(or implementtransport.send).
(mail, done)
transporter.use()
transport.send
Always invokedone(err?)to signal completion or abort the send.
done(err?)
Happy Hacking! 🚀
Attachingcompileandstreamplugins
compile
stream
Plugin APImailobjectmail.resolveContent(obj, key, callback)
mailobject
mail
mail.resolveContent(obj, key, callback)
mail.resolveContent(obj, key, callback)
compileplugins
compile
streampluginsExample – replace all tabs with spaces in the outgoing streamExample – log all address fieldsmail.message.transform(transformStream)mail.message.getAddresses()
stream
Example – replace all tabs with spaces in the outgoing stream
Example – log all address fields
mail.message.transform(transformStream)
mail.message.transform(transformStream)
mail.message.getAddresses()
mail.message.getAddresses()
Writing a custom transport
Summary



===== https://nodemailer.com/plugins/create#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
PluginsCreate plugins
Create plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Plugins
Create plugins
Create plugins
Nodemailer exposes three points in the e‑mail delivery pipeline where you can attachplugins:
compile– triggered right after the originalsendMail()input has been received, before any MIME tree has been built. Modifymail.datahere (e.g. tweakhtmlcontents, add headers, etc.).
compile
sendMail()
mail.data
html
stream– triggered after Nodemailer has generated the complete MIME tree butbeforeit starts streaming the raw message. At this stage you can mutate themail.messageobject or inject transform streams that the message is piped through.
stream
mail.message
Transport– the final step where the raw message stream is sent to its destination. Custom transports implement this stage themselves.
Attachingcompileandstreamplugins​
compile
stream
transporter.use(step,pluginFn);
transporter.use(step,pluginFn);
transporter
Object
nodemailer.createTransport()
step
String
'compile'
'stream'
pluginFn
Function(mail, done)
Plugin API​
Every plugin ‑‑ including custom transports ‑‑ receives two arguments:
mail– Details about the message being processed (see below)
mail
done– Callbackfunction (err?)whichmustbe invoked when your plugin finishes (pass anErrorto abort the send)
done
function (err?)
Error
mailobject​
mail
data
compile
stream
sendMail()
message
stream
MimeNode
resolveContent
compile
stream
String
Buffer
mail.resolveContent(obj, key, callback)​
mail.resolveContent(obj, key, callback)
Convert anyNodemailer content type(file path, URL, Stream, Buffer, etc.) into a plainStringorBuffer.
String
Buffer
mail.resolveContent(sourceObject,propertyName,(err,value)=>{if(err)returndone(err);// value is String or Buffer depending on the input type});
mail.resolveContent(sourceObject,propertyName,(err,value)=>{if(err)returndone(err);// value is String or Buffer depending on the input type});
functionplugin(mail,done){mail.resolveContent(mail.data,"html",(err,html)=>{if(err)returndone(err);console.log("HTML contents: %s",html.toString());done();});}
functionplugin(mail,done){mail.resolveContent(mail.data,"html",(err,html)=>{if(err)returndone(err);console.log("HTML contents: %s",html.toString());done();});}
compileplugins​
compile
compilepluginsonlyreceivemail.data;mail.messagedoesnotyet exist. Mutatemail.datafreely and calldone()when finished. Returning an error abortssendMail().
compile
mail.data
mail.message
mail.data
done()
sendMail()
text
html
transporter.use("compile",(mail,done)=>{if(!mail.data.text&&mail.data.html){mail.data.text=mail.data.html.replace(/<[^>]*>/g," ");}done();});
transporter.use("compile",(mail,done)=>{if(!mail.data.text&&mail.data.html){mail.data.text=mail.data.html.replace(/<[^>]*>/g," ");}done();});
streamplugins​
stream
streamplugins are invokedafterthe MIME tree is ready butbeforethe first byte is sent. You can:
stream
Mutatemail.message(e.g. add headers)
mail.message
Pipe the output through additional Transform streams viamail.message.transform()
mail.message.transform()
Editingmail.dataat this stage usually hasno effectunless your custom transport explicitly reads the changed property.
mail.data
Example – replace all tabs with spaces in the outgoing stream​
const{Transform}=require("stream");consttabToSpace=newTransform();tabToSpace._transform=function(chunk,_enc,cb){for(leti=0;i<chunk.length;++i){if(chunk[i]===0x09)chunk[i]=0x20;// 0x09 = TAB, 0x20 = space}this.push(chunk);cb();};transporter.use("stream",(mail,done)=>{mail.message.transform(tabToSpace);done();});
const{Transform}=require("stream");consttabToSpace=newTransform();tabToSpace._transform=function(chunk,_enc,cb){for(leti=0;i<chunk.length;++i){if(chunk[i]===0x09)chunk[i]=0x20;// 0x09 = TAB, 0x20 = space}this.push(chunk);cb();};transporter.use("stream",(mail,done)=>{mail.message.transform(tabToSpace);done();});
Example – log all address fields​
transporter.use("stream",(mail,done)=>{consta=mail.message.getAddresses();console.log("From :",JSON.stringify(a.from));console.log("To   :",JSON.stringify(a.to));console.log("Cc   :",JSON.stringify(a.cc));console.log("Bcc  :",JSON.stringify(a.bcc));done();});
transporter.use("stream",(mail,done)=>{consta=mail.message.getAddresses();console.log("From :",JSON.stringify(a.from));console.log("To   :",JSON.stringify(a.to));console.log("Cc   :",JSON.stringify(a.cc));console.log("Bcc  :",JSON.stringify(a.bcc));done();});
mail.message.transform(transformStream)​
mail.message.transform(transformStream)
Add astream.Transform(or a function returning one) through which the raw message is pipedbeforeit reaches the transport.
stream.Transform
mail.message.getAddresses()​
mail.message.getAddresses()
Returns an object containing parsed addresses fromFrom,Sender,Reply‑To,To,Cc, andBccheaders. Each property is anarrayof{ name, address }. Absent fields are omitted.
{ name, address }
Writing a custom transport​
A transport is simply an object withname,version, and asend(mail, done)method. Provide the object tonodemailer.createTransport()to create a usable transporter.
name
version
send(mail, done)
nodemailer.createTransport()
constnodemailer=require("nodemailer");consttransport={name:require("./package.json").name,// e.g. "SMTP"version:require("./package.json").version,// e.g. "1.0.0"/*** Actually sends the message.*@param{Object}mail– the same `mail` object plugins receive*@param{Function}done– callback `(err, info)`*/send(mail,done){constinput=mail.message.createReadStream();constenvelope=mail.message.getEnvelope();constmessageId=mail.message.messageId();// For demo purposes we just pipe to stdoutinput.pipe(process.stdout);input.on("end",()=>{done(null,{envelope,messageId,});});},/* Optional: close long‑lived connections (e.g. pooled SMTP) */close(){// Clean‑up resources here},/* Optional: report idling state (used by pooling)Should return `true` when the transport has capacity to send more messages. */isIdle(){returntrue;},};consttransporter=nodemailer.createTransport(transport);transporter.sendMail({from:"sender@example.com",to:"receiver@example.com",subject:"Hello",text:"Hello world!",},console.log);
constnodemailer=require("nodemailer");consttransport={name:require("./package.json").name,// e.g. "SMTP"version:require("./package.json").version,// e.g. "1.0.0"/*** Actually sends the message.*@param{Object}mail– the same `mail` object plugins receive*@param{Function}done– callback `(err, info)`*/send(mail,done){constinput=mail.message.createReadStream();constenvelope=mail.message.getEnvelope();constmessageId=mail.message.messageId();// For demo purposes we just pipe to stdoutinput.pipe(process.stdout);input.on("end",()=>{done(null,{envelope,messageId,});});},/* Optional: close long‑lived connections (e.g. pooled SMTP) */close(){// Clean‑up resources here},/* Optional: report idling state (used by pooling)Should return `true` when the transport has capacity to send more messages. */isIdle(){returntrue;},};consttransporter=nodemailer.createTransport(transport);transporter.sendMail({from:"sender@example.com",to:"receiver@example.com",subject:"Hello",text:"Hello world!",},console.log);
Summary​
Decide which stage (compile,stream, or customtransport) best suits your use‑case.
compile
stream
Write a plugin function receiving(mail, done)and attach it withtransporter.use()(or implementtransport.send).
(mail, done)
transporter.use()
transport.send
Always invokedone(err?)to signal completion or abort the send.
done(err?)
Happy Hacking! 🚀
Attachingcompileandstreamplugins
compile
stream
Plugin APImailobjectmail.resolveContent(obj, key, callback)
mailobject
mail
mail.resolveContent(obj, key, callback)
mail.resolveContent(obj, key, callback)
compileplugins
compile
streampluginsExample – replace all tabs with spaces in the outgoing streamExample – log all address fieldsmail.message.transform(transformStream)mail.message.getAddresses()
stream
Example – replace all tabs with spaces in the outgoing stream
Example – log all address fields
mail.message.transform(transformStream)
mail.message.transform(transformStream)
mail.message.getAddresses()
mail.message.getAddresses()
Writing a custom transport
Summary



===== https://nodemailer.com/dkim =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
DKIM
DKIM Signing
DomainKeys Identified Mail (DKIM) adds a cryptographic signature to every
out‑going message, allowing receiving servers to verify that the message
really originates fromyourdomain and has not been altered in transit.
Nodemailer can sign messages with one or more DKIM keyswithoutany extra
dependencies. In most cases signing is fast and fully in‑memory. For very large
messages you can optionally enable on‑disk caching so that only the firstcacheTresholdbytes are kept in RAM.
Configuration​
DKIM can be configured either
Transport‑wide– every message sent through the transporter is signed
with the same key(s),or
Per‑message– pass adkimobject in theMailOptionsto override the
transport settings.
dkim
If both are present themessage‑level settings win.
DKIM options​
domainName
string
d=
keySelector
string
<selector>._domainkey.<domain>
privateKey
string | Buffer
keys
Array< {domainName, keySelector, privateKey} >
hashAlgo
'sha256' | 'sha1'
'sha256'
headerFieldNames
string
skipFields
string
message-id:date
cacheDir
string | false
false
cacheTreshold
number
131 072
cacheDir
The optioncacheTresholdis intentionally misspelled to preserve backwards‑compatibility with older Nodemailer versions.
cacheTreshold
Usage examples​
All snippets assume at leastNode.js v6and use CommonJS style:
constnodemailer=require("nodemailer");
constnodemailer=require("nodemailer");
1 – Sign every message​
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim-private.pem","utf8"),},});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim-private.pem","utf8"),},});
Check that the TXT record exists:
dig TXT 2017._domainkey.example.com
dig TXT 2017._domainkey.example.com
2 – Sign withmultiplekeys​
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,dkim:{keys:[{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim-2017.pem","utf8"),},{domainName:"example.com",keySelector:"2016",privateKey:fs.readFileSync("./dkim-2016.pem","utf8"),},],cacheDir:false,// disable disk caching},});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,dkim:{keys:[{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim-2017.pem","utf8"),},{domainName:"example.com",keySelector:"2016",privateKey:fs.readFileSync("./dkim-2016.pem","utf8"),},],cacheDir:false,// disable disk caching},});
3 – Signonespecific message​
consttransporter=nodemailer.createTransport({/* no global DKIM */});constinfo=awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Hello w/ DKIM",text:"I hope this message gets read!",dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim-private.pem","utf8"),},});
consttransporter=nodemailer.createTransport({/* no global DKIM */});constinfo=awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Hello w/ DKIM",text:"I hope this message gets read!",dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim-private.pem","utf8"),},});
4 – Cache large messages on disk​
consttransporter=nodemailer.createTransport({/* …SMTP details… */dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim.pem","utf8"),cacheDir:"/tmp",cacheTreshold:100*1024,// 100 kB},});
consttransporter=nodemailer.createTransport({/* …SMTP details… */dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim.pem","utf8"),cacheDir:"/tmp",cacheTreshold:100*1024,// 100 kB},});
5 – Skip mutable headers​
When sending through services such asAmazon SES,Message‑IDandDateare often replaced. Exclude these fields so the signature
survives:
Message‑ID
Date
consttransporter=nodemailer.createTransport({/* …SMTP details… */dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim.pem","utf8"),skipFields:"message-id:date",},});
consttransporter=nodemailer.createTransport({/* …SMTP details… */dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim.pem","utf8"),skipFields:"message-id:date",},});
Troubleshooting​
Signature fails– Ensure the public key is published at<keySelector>._domainkey.<domainName>and isunder 1024 chars(some DNS providers truncate long TXT records).
<keySelector>._domainkey.<domainName>
Header fields mismatched– Add them toskipFieldsor re‑order your
headers to match exactly what is sent on the wire.
skipFields
Still stuck?Run a full test with tools such asdkimvalidator.comormail-tester.com.
dkimvalidator.com
mail-tester.com
ConfigurationDKIM options
DKIM options
Usage examples1 – Sign every message2 – Sign withmultiplekeys3 – Signonespecific message4 – Cache large messages on disk5 – Skip mutable headers
1 – Sign every message
2 – Sign withmultiplekeys
3 – Signonespecific message
4 – Cache large messages on disk
5 – Skip mutable headers
Troubleshooting



===== https://nodemailer.com/dkim#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
DKIM
DKIM Signing
DomainKeys Identified Mail (DKIM) adds a cryptographic signature to every
out‑going message, allowing receiving servers to verify that the message
really originates fromyourdomain and has not been altered in transit.
Nodemailer can sign messages with one or more DKIM keyswithoutany extra
dependencies. In most cases signing is fast and fully in‑memory. For very large
messages you can optionally enable on‑disk caching so that only the firstcacheTresholdbytes are kept in RAM.
Configuration​
DKIM can be configured either
Transport‑wide– every message sent through the transporter is signed
with the same key(s),or
Per‑message– pass adkimobject in theMailOptionsto override the
transport settings.
dkim
If both are present themessage‑level settings win.
DKIM options​
domainName
string
d=
keySelector
string
<selector>._domainkey.<domain>
privateKey
string | Buffer
keys
Array< {domainName, keySelector, privateKey} >
hashAlgo
'sha256' | 'sha1'
'sha256'
headerFieldNames
string
skipFields
string
message-id:date
cacheDir
string | false
false
cacheTreshold
number
131 072
cacheDir
The optioncacheTresholdis intentionally misspelled to preserve backwards‑compatibility with older Nodemailer versions.
cacheTreshold
Usage examples​
All snippets assume at leastNode.js v6and use CommonJS style:
constnodemailer=require("nodemailer");
constnodemailer=require("nodemailer");
1 – Sign every message​
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim-private.pem","utf8"),},});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim-private.pem","utf8"),},});
Check that the TXT record exists:
dig TXT 2017._domainkey.example.com
dig TXT 2017._domainkey.example.com
2 – Sign withmultiplekeys​
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,dkim:{keys:[{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim-2017.pem","utf8"),},{domainName:"example.com",keySelector:"2016",privateKey:fs.readFileSync("./dkim-2016.pem","utf8"),},],cacheDir:false,// disable disk caching},});
consttransporter=nodemailer.createTransport({host:"smtp.example.com",port:465,secure:true,dkim:{keys:[{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim-2017.pem","utf8"),},{domainName:"example.com",keySelector:"2016",privateKey:fs.readFileSync("./dkim-2016.pem","utf8"),},],cacheDir:false,// disable disk caching},});
3 – Signonespecific message​
consttransporter=nodemailer.createTransport({/* no global DKIM */});constinfo=awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Hello w/ DKIM",text:"I hope this message gets read!",dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim-private.pem","utf8"),},});
consttransporter=nodemailer.createTransport({/* no global DKIM */});constinfo=awaittransporter.sendMail({from:"sender@example.com",to:"recipient@example.com",subject:"Hello w/ DKIM",text:"I hope this message gets read!",dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim-private.pem","utf8"),},});
4 – Cache large messages on disk​
consttransporter=nodemailer.createTransport({/* …SMTP details… */dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim.pem","utf8"),cacheDir:"/tmp",cacheTreshold:100*1024,// 100 kB},});
consttransporter=nodemailer.createTransport({/* …SMTP details… */dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim.pem","utf8"),cacheDir:"/tmp",cacheTreshold:100*1024,// 100 kB},});
5 – Skip mutable headers​
When sending through services such asAmazon SES,Message‑IDandDateare often replaced. Exclude these fields so the signature
survives:
Message‑ID
Date
consttransporter=nodemailer.createTransport({/* …SMTP details… */dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim.pem","utf8"),skipFields:"message-id:date",},});
consttransporter=nodemailer.createTransport({/* …SMTP details… */dkim:{domainName:"example.com",keySelector:"2017",privateKey:fs.readFileSync("./dkim.pem","utf8"),skipFields:"message-id:date",},});
Troubleshooting​
Signature fails– Ensure the public key is published at<keySelector>._domainkey.<domainName>and isunder 1024 chars(some DNS providers truncate long TXT records).
<keySelector>._domainkey.<domainName>
Header fields mismatched– Add them toskipFieldsor re‑order your
headers to match exactly what is sent on the wire.
skipFields
Still stuck?Run a full test with tools such asdkimvalidator.comormail-tester.com.
dkimvalidator.com
mail-tester.com
ConfigurationDKIM options
DKIM options
Usage examples1 – Sign every message2 – Sign withmultiplekeys3 – Signonespecific message4 – Cache large messages on disk5 – Skip mutable headers
1 – Sign every message
2 – Sign withmultiplekeys
3 – Signonespecific message
4 – Cache large messages on disk
5 – Skip mutable headers
Troubleshooting



===== https://nodemailer.com/extras =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Extra modules
Beyond Nodemailer itself, a collection of companion libraries can help you receive, compose, parse, and preview e‑mail inside your Node.js applications.
Official companion libraries​
smtp-server– Accept inbound SMTP connections and build a custom SMTP server or test harness.
smtp-connection– Low‑level SMTP client for establishing outbound SMTP connections; the building block used by Nodemailer’s SMTP transport.
mailparser– Streaming parser that converts raw RFC 822 e‑mail into a structured JavaScript object you can easily inspect.
mailcomposer– Utility for generating RFC 822‑compliant message bodies from a JavaScript object. Handy when you need a MIME string but do not want to send it right away.
Related projects​
EmailEngine– Self‑hosted REST interface that exposes any IMAP mailbox over HTTP and sends mail over SMTP. Offers webhook push notifications for real‑time updates.
ImapFlow– Modern Promise‑based IMAP client designed for EmailEngine but fully usable on its own.
mailauth– Validate and generate SPF, DKIM, DMARC, ARC, and BIMI records in Node.js.
email-templates– Framework for creating, previewing (browser/iOS Simulator), and sending custom e‑mail templates.
preview-email– Automatically opens your browser to preview e‑mails generated with Nodemailer during development.
Note:The first four packages are maintained within the Nodemailer GitHub organisation and follow the same release cadence as Nodemailer itself. The rest are separate open‑source projects maintained by the wider community.
Official companion libraries
Related projects



===== https://nodemailer.com/extras#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Extra modules
Beyond Nodemailer itself, a collection of companion libraries can help you receive, compose, parse, and preview e‑mail inside your Node.js applications.
Official companion libraries​
smtp-server– Accept inbound SMTP connections and build a custom SMTP server or test harness.
smtp-connection– Low‑level SMTP client for establishing outbound SMTP connections; the building block used by Nodemailer’s SMTP transport.
mailparser– Streaming parser that converts raw RFC 822 e‑mail into a structured JavaScript object you can easily inspect.
mailcomposer– Utility for generating RFC 822‑compliant message bodies from a JavaScript object. Handy when you need a MIME string but do not want to send it right away.
Related projects​
EmailEngine– Self‑hosted REST interface that exposes any IMAP mailbox over HTTP and sends mail over SMTP. Offers webhook push notifications for real‑time updates.
ImapFlow– Modern Promise‑based IMAP client designed for EmailEngine but fully usable on its own.
mailauth– Validate and generate SPF, DKIM, DMARC, ARC, and BIMI records in Node.js.
email-templates– Framework for creating, previewing (browser/iOS Simulator), and sending custom e‑mail templates.
preview-email– Automatically opens your browser to preview e‑mails generated with Nodemailer during development.
Note:The first four packages are maintained within the Nodemailer GitHub organisation and follow the same release cadence as Nodemailer itself. The rest are separate open‑source projects maintained by the wider community.
Official companion libraries
Related projects



===== https://nodemailer.com/extras/smtp-server =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
SMTP Server
SMTP Server
Create SMTP and LMTP server instances on the fly.smtp‑serverisnota full‑blown server application likeHarakabut a convenient way to add custom SMTP or LMTP listeners to your app. It is the successor of the server part of the now‑deprecatedsimplesmtpmodule. For a matching SMTP client, seesmtp‑connection.
Usage​
1 — Install​
npm install smtp-server --save
npm install smtp-server --save
2 — Require in your script​
const{SMTPServer}=require("smtp-server");
const{SMTPServer}=require("smtp-server");
3 — Create a server instance​
constserver=newSMTPServer(options);
constserver=newSMTPServer(options);
4 — Start listening​
server.listen(port[,host][,callback]);
server.listen(port[,host][,callback]);
5 — Shut down​
server.close(callback);
server.close(callback);
Options reference​
Boolean
false
STARTTLS
false
String
os.hostname()
String
Number
0
0
Boolean
false
stream.sizeExceeded
String[]
['PLAIN', 'LOGIN']
'XOAUTH2'
'CRAM-MD5'
Boolean
false
String[]
['AUTH']
Boolean
false
Boolean
true
ENHANCEDSTATUSCODES
EHLO
Boolean
true
DSN
EHLO
Boolean
false
Boolean
false
Map | Object
Boolean | Object
false
true
console
Number
Infinity
Boolean
false
Boolean
false
Boolean
false
Number
60_000
Number
30_000
close()
Function
Object
.reverse
dns
dns.reverse
You may also pass anynet.createServeroptions and, whensecureistrue, anytls.createServeroptions.
net.createServer
secure
true
tls.createServer
TLS and STARTTLS​
If you enable TLS (secure: true)orleaveSTARTTLSenabled, ship a proper certificate viakey,cert, and optionallyca. Otherwisesmtp‑serverfalls back to a self‑signed cert forlocalhost, which almost every client rejects.
secure: true
STARTTLS
key
cert
ca
localhost
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
Handling errors​
Attach anerrorlistener to surface server errors:
error
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
Handling authentication (onAuth)​
onAuth
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
Password‑based (PLAIN / LOGIN)​
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
OAuth 2 (XOAUTH2)​
XOAUTH2
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
Validating client connection (onConnect/onClose)​
onConnect
onClose
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
Validating TLS information (onSecure)​
onSecure
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
Validating sender (onMailFrom)​
onMailFrom
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
Validating recipients (onRcptTo)​
onRcptTo
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
Processing incoming messages (onData)​
onData
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
smtp‑serverstreams your messageverbatim— noReceived:header is added. Add one yourself if you need full RFC 5321 compliance.
Received:
Using the SIZE extension​
Set thesizeoption to advertise a limit, then checkstream.sizeExceededinonData:
size
stream.sizeExceeded
onData
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
Using LMTP​
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
Session object​
String
String
String
remoteAddress
disableReverseLookup
"HELO" | "EHLO" | "LHLO"
String
Object
mailFrom
rcptTo
dsn
any
onAuth
Number
"SMTP" | "ESMTP" | "ESMTPA" …
Received:
Envelope object​
Thesession.envelopeobject contains transaction-specific data:
session.envelope
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
Object
Object[]
Object
Address object​
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
MAIL FROM:
RCPT TO:
DSN Object Properties​
String
'FULL'
'HDRS'
String
String[]
String
Enhanced Status Codes (RFC 2034/3463)​
smtp‑serversupportsEnhanced Status Codesas defined in RFC 2034 and RFC 3463. When enabled, all SMTP responses include enhanced status codes in the formatX.Y.Z:
X.Y.Z
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
Enabling Enhanced Status Codes​
To enable enhanced status codes (they are disabled by default):
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
Disabling Enhanced Status Codes​
Enhanced status codes are disabled by default, but you can explicitly disable them:
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
Enhanced Status Code Examples​
250
2.0.0
250
2.1.0
250
2.1.5
250
2.6.0
501
5.5.4
550
5.1.1
552
5.2.2
DSN (Delivery Status Notification) Support​
smtp‑serverfully supportsDSN parametersas defined in RFC 3461, allowing clients to request delivery status notifications.
DSN functionality requiresdelivery status notificationsto be enabled. Since delivery status notifications are disabled by default, you must sethideDSN: falseto use DSN features.
hideDSN: false
DSN Parameters​
RET=FULLorRET=HDRS— Return full message or headers only in DSN
RET=FULL
RET=HDRS
ENVID=<envelope-id>— Envelope identifier for tracking
ENVID=<envelope-id>
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER— When to send DSN
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER
ORCPT=<original-recipient>— Original recipient for tracking
ORCPT=<original-recipient>
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
Accessing DSN Parameters​
DSN parameters are available in your callback handlers:
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
DSN Parameter Validation​
smtp‑serverautomatically validates DSN parameters:
RETmust beFULLorHDRS
RET
FULL
HDRS
NOTIFYmust beSUCCESS,FAILURE,DELAY, orNEVER
NOTIFY
SUCCESS
FAILURE
DELAY
NEVER
NOTIFY=NEVERcannot be combined with other values
NOTIFY=NEVER
Invalid parameters return appropriate error responses with enhanced status codes
Complete DSN Example​
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
Production DSN Implementation Example​
Here's a complete example showing how to implement DSN notifications using nodemailer:
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
This example demonstrates:
Complete DSN workflowfrom parameter parsing to notification sending
RFC-compliant DSN messageswith proper headers and content
Conditional notificationsbased on NOTIFY parameters
Integration with nodemailerfor sending DSN notifications
Production-ready structurewith error handling
Supported commands and extensions​
Commands​
EHLO/HELO
EHLO
HELO
AUTHLOGIN·PLAIN·XOAUTH2† ·CRAM‑MD5†
AUTH
LOGIN
PLAIN
XOAUTH2
CRAM‑MD5
MAIL/RCPT/DATA
MAIL
RCPT
DATA
RSET/NOOP/QUIT/VRFY
RSET
NOOP
QUIT
VRFY
HELP(returns RFC 5321 URL)
HELP
STARTTLS
STARTTLS
†XOAUTH2andCRAM‑MD5must be enabled viaauthMethods.
XOAUTH2
CRAM‑MD5
authMethods
Extensions​
PIPELINING
PIPELINING
8BITMIME
8BITMIME
SMTPUTF8
SMTPUTF8
SIZE
SIZE
DSN(RFC 3461)
DSN
ENHANCEDSTATUSCODES(RFC 2034/3463)
ENHANCEDSTATUSCODES
TheCHUNKINGextension isnotimplemented.
CHUNKING
License​
MIT
Usage1 — Install2 — Require in your script3 — Create a server instance4 — Start listening5 — Shut down
1 — Install
2 — Require in your script
3 — Create a server instance
4 — Start listening
5 — Shut down
Options reference
TLS and STARTTLS
Handling errors
Handling authentication (onAuth)Password‑based (PLAIN / LOGIN)OAuth 2 (XOAUTH2)
onAuth
Password‑based (PLAIN / LOGIN)
OAuth 2 (XOAUTH2)
XOAUTH2
Validating client connection (onConnect/onClose)
onConnect
onClose
Validating TLS information (onSecure)
onSecure
Validating sender (onMailFrom)
onMailFrom
Validating recipients (onRcptTo)
onRcptTo
Processing incoming messages (onData)
onData
Using the SIZE extension
Using LMTP
Session object
Envelope object
Address objectDSN Object Properties
DSN Object Properties
Enhanced Status Codes (RFC 2034/3463)Enabling Enhanced Status CodesDisabling Enhanced Status CodesEnhanced Status Code Examples
Enabling Enhanced Status Codes
Disabling Enhanced Status Codes
Enhanced Status Code Examples
DSN (Delivery Status Notification) SupportDSN ParametersAccessing DSN ParametersDSN Parameter ValidationComplete DSN ExampleProduction DSN Implementation Example
DSN Parameters
Accessing DSN Parameters
DSN Parameter Validation
Complete DSN Example
Production DSN Implementation Example
Supported commands and extensionsCommandsExtensions
Commands
Extensions
License



===== https://nodemailer.com/extras/smtp-server#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
SMTP Server
SMTP Server
Create SMTP and LMTP server instances on the fly.smtp‑serverisnota full‑blown server application likeHarakabut a convenient way to add custom SMTP or LMTP listeners to your app. It is the successor of the server part of the now‑deprecatedsimplesmtpmodule. For a matching SMTP client, seesmtp‑connection.
Usage​
1 — Install​
npm install smtp-server --save
npm install smtp-server --save
2 — Require in your script​
const{SMTPServer}=require("smtp-server");
const{SMTPServer}=require("smtp-server");
3 — Create a server instance​
constserver=newSMTPServer(options);
constserver=newSMTPServer(options);
4 — Start listening​
server.listen(port[,host][,callback]);
server.listen(port[,host][,callback]);
5 — Shut down​
server.close(callback);
server.close(callback);
Options reference​
Boolean
false
STARTTLS
false
String
os.hostname()
String
Number
0
0
Boolean
false
stream.sizeExceeded
String[]
['PLAIN', 'LOGIN']
'XOAUTH2'
'CRAM-MD5'
Boolean
false
String[]
['AUTH']
Boolean
false
Boolean
true
ENHANCEDSTATUSCODES
EHLO
Boolean
true
DSN
EHLO
Boolean
false
Boolean
false
Map | Object
Boolean | Object
false
true
console
Number
Infinity
Boolean
false
Boolean
false
Boolean
false
Number
60_000
Number
30_000
close()
Function
Object
.reverse
dns
dns.reverse
You may also pass anynet.createServeroptions and, whensecureistrue, anytls.createServeroptions.
net.createServer
secure
true
tls.createServer
TLS and STARTTLS​
If you enable TLS (secure: true)orleaveSTARTTLSenabled, ship a proper certificate viakey,cert, and optionallyca. Otherwisesmtp‑serverfalls back to a self‑signed cert forlocalhost, which almost every client rejects.
secure: true
STARTTLS
key
cert
ca
localhost
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
Handling errors​
Attach anerrorlistener to surface server errors:
error
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
Handling authentication (onAuth)​
onAuth
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
Password‑based (PLAIN / LOGIN)​
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
OAuth 2 (XOAUTH2)​
XOAUTH2
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
Validating client connection (onConnect/onClose)​
onConnect
onClose
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
Validating TLS information (onSecure)​
onSecure
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
Validating sender (onMailFrom)​
onMailFrom
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
Validating recipients (onRcptTo)​
onRcptTo
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
Processing incoming messages (onData)​
onData
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
smtp‑serverstreams your messageverbatim— noReceived:header is added. Add one yourself if you need full RFC 5321 compliance.
Received:
Using the SIZE extension​
Set thesizeoption to advertise a limit, then checkstream.sizeExceededinonData:
size
stream.sizeExceeded
onData
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
Using LMTP​
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
Session object​
String
String
String
remoteAddress
disableReverseLookup
"HELO" | "EHLO" | "LHLO"
String
Object
mailFrom
rcptTo
dsn
any
onAuth
Number
"SMTP" | "ESMTP" | "ESMTPA" …
Received:
Envelope object​
Thesession.envelopeobject contains transaction-specific data:
session.envelope
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
Object
Object[]
Object
Address object​
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
MAIL FROM:
RCPT TO:
DSN Object Properties​
String
'FULL'
'HDRS'
String
String[]
String
Enhanced Status Codes (RFC 2034/3463)​
smtp‑serversupportsEnhanced Status Codesas defined in RFC 2034 and RFC 3463. When enabled, all SMTP responses include enhanced status codes in the formatX.Y.Z:
X.Y.Z
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
Enabling Enhanced Status Codes​
To enable enhanced status codes (they are disabled by default):
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
Disabling Enhanced Status Codes​
Enhanced status codes are disabled by default, but you can explicitly disable them:
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
Enhanced Status Code Examples​
250
2.0.0
250
2.1.0
250
2.1.5
250
2.6.0
501
5.5.4
550
5.1.1
552
5.2.2
DSN (Delivery Status Notification) Support​
smtp‑serverfully supportsDSN parametersas defined in RFC 3461, allowing clients to request delivery status notifications.
DSN functionality requiresdelivery status notificationsto be enabled. Since delivery status notifications are disabled by default, you must sethideDSN: falseto use DSN features.
hideDSN: false
DSN Parameters​
RET=FULLorRET=HDRS— Return full message or headers only in DSN
RET=FULL
RET=HDRS
ENVID=<envelope-id>— Envelope identifier for tracking
ENVID=<envelope-id>
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER— When to send DSN
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER
ORCPT=<original-recipient>— Original recipient for tracking
ORCPT=<original-recipient>
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
Accessing DSN Parameters​
DSN parameters are available in your callback handlers:
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
DSN Parameter Validation​
smtp‑serverautomatically validates DSN parameters:
RETmust beFULLorHDRS
RET
FULL
HDRS
NOTIFYmust beSUCCESS,FAILURE,DELAY, orNEVER
NOTIFY
SUCCESS
FAILURE
DELAY
NEVER
NOTIFY=NEVERcannot be combined with other values
NOTIFY=NEVER
Invalid parameters return appropriate error responses with enhanced status codes
Complete DSN Example​
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
Production DSN Implementation Example​
Here's a complete example showing how to implement DSN notifications using nodemailer:
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
This example demonstrates:
Complete DSN workflowfrom parameter parsing to notification sending
RFC-compliant DSN messageswith proper headers and content
Conditional notificationsbased on NOTIFY parameters
Integration with nodemailerfor sending DSN notifications
Production-ready structurewith error handling
Supported commands and extensions​
Commands​
EHLO/HELO
EHLO
HELO
AUTHLOGIN·PLAIN·XOAUTH2† ·CRAM‑MD5†
AUTH
LOGIN
PLAIN
XOAUTH2
CRAM‑MD5
MAIL/RCPT/DATA
MAIL
RCPT
DATA
RSET/NOOP/QUIT/VRFY
RSET
NOOP
QUIT
VRFY
HELP(returns RFC 5321 URL)
HELP
STARTTLS
STARTTLS
†XOAUTH2andCRAM‑MD5must be enabled viaauthMethods.
XOAUTH2
CRAM‑MD5
authMethods
Extensions​
PIPELINING
PIPELINING
8BITMIME
8BITMIME
SMTPUTF8
SMTPUTF8
SIZE
SIZE
DSN(RFC 3461)
DSN
ENHANCEDSTATUSCODES(RFC 2034/3463)
ENHANCEDSTATUSCODES
TheCHUNKINGextension isnotimplemented.
CHUNKING
License​
MIT
Usage1 — Install2 — Require in your script3 — Create a server instance4 — Start listening5 — Shut down
1 — Install
2 — Require in your script
3 — Create a server instance
4 — Start listening
5 — Shut down
Options reference
TLS and STARTTLS
Handling errors
Handling authentication (onAuth)Password‑based (PLAIN / LOGIN)OAuth 2 (XOAUTH2)
onAuth
Password‑based (PLAIN / LOGIN)
OAuth 2 (XOAUTH2)
XOAUTH2
Validating client connection (onConnect/onClose)
onConnect
onClose
Validating TLS information (onSecure)
onSecure
Validating sender (onMailFrom)
onMailFrom
Validating recipients (onRcptTo)
onRcptTo
Processing incoming messages (onData)
onData
Using the SIZE extension
Using LMTP
Session object
Envelope object
Address objectDSN Object Properties
DSN Object Properties
Enhanced Status Codes (RFC 2034/3463)Enabling Enhanced Status CodesDisabling Enhanced Status CodesEnhanced Status Code Examples
Enabling Enhanced Status Codes
Disabling Enhanced Status Codes
Enhanced Status Code Examples
DSN (Delivery Status Notification) SupportDSN ParametersAccessing DSN ParametersDSN Parameter ValidationComplete DSN ExampleProduction DSN Implementation Example
DSN Parameters
Accessing DSN Parameters
DSN Parameter Validation
Complete DSN Example
Production DSN Implementation Example
Supported commands and extensionsCommandsExtensions
Commands
Extensions
License



===== https://nodemailer.com/extras/mailparser =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/mailparser#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/mailcomposer =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/smtp-connection =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Testing SMTP
Testing SMTP
When you need to exercise the email‑sending paths of your application in a development or continuous‑integration environment, youmust notaccidentally spam real inboxes. Instead of routing all mail to a single hard‑coded test address, point your code at amail‑catcherservice: it accepts messages over SMTP exactly like a production provider, butneverdelivers them. It just stores the messages so that you can open or download them later.
Nodemailer ships with first‑class support forEthereal Email– a free, open‑source mail‑catcher designed for test environments. You can either
provision an account on the flywithcreateTestAccount, or
createTestAccount
create a persistent test mailboxfrom the Ethereal dashboard.
If you would rather stay completely offline you can preview messages locally withforwardemail/email‑templates(it renders every message in your browser and iOS simulator viapreview-email).
Quick‑start​
Install Nodemailer if you have not done so yet:
npm install nodemailer
npm install nodemailer
1. Spin up a throw‑away Ethereal account​
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
Ethereal automatically deletes an account after48 hours of inactivity. Save the generated credentials somewhere if you want to inspect the messages later via the dashboard.
2. Switch transports per environment​
You only need one place in your code base that knows which SMTP credentials to use. Everything else just callscreateTransport().
createTransport()
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
Your application code can treat the transporter as a black box:
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
3. Inspect the message​
WhensendMailresolves (or its callback fires), the returnedinfoobject contains everything you need to locate the message inside Ethereal:
sendMail
info
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
You can also openMessages → Inboxin Ethereal’s dashboard and browse around.
Below is what a captured message looks like in the Ethereal UI.
Quick‑start1. Spin up a throw‑away Ethereal account2. Switch transports per environment3. Inspect the message
1. Spin up a throw‑away Ethereal account
2. Switch transports per environment
3. Inspect the message



===== https://nodemailer.com/extras/smtp-connection#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Testing SMTP
Testing SMTP
When you need to exercise the email‑sending paths of your application in a development or continuous‑integration environment, youmust notaccidentally spam real inboxes. Instead of routing all mail to a single hard‑coded test address, point your code at amail‑catcherservice: it accepts messages over SMTP exactly like a production provider, butneverdelivers them. It just stores the messages so that you can open or download them later.
Nodemailer ships with first‑class support forEthereal Email– a free, open‑source mail‑catcher designed for test environments. You can either
provision an account on the flywithcreateTestAccount, or
createTestAccount
create a persistent test mailboxfrom the Ethereal dashboard.
If you would rather stay completely offline you can preview messages locally withforwardemail/email‑templates(it renders every message in your browser and iOS simulator viapreview-email).
Quick‑start​
Install Nodemailer if you have not done so yet:
npm install nodemailer
npm install nodemailer
1. Spin up a throw‑away Ethereal account​
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
Ethereal automatically deletes an account after48 hours of inactivity. Save the generated credentials somewhere if you want to inspect the messages later via the dashboard.
2. Switch transports per environment​
You only need one place in your code base that knows which SMTP credentials to use. Everything else just callscreateTransport().
createTransport()
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
Your application code can treat the transporter as a black box:
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
3. Inspect the message​
WhensendMailresolves (or its callback fires), the returnedinfoobject contains everything you need to locate the message inside Ethereal:
sendMail
info
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
You can also openMessages → Inboxin Ethereal’s dashboard and browse around.
Below is what a captured message looks like in the Ethereal UI.
Quick‑start1. Spin up a throw‑away Ethereal account2. Switch transports per environment3. Inspect the message
1. Spin up a throw‑away Ethereal account
2. Switch transports per environment
3. Inspect the message



===== https://nodemailer.com/license =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
License
License
Nodemailer is licensed under the"MIT No Attribution"(MIT-0) License
Version 3 of Nodemailer was licensed under theEuropean Union Public License 1.1 (EUPL), which is acopyleftlicense. For more details on the decision to use EUPL for Nodemailer v3, you can refer to theNodemailer blog. However, after a two-month experiment, I decided to revert Nodemailer back to the MIT license and canceled all active subscriptions.
Using a restrictive license for a lower-level infrastructure module like Nodemailer proved to be more problematic than beneficial. Even I had to use older versions of Nodemailer to avoid licensing issues for client work. Additionally, there wasn’t a significant interest in paid subscriptions or services, and most users continued using the copyleft-licensed Nodemailer in their commercial projects, with little concern for the licensing terms. Without a feasible way to enforce the copyleft license, the decision was made to return to the more permissive MIT license.
Support Nodemailer​
If you appreciate Nodemailer or if your business profits from its use, I would greatly appreciate any support. You can donate via Bitcoin or PayPal, or become a sponsor on GitHub.
Nodemailer Bitcoin wallet:15Z8ADxhssKUiwP3jbbqJwA21744KMCfTM
15Z8ADxhssKUiwP3jbbqJwA21744KMCfTM
Donate via PayPal
Become a sponsor onGitHub
Support Nodemailer



===== https://nodemailer.com/license#__docusaurus_skipToContent_fallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
License
License
Nodemailer is licensed under the"MIT No Attribution"(MIT-0) License
Version 3 of Nodemailer was licensed under theEuropean Union Public License 1.1 (EUPL), which is acopyleftlicense. For more details on the decision to use EUPL for Nodemailer v3, you can refer to theNodemailer blog. However, after a two-month experiment, I decided to revert Nodemailer back to the MIT license and canceled all active subscriptions.
Using a restrictive license for a lower-level infrastructure module like Nodemailer proved to be more problematic than beneficial. Even I had to use older versions of Nodemailer to avoid licensing issues for client work. Additionally, there wasn’t a significant interest in paid subscriptions or services, and most users continued using the copyleft-licensed Nodemailer in their commercial projects, with little concern for the licensing terms. Without a feasible way to enforce the copyleft license, the decision was made to return to the more permissive MIT license.
Support Nodemailer​
If you appreciate Nodemailer or if your business profits from its use, I would greatly appreciate any support. You can donate via Bitcoin or PayPal, or become a sponsor on GitHub.
Nodemailer Bitcoin wallet:15Z8ADxhssKUiwP3jbbqJwA21744KMCfTM
15Z8ADxhssKUiwP3jbbqJwA21744KMCfTM
Donate via PayPal
Become a sponsor onGitHub
Support Nodemailer



===== https://nodemailer.com/license#support-nodemailer =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modules
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
License
License
Nodemailer is licensed under the"MIT No Attribution"(MIT-0) License
Version 3 of Nodemailer was licensed under theEuropean Union Public License 1.1 (EUPL), which is acopyleftlicense. For more details on the decision to use EUPL for Nodemailer v3, you can refer to theNodemailer blog. However, after a two-month experiment, I decided to revert Nodemailer back to the MIT license and canceled all active subscriptions.
Using a restrictive license for a lower-level infrastructure module like Nodemailer proved to be more problematic than beneficial. Even I had to use older versions of Nodemailer to avoid licensing issues for client work. Additionally, there wasn’t a significant interest in paid subscriptions or services, and most users continued using the copyleft-licensed Nodemailer in their commercial projects, with little concern for the licensing terms. Without a feasible way to enforce the copyleft license, the decision was made to return to the more permissive MIT license.
Support Nodemailer​
If you appreciate Nodemailer or if your business profits from its use, I would greatly appreciate any support. You can donate via Bitcoin or PayPal, or become a sponsor on GitHub.
Nodemailer Bitcoin wallet:15Z8ADxhssKUiwP3jbbqJwA21744KMCfTM
15Z8ADxhssKUiwP3jbbqJwA21744KMCfTM
Donate via PayPal
Become a sponsor onGitHub
Support Nodemailer



===== https://nodemailer.com/extras/smtp-connection#quickstart =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Testing SMTP
Testing SMTP
When you need to exercise the email‑sending paths of your application in a development or continuous‑integration environment, youmust notaccidentally spam real inboxes. Instead of routing all mail to a single hard‑coded test address, point your code at amail‑catcherservice: it accepts messages over SMTP exactly like a production provider, butneverdelivers them. It just stores the messages so that you can open or download them later.
Nodemailer ships with first‑class support forEthereal Email– a free, open‑source mail‑catcher designed for test environments. You can either
provision an account on the flywithcreateTestAccount, or
createTestAccount
create a persistent test mailboxfrom the Ethereal dashboard.
If you would rather stay completely offline you can preview messages locally withforwardemail/email‑templates(it renders every message in your browser and iOS simulator viapreview-email).
Quick‑start​
Install Nodemailer if you have not done so yet:
npm install nodemailer
npm install nodemailer
1. Spin up a throw‑away Ethereal account​
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
Ethereal automatically deletes an account after48 hours of inactivity. Save the generated credentials somewhere if you want to inspect the messages later via the dashboard.
2. Switch transports per environment​
You only need one place in your code base that knows which SMTP credentials to use. Everything else just callscreateTransport().
createTransport()
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
Your application code can treat the transporter as a black box:
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
3. Inspect the message​
WhensendMailresolves (or its callback fires), the returnedinfoobject contains everything you need to locate the message inside Ethereal:
sendMail
info
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
You can also openMessages → Inboxin Ethereal’s dashboard and browse around.
Below is what a captured message looks like in the Ethereal UI.
Quick‑start1. Spin up a throw‑away Ethereal account2. Switch transports per environment3. Inspect the message
1. Spin up a throw‑away Ethereal account
2. Switch transports per environment
3. Inspect the message



===== https://nodemailer.com/extras/smtp-connection#1-spin-up-a-throwaway-ethereal-account =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Testing SMTP
Testing SMTP
When you need to exercise the email‑sending paths of your application in a development or continuous‑integration environment, youmust notaccidentally spam real inboxes. Instead of routing all mail to a single hard‑coded test address, point your code at amail‑catcherservice: it accepts messages over SMTP exactly like a production provider, butneverdelivers them. It just stores the messages so that you can open or download them later.
Nodemailer ships with first‑class support forEthereal Email– a free, open‑source mail‑catcher designed for test environments. You can either
provision an account on the flywithcreateTestAccount, or
createTestAccount
create a persistent test mailboxfrom the Ethereal dashboard.
If you would rather stay completely offline you can preview messages locally withforwardemail/email‑templates(it renders every message in your browser and iOS simulator viapreview-email).
Quick‑start​
Install Nodemailer if you have not done so yet:
npm install nodemailer
npm install nodemailer
1. Spin up a throw‑away Ethereal account​
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
Ethereal automatically deletes an account after48 hours of inactivity. Save the generated credentials somewhere if you want to inspect the messages later via the dashboard.
2. Switch transports per environment​
You only need one place in your code base that knows which SMTP credentials to use. Everything else just callscreateTransport().
createTransport()
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
Your application code can treat the transporter as a black box:
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
3. Inspect the message​
WhensendMailresolves (or its callback fires), the returnedinfoobject contains everything you need to locate the message inside Ethereal:
sendMail
info
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
You can also openMessages → Inboxin Ethereal’s dashboard and browse around.
Below is what a captured message looks like in the Ethereal UI.
Quick‑start1. Spin up a throw‑away Ethereal account2. Switch transports per environment3. Inspect the message
1. Spin up a throw‑away Ethereal account
2. Switch transports per environment
3. Inspect the message



===== https://nodemailer.com/extras/smtp-connection#2-switch-transports-per-environment =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Testing SMTP
Testing SMTP
When you need to exercise the email‑sending paths of your application in a development or continuous‑integration environment, youmust notaccidentally spam real inboxes. Instead of routing all mail to a single hard‑coded test address, point your code at amail‑catcherservice: it accepts messages over SMTP exactly like a production provider, butneverdelivers them. It just stores the messages so that you can open or download them later.
Nodemailer ships with first‑class support forEthereal Email– a free, open‑source mail‑catcher designed for test environments. You can either
provision an account on the flywithcreateTestAccount, or
createTestAccount
create a persistent test mailboxfrom the Ethereal dashboard.
If you would rather stay completely offline you can preview messages locally withforwardemail/email‑templates(it renders every message in your browser and iOS simulator viapreview-email).
Quick‑start​
Install Nodemailer if you have not done so yet:
npm install nodemailer
npm install nodemailer
1. Spin up a throw‑away Ethereal account​
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
Ethereal automatically deletes an account after48 hours of inactivity. Save the generated credentials somewhere if you want to inspect the messages later via the dashboard.
2. Switch transports per environment​
You only need one place in your code base that knows which SMTP credentials to use. Everything else just callscreateTransport().
createTransport()
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
Your application code can treat the transporter as a black box:
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
3. Inspect the message​
WhensendMailresolves (or its callback fires), the returnedinfoobject contains everything you need to locate the message inside Ethereal:
sendMail
info
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
You can also openMessages → Inboxin Ethereal’s dashboard and browse around.
Below is what a captured message looks like in the Ethereal UI.
Quick‑start1. Spin up a throw‑away Ethereal account2. Switch transports per environment3. Inspect the message
1. Spin up a throw‑away Ethereal account
2. Switch transports per environment
3. Inspect the message



===== https://nodemailer.com/extras/smtp-connection#3-inspect-the-message =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Testing SMTP
Testing SMTP
When you need to exercise the email‑sending paths of your application in a development or continuous‑integration environment, youmust notaccidentally spam real inboxes. Instead of routing all mail to a single hard‑coded test address, point your code at amail‑catcherservice: it accepts messages over SMTP exactly like a production provider, butneverdelivers them. It just stores the messages so that you can open or download them later.
Nodemailer ships with first‑class support forEthereal Email– a free, open‑source mail‑catcher designed for test environments. You can either
provision an account on the flywithcreateTestAccount, or
createTestAccount
create a persistent test mailboxfrom the Ethereal dashboard.
If you would rather stay completely offline you can preview messages locally withforwardemail/email‑templates(it renders every message in your browser and iOS simulator viapreview-email).
Quick‑start​
Install Nodemailer if you have not done so yet:
npm install nodemailer
npm install nodemailer
1. Spin up a throw‑away Ethereal account​
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
// ./mail.jsconstnodemailer=require("nodemailer");nodemailer.createTestAccount((err,account)=>{if(err){console.error("Failed to create a testing account. "+err.message);return;}// 1️⃣  Configure a transporter that talks to Etherealconsttransporter=nodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,// upgrade later with STARTTLSauth:{user:account.user,// generated userpass:account.pass,// generated password},});// 2️⃣  Send a messagetransporter.sendMail({from:"Example app <no-reply@example.com>",to:"user@example.com",subject:"Hello from tests ✔",text:"This message was sent from a Node.js integration test.",}).then((info)=>{console.log("Message sent: %s",info.messageId);// Preview the stored message in Ethereal’s web UIconsole.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));}).catch(console.error);});
Ethereal automatically deletes an account after48 hours of inactivity. Save the generated credentials somewhere if you want to inspect the messages later via the dashboard.
2. Switch transports per environment​
You only need one place in your code base that knows which SMTP credentials to use. Everything else just callscreateTransport().
createTransport()
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
// ./mail‑transport.jsconstnodemailer=require("nodemailer");functioncreateTransport(){if(process.env.NODE_ENV==="production"){// 🚀  Real emailsreturnnodemailer.createTransport({host:"smtp.sendgrid.net",port:587,secure:false,auth:{user:process.env.SMTP_USERNAME,pass:process.env.SMTP_PASSWORD,},});}// 🧪  Captured by Etherealreturnnodemailer.createTransport({host:"smtp.ethereal.email",port:587,secure:false,auth:{user:process.env.ETHEREAL_USERNAME,pass:process.env.ETHEREAL_PASSWORD,},});}module.exports=createTransport;
Your application code can treat the transporter as a black box:
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
constcreateTransport=require('./mail-transport');consttransporter=createTransport();awaittransporter.sendMail({...});
3. Inspect the message​
WhensendMailresolves (or its callback fires), the returnedinfoobject contains everything you need to locate the message inside Ethereal:
sendMail
info
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
constinfo=awaittransporter.sendMail(message);console.log("Preview URL: %s",nodemailer.getTestMessageUrl(info));// → https://ethereal.email/message/WaQKMgKddxQDoou
You can also openMessages → Inboxin Ethereal’s dashboard and browse around.
Below is what a captured message looks like in the Ethereal UI.
Quick‑start1. Spin up a throw‑away Ethereal account2. Switch transports per environment3. Inspect the message
1. Spin up a throw‑away Ethereal account
2. Switch transports per environment
3. Inspect the message



===== https://nodemailer.com/extras/mailcomposer#usage =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#1install-nodemailer =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#2require-mailcomposer-in-your-code =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#3create-a-mailcomposer-instance =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#api =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#createreadstream =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#buildcallback =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#message-fields =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#address-formatting =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#bcc =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#attachments =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#alternatives =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#smtp-envelope =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#example =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#using-embedded-images =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailcomposer#license =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
Mailcomposer
Mailcomposer
Generate RFC 822–formatted email messages that you can stream directly to an SMTP connection or save to disk.
Mailcomposer is shipped with Nodemailer – you donothave to install anything else.
Usage​
1 · Install Nodemailer​
npm install nodemailer
npm install nodemailer
2 · Requiremailcomposerin your code​
constMailComposer=require("nodemailer/lib/mail-composer");
constMailComposer=require("nodemailer/lib/mail-composer");
3 · Create aMailComposerinstance​
constmail=newMailComposer(mailOptions);
constmail=newMailComposer(mailOptions);
mailOptionsis an object that describes your message. See the full option reference below.
mailOptions
API​
createReadStream()​
createReadStream()
Create a readable stream that emits the raw RFC 822 message:
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
constmail=newMailComposer({from:"you@example.com"/* … */});conststream=mail.compile().createReadStream();stream.pipe(process.stdout);
build(callback)​
build(callback)
Generate the message and receive it as aBufferin a callback:
Buffer
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({from:"you@example.com"/* … */});mail.compile().build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
Message fields​
'sender@server.com'
'Sender Name <sender@server.com>'
Message‑ID
Message‑ID
string
Buffer
Stream
{ path: '…' }
text/html
{ method: 'REQUEST', content: icsString }
PUBLISH
{ 'X-Key': 'value' }
[{ key: 'X-Key', value: 'v1' }]
multipart/alternative
Message‑ID
Date
quoted‑printable
base64
true
true
\r\n
\n
All textual content is treated as UTF‑8. Attachments are streamed as binary.
Attachments​
Attachment objects support the following properties:
false
cid:
contentDisposition: 'inline'
multipart/related
string
Buffer
Stream
content
Buffer
base64
hex
quoted-printable
base64
attachment
inline
{ 'X-My-Header': 'value' }
string
Buffer
Stream
Example​
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
constfs=require("fs");constmailOptions={/* …other fields… */attachments:[// UTF‑8 string{filename:"hello.txt",content:"hello world!"},// Binary Buffer{filename:"buffer.txt",content:Buffer.from("hello world!","utf‑8")},// File on disk (streams the file){filename:"file.txt",path:"/path/to/file.txt"},// Derive filename & contentType from path{path:"/path/to/logo.png"},// Readable stream{filename:"stream.txt",content:fs.createReadStream("file.txt")},// Custom content type{filename:"data.bin",content:"hello world!",contentType:"application/octet-stream"},// Remote URL{filename:"license.txt",path:"https://raw.githubusercontent.com/nodemailer/nodemailer/master/LICENSE"},// Base64‑encoded string{filename:"base64.txt",content:"aGVsbG8gd29ybGQh",encoding:"base64"},// Data URI{path:"data:text/plain;base64,aGVsbG8gd29ybGQ="},],};
Alternatives​
Besidestextandhtml, you can include any data as analternativepart – for example, a Markdown or OpenDocument version of the same content. The email client picks the best‑suited alternative to display. Calendar events are commonly attached this way.
Alternative objects use thesame optionsasattachments, but are placed into themultipart/alternativesection of the message instead ofmultipart/mixed/multipart/related.
multipart/alternative
multipart/mixed
multipart/related
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
constmailOptions={html:"<b>Hello world!</b>",alternatives:[{contentType:"text/x-web-markdown",content:"**Hello world!**",},],};
Address formatting​
You can supply addresses in any of the following forms:
recipient@example.com"Display Name" <recipient@example.com>
recipient@example.com"Display Name" <recipient@example.com>
Or as an object (no need to quote anything):
{name:'Display Name',address:'recipient@example.com'}
{name:'Display Name',address:'recipient@example.com'}
Every address field – evenfrom– acceptsone or manyaddresses, in any mix of formats:
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
{to:'user1@example.com, "User Two" <user2@example.com>',cc:['user3@example.com','"User Four" <user4@example.com>',{name:'User Five',address:'user5@example.com'}]}
Internationalized domain names (IDN) are automatically converted to punycode:
"Unicode Domain" <info@müriaad-polüteism.info>
"Unicode Domain" <info@müriaad-polüteism.info>
SMTP envelope​
By default the SMTP envelope is generated from the address headers. If you need something different – for example, VERP or black‑holefrom– you can setenvelopeexplicitly:
from
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
constmailOptions={from:"mailer@example.com",to:"daemon@example.com",envelope:{from:"Daemon <daemon@example.com>",to:'mailer@example.com, "Mailer Two" <mailer2@example.com>',},};
Some transports (e.g. AWS SES) ignoreenvelopeand instead use the header addresses.
envelope
Using embedded images​
Setcidon an attachment and reference it in the HTML with thecid:protocol:
cid
cid:
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
constmailOptions={html:'Embedded image: <img src="cid:unique@nodemailer" />',attachments:[{filename:"image.png",path:"/path/to/image.png",cid:"unique@nodemailer",// must match the src above},],};
BCC​
MailComposer removes theBcc:header by default to keep recipient addresses private. If you need the header to remain, enablekeepBccaftercallingcompile():
keepBcc
compile()
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
constmail=newMailComposer({/* … */bcc:"bcc@example.com",}).compile();mail.keepBcc=true;mail.build((err,message)=>{if(err)throwerr;process.stdout.write(message);});
License​
MIT
Usage1 · Install Nodemailer2 · Requiremailcomposerin your code3 · Create aMailComposerinstance
1 · Install Nodemailer
2 · Requiremailcomposerin your code
3 · Create aMailComposerinstance
APIcreateReadStream()build(callback)
createReadStream()
createReadStream()
build(callback)
build(callback)
Message fields
AttachmentsExample
Example
Alternatives
Address formatting
SMTP envelope
Using embedded images
BCC
License



===== https://nodemailer.com/extras/mailparser#installation =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/mailparser#simpleparser =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/mailparser#parameters =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/mailparser#options =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/mailparser#returned-mail-object =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/mailparser#address-object =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/mailparser#headersmap-quirks =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/mailparser#attachment-object-simpleparser =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/mailparser#mailparser-stream-api =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/mailparser#attachment-stream-object-type--attachment =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/mailparser#character-set-decoding =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/mailparser#license =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
MailParser
MailParser
Streaming e‑mail parser for Node.js that can handle very large messages with minimal memory overhead.
MailParser offers two ways to consume a message:
simpleParser– convenience helper that buffers the whole message (including attachments) in memory and returns a singlemail object. Great for simple use‑cases and tests.
simpleParser
MailParserclass– a lower‑levelTransformstream that emits message parts and attachmentstreamsas they become available, letting you process huge messages without blowing up memory.
MailParser
Transform
Installation​
npm install mailparser
npm install mailparser
simpleParser()​
simpleParser()
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
const{simpleParser}=require("mailparser");// Callback stylesimpleParser(source,options,(err,mail)=>{if(err)throwerr;console.log(mail.subject);});// Promise stylesimpleParser(source,options).then((mail)=>console.log(mail.subject)).catch(console.error);// async/awaitconstmail=awaitsimpleParser(source,options);
Parameters​
source– aBuffer,String, orreadable streamcontaining the RFC 822 message.
source
Buffer
String
options– optional configuration (seeOptions).
options
Returnedmail object​
The resolvedmailobject aggregates every piece of the message:
mail
headers
Map
subject
String
headers.get('subject')
from
to
cc
bcc
reply-to
date
Date
messageId
String
inReplyTo
String
references
String[] | String
html
text
textAsHtml
text
attachments
Attachment[]
No sanitisation is performed. If you displayhtml, make sure to run it through a trusted HTML‑sanitiser first.
html
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
{"value":[{"name":"Jane Doe","address":"jane@example.com"}],"html":"<span class=\"mp_address_name\">Jane Doe</span> &lt;<a href=\"mailto:jane@example.com\" class=\"mp_address_email\">jane@example.com</a>&gt;","text":"Jane Doe <jane@example.com>"}
value– array of individual addresses (or groups)
value
text– formatted for plaintext context
text
html– formatted for HTML context
html
For a deep dive into address objects see theMessage → Addressessection.
headers
Most headers resolve tostrings(single header) orstring[](multiple occurrences). The following are parsed into richer structures for convenience:
Address headers→ address objects (from,to,cc,bcc,sender,reply-to,delivered-to,return-path).
from
to
cc
bcc
sender
reply-to
delivered-to
return-path
Priority headers(x-priority,importance, …) are normalised to a singleprioritykey with values"high" | "normal" | "low".
x-priority
importance
priority
"high" | "normal" | "low"
references→String|String[].
references
String
String[]
date→Date.
date
Date
Structured headers(content-type,content-disposition,dkim-signature) →{ value: String, params: Object }.
content-type
content-disposition
dkim-signature
{ value: String, params: Object }
Attachment object (simpleParser)​
filename
undefined
contentType
contentDisposition
"attachment"
checksum
content
size
headers
Map
content
Buffer
contentId
cid
related
true
MailParser(stream API)​
MailParser
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
const{MailParser}=require("mailparser");constparser=newMailParser(options);sourceStream.pipe(parser);
MailParseris aTransformstream inobject modethat emits two kinds of objects via the'data'event:
MailParser
Transform
'data'
{ type: 'headers', headers: Map }– once, after the headers are parsed.
{ type: 'headers', headers: Map }
{ type: 'attachment', ... }– for every attachment (see below).
Thecontentproperty is aReadable stream.
{ type: 'attachment', ... }
content
{ type: 'text', html, text, textAsHtml }– once, containing the message bodies.
{ type: 'text', html, text, textAsHtml }
Stream options​
skipHtmlToText
false
text
maxHtmlLengthToParse
Infinity
formatDateString
undefined
skipImageLinks
false
skipTextToHtml
false
textAsHtml
skipTextLinks
false
text
keepDeliveryStatus
false
message/delivery-status
Iconv
iconv-lite
keepCidLinks
false
skipImageLinks: true
Attachment stream object (type === 'attachment')​
type === 'attachment'
Identical shape to the buffered object shown earlier, except:
contentis aReadable stream.
content
Youmustcallattachment.release()when you are done. Parsing pauses until every attachment is released.
attachment.release()
relatedis only availableafterparsing ends.
related
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
parser.on("data",(part)=>{if(part.type==="attachment"){console.log("Attachment:",part.filename);part.content.pipe(fs.createWriteStream(part.filename)).on("finish",part.release);}});
Character set decoding​
MailParser relies oniconv‑litefor charset conversion, except forISO‑2022‑JPandEUC‑JPwhich are handled byencoding‑japanese.
If you prefernode-iconv, inject it:
node-iconv
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
const{Iconv}=require('iconv');const{simpleParser}=require('mailparser');simpleParser(rfc822Message,{Iconv}).then(mail=>/* … */);
License​
Dual‑licensed under theMIT LicenseorEUPL v1.1 +.
Installation
simpleParser()ParametersReturnedmail objectAttachment object (simpleParser)
simpleParser()
Parameters
Returnedmail object
Attachment object (simpleParser)
MailParser(stream API)Stream optionsAttachment stream object (type === 'attachment')
MailParser
Stream options
Attachment stream object (type === 'attachment')
type === 'attachment'
Character set decoding
License



===== https://nodemailer.com/extras/smtp-server#usage =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
SMTP Server
SMTP Server
Create SMTP and LMTP server instances on the fly.smtp‑serverisnota full‑blown server application likeHarakabut a convenient way to add custom SMTP or LMTP listeners to your app. It is the successor of the server part of the now‑deprecatedsimplesmtpmodule. For a matching SMTP client, seesmtp‑connection.
Usage​
1 — Install​
npm install smtp-server --save
npm install smtp-server --save
2 — Require in your script​
const{SMTPServer}=require("smtp-server");
const{SMTPServer}=require("smtp-server");
3 — Create a server instance​
constserver=newSMTPServer(options);
constserver=newSMTPServer(options);
4 — Start listening​
server.listen(port[,host][,callback]);
server.listen(port[,host][,callback]);
5 — Shut down​
server.close(callback);
server.close(callback);
Options reference​
Boolean
false
STARTTLS
false
String
os.hostname()
String
Number
0
0
Boolean
false
stream.sizeExceeded
String[]
['PLAIN', 'LOGIN']
'XOAUTH2'
'CRAM-MD5'
Boolean
false
String[]
['AUTH']
Boolean
false
Boolean
true
ENHANCEDSTATUSCODES
EHLO
Boolean
true
DSN
EHLO
Boolean
false
Boolean
false
Map | Object
Boolean | Object
false
true
console
Number
Infinity
Boolean
false
Boolean
false
Boolean
false
Number
60_000
Number
30_000
close()
Function
Object
.reverse
dns
dns.reverse
You may also pass anynet.createServeroptions and, whensecureistrue, anytls.createServeroptions.
net.createServer
secure
true
tls.createServer
TLS and STARTTLS​
If you enable TLS (secure: true)orleaveSTARTTLSenabled, ship a proper certificate viakey,cert, and optionallyca. Otherwisesmtp‑serverfalls back to a self‑signed cert forlocalhost, which almost every client rejects.
secure: true
STARTTLS
key
cert
ca
localhost
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
Handling errors​
Attach anerrorlistener to surface server errors:
error
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
Handling authentication (onAuth)​
onAuth
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
Password‑based (PLAIN / LOGIN)​
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
OAuth 2 (XOAUTH2)​
XOAUTH2
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
Validating client connection (onConnect/onClose)​
onConnect
onClose
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
Validating TLS information (onSecure)​
onSecure
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
Validating sender (onMailFrom)​
onMailFrom
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
Validating recipients (onRcptTo)​
onRcptTo
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
Processing incoming messages (onData)​
onData
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
smtp‑serverstreams your messageverbatim— noReceived:header is added. Add one yourself if you need full RFC 5321 compliance.
Received:
Using the SIZE extension​
Set thesizeoption to advertise a limit, then checkstream.sizeExceededinonData:
size
stream.sizeExceeded
onData
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
Using LMTP​
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
Session object​
String
String
String
remoteAddress
disableReverseLookup
"HELO" | "EHLO" | "LHLO"
String
Object
mailFrom
rcptTo
dsn
any
onAuth
Number
"SMTP" | "ESMTP" | "ESMTPA" …
Received:
Envelope object​
Thesession.envelopeobject contains transaction-specific data:
session.envelope
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
Object
Object[]
Object
Address object​
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
MAIL FROM:
RCPT TO:
DSN Object Properties​
String
'FULL'
'HDRS'
String
String[]
String
Enhanced Status Codes (RFC 2034/3463)​
smtp‑serversupportsEnhanced Status Codesas defined in RFC 2034 and RFC 3463. When enabled, all SMTP responses include enhanced status codes in the formatX.Y.Z:
X.Y.Z
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
Enabling Enhanced Status Codes​
To enable enhanced status codes (they are disabled by default):
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
Disabling Enhanced Status Codes​
Enhanced status codes are disabled by default, but you can explicitly disable them:
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
Enhanced Status Code Examples​
250
2.0.0
250
2.1.0
250
2.1.5
250
2.6.0
501
5.5.4
550
5.1.1
552
5.2.2
DSN (Delivery Status Notification) Support​
smtp‑serverfully supportsDSN parametersas defined in RFC 3461, allowing clients to request delivery status notifications.
DSN functionality requiresdelivery status notificationsto be enabled. Since delivery status notifications are disabled by default, you must sethideDSN: falseto use DSN features.
hideDSN: false
DSN Parameters​
RET=FULLorRET=HDRS— Return full message or headers only in DSN
RET=FULL
RET=HDRS
ENVID=<envelope-id>— Envelope identifier for tracking
ENVID=<envelope-id>
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER— When to send DSN
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER
ORCPT=<original-recipient>— Original recipient for tracking
ORCPT=<original-recipient>
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
Accessing DSN Parameters​
DSN parameters are available in your callback handlers:
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
DSN Parameter Validation​
smtp‑serverautomatically validates DSN parameters:
RETmust beFULLorHDRS
RET
FULL
HDRS
NOTIFYmust beSUCCESS,FAILURE,DELAY, orNEVER
NOTIFY
SUCCESS
FAILURE
DELAY
NEVER
NOTIFY=NEVERcannot be combined with other values
NOTIFY=NEVER
Invalid parameters return appropriate error responses with enhanced status codes
Complete DSN Example​
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
Production DSN Implementation Example​
Here's a complete example showing how to implement DSN notifications using nodemailer:
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
This example demonstrates:
Complete DSN workflowfrom parameter parsing to notification sending
RFC-compliant DSN messageswith proper headers and content
Conditional notificationsbased on NOTIFY parameters
Integration with nodemailerfor sending DSN notifications
Production-ready structurewith error handling
Supported commands and extensions​
Commands​
EHLO/HELO
EHLO
HELO
AUTHLOGIN·PLAIN·XOAUTH2† ·CRAM‑MD5†
AUTH
LOGIN
PLAIN
XOAUTH2
CRAM‑MD5
MAIL/RCPT/DATA
MAIL
RCPT
DATA
RSET/NOOP/QUIT/VRFY
RSET
NOOP
QUIT
VRFY
HELP(returns RFC 5321 URL)
HELP
STARTTLS
STARTTLS
†XOAUTH2andCRAM‑MD5must be enabled viaauthMethods.
XOAUTH2
CRAM‑MD5
authMethods
Extensions​
PIPELINING
PIPELINING
8BITMIME
8BITMIME
SMTPUTF8
SMTPUTF8
SIZE
SIZE
DSN(RFC 3461)
DSN
ENHANCEDSTATUSCODES(RFC 2034/3463)
ENHANCEDSTATUSCODES
TheCHUNKINGextension isnotimplemented.
CHUNKING
License​
MIT
Usage1 — Install2 — Require in your script3 — Create a server instance4 — Start listening5 — Shut down
1 — Install
2 — Require in your script
3 — Create a server instance
4 — Start listening
5 — Shut down
Options reference
TLS and STARTTLS
Handling errors
Handling authentication (onAuth)Password‑based (PLAIN / LOGIN)OAuth 2 (XOAUTH2)
onAuth
Password‑based (PLAIN / LOGIN)
OAuth 2 (XOAUTH2)
XOAUTH2
Validating client connection (onConnect/onClose)
onConnect
onClose
Validating TLS information (onSecure)
onSecure
Validating sender (onMailFrom)
onMailFrom
Validating recipients (onRcptTo)
onRcptTo
Processing incoming messages (onData)
onData
Using the SIZE extension
Using LMTP
Session object
Envelope object
Address objectDSN Object Properties
DSN Object Properties
Enhanced Status Codes (RFC 2034/3463)Enabling Enhanced Status CodesDisabling Enhanced Status CodesEnhanced Status Code Examples
Enabling Enhanced Status Codes
Disabling Enhanced Status Codes
Enhanced Status Code Examples
DSN (Delivery Status Notification) SupportDSN ParametersAccessing DSN ParametersDSN Parameter ValidationComplete DSN ExampleProduction DSN Implementation Example
DSN Parameters
Accessing DSN Parameters
DSN Parameter Validation
Complete DSN Example
Production DSN Implementation Example
Supported commands and extensionsCommandsExtensions
Commands
Extensions
License



===== https://nodemailer.com/extras/smtp-server#1install =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
SMTP Server
SMTP Server
Create SMTP and LMTP server instances on the fly.smtp‑serverisnota full‑blown server application likeHarakabut a convenient way to add custom SMTP or LMTP listeners to your app. It is the successor of the server part of the now‑deprecatedsimplesmtpmodule. For a matching SMTP client, seesmtp‑connection.
Usage​
1 — Install​
npm install smtp-server --save
npm install smtp-server --save
2 — Require in your script​
const{SMTPServer}=require("smtp-server");
const{SMTPServer}=require("smtp-server");
3 — Create a server instance​
constserver=newSMTPServer(options);
constserver=newSMTPServer(options);
4 — Start listening​
server.listen(port[,host][,callback]);
server.listen(port[,host][,callback]);
5 — Shut down​
server.close(callback);
server.close(callback);
Options reference​
Boolean
false
STARTTLS
false
String
os.hostname()
String
Number
0
0
Boolean
false
stream.sizeExceeded
String[]
['PLAIN', 'LOGIN']
'XOAUTH2'
'CRAM-MD5'
Boolean
false
String[]
['AUTH']
Boolean
false
Boolean
true
ENHANCEDSTATUSCODES
EHLO
Boolean
true
DSN
EHLO
Boolean
false
Boolean
false
Map | Object
Boolean | Object
false
true
console
Number
Infinity
Boolean
false
Boolean
false
Boolean
false
Number
60_000
Number
30_000
close()
Function
Object
.reverse
dns
dns.reverse
You may also pass anynet.createServeroptions and, whensecureistrue, anytls.createServeroptions.
net.createServer
secure
true
tls.createServer
TLS and STARTTLS​
If you enable TLS (secure: true)orleaveSTARTTLSenabled, ship a proper certificate viakey,cert, and optionallyca. Otherwisesmtp‑serverfalls back to a self‑signed cert forlocalhost, which almost every client rejects.
secure: true
STARTTLS
key
cert
ca
localhost
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
Handling errors​
Attach anerrorlistener to surface server errors:
error
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
Handling authentication (onAuth)​
onAuth
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
Password‑based (PLAIN / LOGIN)​
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
OAuth 2 (XOAUTH2)​
XOAUTH2
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
Validating client connection (onConnect/onClose)​
onConnect
onClose
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
Validating TLS information (onSecure)​
onSecure
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
Validating sender (onMailFrom)​
onMailFrom
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
Validating recipients (onRcptTo)​
onRcptTo
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
Processing incoming messages (onData)​
onData
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
smtp‑serverstreams your messageverbatim— noReceived:header is added. Add one yourself if you need full RFC 5321 compliance.
Received:
Using the SIZE extension​
Set thesizeoption to advertise a limit, then checkstream.sizeExceededinonData:
size
stream.sizeExceeded
onData
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
Using LMTP​
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
Session object​
String
String
String
remoteAddress
disableReverseLookup
"HELO" | "EHLO" | "LHLO"
String
Object
mailFrom
rcptTo
dsn
any
onAuth
Number
"SMTP" | "ESMTP" | "ESMTPA" …
Received:
Envelope object​
Thesession.envelopeobject contains transaction-specific data:
session.envelope
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
Object
Object[]
Object
Address object​
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
MAIL FROM:
RCPT TO:
DSN Object Properties​
String
'FULL'
'HDRS'
String
String[]
String
Enhanced Status Codes (RFC 2034/3463)​
smtp‑serversupportsEnhanced Status Codesas defined in RFC 2034 and RFC 3463. When enabled, all SMTP responses include enhanced status codes in the formatX.Y.Z:
X.Y.Z
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
Enabling Enhanced Status Codes​
To enable enhanced status codes (they are disabled by default):
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
Disabling Enhanced Status Codes​
Enhanced status codes are disabled by default, but you can explicitly disable them:
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
Enhanced Status Code Examples​
250
2.0.0
250
2.1.0
250
2.1.5
250
2.6.0
501
5.5.4
550
5.1.1
552
5.2.2
DSN (Delivery Status Notification) Support​
smtp‑serverfully supportsDSN parametersas defined in RFC 3461, allowing clients to request delivery status notifications.
DSN functionality requiresdelivery status notificationsto be enabled. Since delivery status notifications are disabled by default, you must sethideDSN: falseto use DSN features.
hideDSN: false
DSN Parameters​
RET=FULLorRET=HDRS— Return full message or headers only in DSN
RET=FULL
RET=HDRS
ENVID=<envelope-id>— Envelope identifier for tracking
ENVID=<envelope-id>
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER— When to send DSN
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER
ORCPT=<original-recipient>— Original recipient for tracking
ORCPT=<original-recipient>
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
Accessing DSN Parameters​
DSN parameters are available in your callback handlers:
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
DSN Parameter Validation​
smtp‑serverautomatically validates DSN parameters:
RETmust beFULLorHDRS
RET
FULL
HDRS
NOTIFYmust beSUCCESS,FAILURE,DELAY, orNEVER
NOTIFY
SUCCESS
FAILURE
DELAY
NEVER
NOTIFY=NEVERcannot be combined with other values
NOTIFY=NEVER
Invalid parameters return appropriate error responses with enhanced status codes
Complete DSN Example​
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
Production DSN Implementation Example​
Here's a complete example showing how to implement DSN notifications using nodemailer:
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
This example demonstrates:
Complete DSN workflowfrom parameter parsing to notification sending
RFC-compliant DSN messageswith proper headers and content
Conditional notificationsbased on NOTIFY parameters
Integration with nodemailerfor sending DSN notifications
Production-ready structurewith error handling
Supported commands and extensions​
Commands​
EHLO/HELO
EHLO
HELO
AUTHLOGIN·PLAIN·XOAUTH2† ·CRAM‑MD5†
AUTH
LOGIN
PLAIN
XOAUTH2
CRAM‑MD5
MAIL/RCPT/DATA
MAIL
RCPT
DATA
RSET/NOOP/QUIT/VRFY
RSET
NOOP
QUIT
VRFY
HELP(returns RFC 5321 URL)
HELP
STARTTLS
STARTTLS
†XOAUTH2andCRAM‑MD5must be enabled viaauthMethods.
XOAUTH2
CRAM‑MD5
authMethods
Extensions​
PIPELINING
PIPELINING
8BITMIME
8BITMIME
SMTPUTF8
SMTPUTF8
SIZE
SIZE
DSN(RFC 3461)
DSN
ENHANCEDSTATUSCODES(RFC 2034/3463)
ENHANCEDSTATUSCODES
TheCHUNKINGextension isnotimplemented.
CHUNKING
License​
MIT
Usage1 — Install2 — Require in your script3 — Create a server instance4 — Start listening5 — Shut down
1 — Install
2 — Require in your script
3 — Create a server instance
4 — Start listening
5 — Shut down
Options reference
TLS and STARTTLS
Handling errors
Handling authentication (onAuth)Password‑based (PLAIN / LOGIN)OAuth 2 (XOAUTH2)
onAuth
Password‑based (PLAIN / LOGIN)
OAuth 2 (XOAUTH2)
XOAUTH2
Validating client connection (onConnect/onClose)
onConnect
onClose
Validating TLS information (onSecure)
onSecure
Validating sender (onMailFrom)
onMailFrom
Validating recipients (onRcptTo)
onRcptTo
Processing incoming messages (onData)
onData
Using the SIZE extension
Using LMTP
Session object
Envelope object
Address objectDSN Object Properties
DSN Object Properties
Enhanced Status Codes (RFC 2034/3463)Enabling Enhanced Status CodesDisabling Enhanced Status CodesEnhanced Status Code Examples
Enabling Enhanced Status Codes
Disabling Enhanced Status Codes
Enhanced Status Code Examples
DSN (Delivery Status Notification) SupportDSN ParametersAccessing DSN ParametersDSN Parameter ValidationComplete DSN ExampleProduction DSN Implementation Example
DSN Parameters
Accessing DSN Parameters
DSN Parameter Validation
Complete DSN Example
Production DSN Implementation Example
Supported commands and extensionsCommandsExtensions
Commands
Extensions
License



===== https://nodemailer.com/extras/smtp-server#2require-in-your-script =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
SMTP Server
SMTP Server
Create SMTP and LMTP server instances on the fly.smtp‑serverisnota full‑blown server application likeHarakabut a convenient way to add custom SMTP or LMTP listeners to your app. It is the successor of the server part of the now‑deprecatedsimplesmtpmodule. For a matching SMTP client, seesmtp‑connection.
Usage​
1 — Install​
npm install smtp-server --save
npm install smtp-server --save
2 — Require in your script​
const{SMTPServer}=require("smtp-server");
const{SMTPServer}=require("smtp-server");
3 — Create a server instance​
constserver=newSMTPServer(options);
constserver=newSMTPServer(options);
4 — Start listening​
server.listen(port[,host][,callback]);
server.listen(port[,host][,callback]);
5 — Shut down​
server.close(callback);
server.close(callback);
Options reference​
Boolean
false
STARTTLS
false
String
os.hostname()
String
Number
0
0
Boolean
false
stream.sizeExceeded
String[]
['PLAIN', 'LOGIN']
'XOAUTH2'
'CRAM-MD5'
Boolean
false
String[]
['AUTH']
Boolean
false
Boolean
true
ENHANCEDSTATUSCODES
EHLO
Boolean
true
DSN
EHLO
Boolean
false
Boolean
false
Map | Object
Boolean | Object
false
true
console
Number
Infinity
Boolean
false
Boolean
false
Boolean
false
Number
60_000
Number
30_000
close()
Function
Object
.reverse
dns
dns.reverse
You may also pass anynet.createServeroptions and, whensecureistrue, anytls.createServeroptions.
net.createServer
secure
true
tls.createServer
TLS and STARTTLS​
If you enable TLS (secure: true)orleaveSTARTTLSenabled, ship a proper certificate viakey,cert, and optionallyca. Otherwisesmtp‑serverfalls back to a self‑signed cert forlocalhost, which almost every client rejects.
secure: true
STARTTLS
key
cert
ca
localhost
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
Handling errors​
Attach anerrorlistener to surface server errors:
error
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
Handling authentication (onAuth)​
onAuth
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
Password‑based (PLAIN / LOGIN)​
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
OAuth 2 (XOAUTH2)​
XOAUTH2
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
Validating client connection (onConnect/onClose)​
onConnect
onClose
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
Validating TLS information (onSecure)​
onSecure
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
Validating sender (onMailFrom)​
onMailFrom
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
Validating recipients (onRcptTo)​
onRcptTo
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
Processing incoming messages (onData)​
onData
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
smtp‑serverstreams your messageverbatim— noReceived:header is added. Add one yourself if you need full RFC 5321 compliance.
Received:
Using the SIZE extension​
Set thesizeoption to advertise a limit, then checkstream.sizeExceededinonData:
size
stream.sizeExceeded
onData
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
Using LMTP​
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
Session object​
String
String
String
remoteAddress
disableReverseLookup
"HELO" | "EHLO" | "LHLO"
String
Object
mailFrom
rcptTo
dsn
any
onAuth
Number
"SMTP" | "ESMTP" | "ESMTPA" …
Received:
Envelope object​
Thesession.envelopeobject contains transaction-specific data:
session.envelope
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
Object
Object[]
Object
Address object​
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
MAIL FROM:
RCPT TO:
DSN Object Properties​
String
'FULL'
'HDRS'
String
String[]
String
Enhanced Status Codes (RFC 2034/3463)​
smtp‑serversupportsEnhanced Status Codesas defined in RFC 2034 and RFC 3463. When enabled, all SMTP responses include enhanced status codes in the formatX.Y.Z:
X.Y.Z
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
Enabling Enhanced Status Codes​
To enable enhanced status codes (they are disabled by default):
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
Disabling Enhanced Status Codes​
Enhanced status codes are disabled by default, but you can explicitly disable them:
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
Enhanced Status Code Examples​
250
2.0.0
250
2.1.0
250
2.1.5
250
2.6.0
501
5.5.4
550
5.1.1
552
5.2.2
DSN (Delivery Status Notification) Support​
smtp‑serverfully supportsDSN parametersas defined in RFC 3461, allowing clients to request delivery status notifications.
DSN functionality requiresdelivery status notificationsto be enabled. Since delivery status notifications are disabled by default, you must sethideDSN: falseto use DSN features.
hideDSN: false
DSN Parameters​
RET=FULLorRET=HDRS— Return full message or headers only in DSN
RET=FULL
RET=HDRS
ENVID=<envelope-id>— Envelope identifier for tracking
ENVID=<envelope-id>
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER— When to send DSN
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER
ORCPT=<original-recipient>— Original recipient for tracking
ORCPT=<original-recipient>
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
Accessing DSN Parameters​
DSN parameters are available in your callback handlers:
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
DSN Parameter Validation​
smtp‑serverautomatically validates DSN parameters:
RETmust beFULLorHDRS
RET
FULL
HDRS
NOTIFYmust beSUCCESS,FAILURE,DELAY, orNEVER
NOTIFY
SUCCESS
FAILURE
DELAY
NEVER
NOTIFY=NEVERcannot be combined with other values
NOTIFY=NEVER
Invalid parameters return appropriate error responses with enhanced status codes
Complete DSN Example​
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
Production DSN Implementation Example​
Here's a complete example showing how to implement DSN notifications using nodemailer:
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
This example demonstrates:
Complete DSN workflowfrom parameter parsing to notification sending
RFC-compliant DSN messageswith proper headers and content
Conditional notificationsbased on NOTIFY parameters
Integration with nodemailerfor sending DSN notifications
Production-ready structurewith error handling
Supported commands and extensions​
Commands​
EHLO/HELO
EHLO
HELO
AUTHLOGIN·PLAIN·XOAUTH2† ·CRAM‑MD5†
AUTH
LOGIN
PLAIN
XOAUTH2
CRAM‑MD5
MAIL/RCPT/DATA
MAIL
RCPT
DATA
RSET/NOOP/QUIT/VRFY
RSET
NOOP
QUIT
VRFY
HELP(returns RFC 5321 URL)
HELP
STARTTLS
STARTTLS
†XOAUTH2andCRAM‑MD5must be enabled viaauthMethods.
XOAUTH2
CRAM‑MD5
authMethods
Extensions​
PIPELINING
PIPELINING
8BITMIME
8BITMIME
SMTPUTF8
SMTPUTF8
SIZE
SIZE
DSN(RFC 3461)
DSN
ENHANCEDSTATUSCODES(RFC 2034/3463)
ENHANCEDSTATUSCODES
TheCHUNKINGextension isnotimplemented.
CHUNKING
License​
MIT
Usage1 — Install2 — Require in your script3 — Create a server instance4 — Start listening5 — Shut down
1 — Install
2 — Require in your script
3 — Create a server instance
4 — Start listening
5 — Shut down
Options reference
TLS and STARTTLS
Handling errors
Handling authentication (onAuth)Password‑based (PLAIN / LOGIN)OAuth 2 (XOAUTH2)
onAuth
Password‑based (PLAIN / LOGIN)
OAuth 2 (XOAUTH2)
XOAUTH2
Validating client connection (onConnect/onClose)
onConnect
onClose
Validating TLS information (onSecure)
onSecure
Validating sender (onMailFrom)
onMailFrom
Validating recipients (onRcptTo)
onRcptTo
Processing incoming messages (onData)
onData
Using the SIZE extension
Using LMTP
Session object
Envelope object
Address objectDSN Object Properties
DSN Object Properties
Enhanced Status Codes (RFC 2034/3463)Enabling Enhanced Status CodesDisabling Enhanced Status CodesEnhanced Status Code Examples
Enabling Enhanced Status Codes
Disabling Enhanced Status Codes
Enhanced Status Code Examples
DSN (Delivery Status Notification) SupportDSN ParametersAccessing DSN ParametersDSN Parameter ValidationComplete DSN ExampleProduction DSN Implementation Example
DSN Parameters
Accessing DSN Parameters
DSN Parameter Validation
Complete DSN Example
Production DSN Implementation Example
Supported commands and extensionsCommandsExtensions
Commands
Extensions
License



===== https://nodemailer.com/extras/smtp-server#3create-a-server-instance =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
SMTP Server
SMTP Server
Create SMTP and LMTP server instances on the fly.smtp‑serverisnota full‑blown server application likeHarakabut a convenient way to add custom SMTP or LMTP listeners to your app. It is the successor of the server part of the now‑deprecatedsimplesmtpmodule. For a matching SMTP client, seesmtp‑connection.
Usage​
1 — Install​
npm install smtp-server --save
npm install smtp-server --save
2 — Require in your script​
const{SMTPServer}=require("smtp-server");
const{SMTPServer}=require("smtp-server");
3 — Create a server instance​
constserver=newSMTPServer(options);
constserver=newSMTPServer(options);
4 — Start listening​
server.listen(port[,host][,callback]);
server.listen(port[,host][,callback]);
5 — Shut down​
server.close(callback);
server.close(callback);
Options reference​
Boolean
false
STARTTLS
false
String
os.hostname()
String
Number
0
0
Boolean
false
stream.sizeExceeded
String[]
['PLAIN', 'LOGIN']
'XOAUTH2'
'CRAM-MD5'
Boolean
false
String[]
['AUTH']
Boolean
false
Boolean
true
ENHANCEDSTATUSCODES
EHLO
Boolean
true
DSN
EHLO
Boolean
false
Boolean
false
Map | Object
Boolean | Object
false
true
console
Number
Infinity
Boolean
false
Boolean
false
Boolean
false
Number
60_000
Number
30_000
close()
Function
Object
.reverse
dns
dns.reverse
You may also pass anynet.createServeroptions and, whensecureistrue, anytls.createServeroptions.
net.createServer
secure
true
tls.createServer
TLS and STARTTLS​
If you enable TLS (secure: true)orleaveSTARTTLSenabled, ship a proper certificate viakey,cert, and optionallyca. Otherwisesmtp‑serverfalls back to a self‑signed cert forlocalhost, which almost every client rejects.
secure: true
STARTTLS
key
cert
ca
localhost
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
Handling errors​
Attach anerrorlistener to surface server errors:
error
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
Handling authentication (onAuth)​
onAuth
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
Password‑based (PLAIN / LOGIN)​
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
OAuth 2 (XOAUTH2)​
XOAUTH2
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
Validating client connection (onConnect/onClose)​
onConnect
onClose
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
Validating TLS information (onSecure)​
onSecure
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
Validating sender (onMailFrom)​
onMailFrom
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
Validating recipients (onRcptTo)​
onRcptTo
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
Processing incoming messages (onData)​
onData
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
smtp‑serverstreams your messageverbatim— noReceived:header is added. Add one yourself if you need full RFC 5321 compliance.
Received:
Using the SIZE extension​
Set thesizeoption to advertise a limit, then checkstream.sizeExceededinonData:
size
stream.sizeExceeded
onData
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
Using LMTP​
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
Session object​
String
String
String
remoteAddress
disableReverseLookup
"HELO" | "EHLO" | "LHLO"
String
Object
mailFrom
rcptTo
dsn
any
onAuth
Number
"SMTP" | "ESMTP" | "ESMTPA" …
Received:
Envelope object​
Thesession.envelopeobject contains transaction-specific data:
session.envelope
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
Object
Object[]
Object
Address object​
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
MAIL FROM:
RCPT TO:
DSN Object Properties​
String
'FULL'
'HDRS'
String
String[]
String
Enhanced Status Codes (RFC 2034/3463)​
smtp‑serversupportsEnhanced Status Codesas defined in RFC 2034 and RFC 3463. When enabled, all SMTP responses include enhanced status codes in the formatX.Y.Z:
X.Y.Z
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
Enabling Enhanced Status Codes​
To enable enhanced status codes (they are disabled by default):
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
Disabling Enhanced Status Codes​
Enhanced status codes are disabled by default, but you can explicitly disable them:
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
Enhanced Status Code Examples​
250
2.0.0
250
2.1.0
250
2.1.5
250
2.6.0
501
5.5.4
550
5.1.1
552
5.2.2
DSN (Delivery Status Notification) Support​
smtp‑serverfully supportsDSN parametersas defined in RFC 3461, allowing clients to request delivery status notifications.
DSN functionality requiresdelivery status notificationsto be enabled. Since delivery status notifications are disabled by default, you must sethideDSN: falseto use DSN features.
hideDSN: false
DSN Parameters​
RET=FULLorRET=HDRS— Return full message or headers only in DSN
RET=FULL
RET=HDRS
ENVID=<envelope-id>— Envelope identifier for tracking
ENVID=<envelope-id>
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER— When to send DSN
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER
ORCPT=<original-recipient>— Original recipient for tracking
ORCPT=<original-recipient>
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
Accessing DSN Parameters​
DSN parameters are available in your callback handlers:
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
DSN Parameter Validation​
smtp‑serverautomatically validates DSN parameters:
RETmust beFULLorHDRS
RET
FULL
HDRS
NOTIFYmust beSUCCESS,FAILURE,DELAY, orNEVER
NOTIFY
SUCCESS
FAILURE
DELAY
NEVER
NOTIFY=NEVERcannot be combined with other values
NOTIFY=NEVER
Invalid parameters return appropriate error responses with enhanced status codes
Complete DSN Example​
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
Production DSN Implementation Example​
Here's a complete example showing how to implement DSN notifications using nodemailer:
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
This example demonstrates:
Complete DSN workflowfrom parameter parsing to notification sending
RFC-compliant DSN messageswith proper headers and content
Conditional notificationsbased on NOTIFY parameters
Integration with nodemailerfor sending DSN notifications
Production-ready structurewith error handling
Supported commands and extensions​
Commands​
EHLO/HELO
EHLO
HELO
AUTHLOGIN·PLAIN·XOAUTH2† ·CRAM‑MD5†
AUTH
LOGIN
PLAIN
XOAUTH2
CRAM‑MD5
MAIL/RCPT/DATA
MAIL
RCPT
DATA
RSET/NOOP/QUIT/VRFY
RSET
NOOP
QUIT
VRFY
HELP(returns RFC 5321 URL)
HELP
STARTTLS
STARTTLS
†XOAUTH2andCRAM‑MD5must be enabled viaauthMethods.
XOAUTH2
CRAM‑MD5
authMethods
Extensions​
PIPELINING
PIPELINING
8BITMIME
8BITMIME
SMTPUTF8
SMTPUTF8
SIZE
SIZE
DSN(RFC 3461)
DSN
ENHANCEDSTATUSCODES(RFC 2034/3463)
ENHANCEDSTATUSCODES
TheCHUNKINGextension isnotimplemented.
CHUNKING
License​
MIT
Usage1 — Install2 — Require in your script3 — Create a server instance4 — Start listening5 — Shut down
1 — Install
2 — Require in your script
3 — Create a server instance
4 — Start listening
5 — Shut down
Options reference
TLS and STARTTLS
Handling errors
Handling authentication (onAuth)Password‑based (PLAIN / LOGIN)OAuth 2 (XOAUTH2)
onAuth
Password‑based (PLAIN / LOGIN)
OAuth 2 (XOAUTH2)
XOAUTH2
Validating client connection (onConnect/onClose)
onConnect
onClose
Validating TLS information (onSecure)
onSecure
Validating sender (onMailFrom)
onMailFrom
Validating recipients (onRcptTo)
onRcptTo
Processing incoming messages (onData)
onData
Using the SIZE extension
Using LMTP
Session object
Envelope object
Address objectDSN Object Properties
DSN Object Properties
Enhanced Status Codes (RFC 2034/3463)Enabling Enhanced Status CodesDisabling Enhanced Status CodesEnhanced Status Code Examples
Enabling Enhanced Status Codes
Disabling Enhanced Status Codes
Enhanced Status Code Examples
DSN (Delivery Status Notification) SupportDSN ParametersAccessing DSN ParametersDSN Parameter ValidationComplete DSN ExampleProduction DSN Implementation Example
DSN Parameters
Accessing DSN Parameters
DSN Parameter Validation
Complete DSN Example
Production DSN Implementation Example
Supported commands and extensionsCommandsExtensions
Commands
Extensions
License



===== https://nodemailer.com/extras/smtp-server#4start-listening =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
SMTP Server
SMTP Server
Create SMTP and LMTP server instances on the fly.smtp‑serverisnota full‑blown server application likeHarakabut a convenient way to add custom SMTP or LMTP listeners to your app. It is the successor of the server part of the now‑deprecatedsimplesmtpmodule. For a matching SMTP client, seesmtp‑connection.
Usage​
1 — Install​
npm install smtp-server --save
npm install smtp-server --save
2 — Require in your script​
const{SMTPServer}=require("smtp-server");
const{SMTPServer}=require("smtp-server");
3 — Create a server instance​
constserver=newSMTPServer(options);
constserver=newSMTPServer(options);
4 — Start listening​
server.listen(port[,host][,callback]);
server.listen(port[,host][,callback]);
5 — Shut down​
server.close(callback);
server.close(callback);
Options reference​
Boolean
false
STARTTLS
false
String
os.hostname()
String
Number
0
0
Boolean
false
stream.sizeExceeded
String[]
['PLAIN', 'LOGIN']
'XOAUTH2'
'CRAM-MD5'
Boolean
false
String[]
['AUTH']
Boolean
false
Boolean
true
ENHANCEDSTATUSCODES
EHLO
Boolean
true
DSN
EHLO
Boolean
false
Boolean
false
Map | Object
Boolean | Object
false
true
console
Number
Infinity
Boolean
false
Boolean
false
Boolean
false
Number
60_000
Number
30_000
close()
Function
Object
.reverse
dns
dns.reverse
You may also pass anynet.createServeroptions and, whensecureistrue, anytls.createServeroptions.
net.createServer
secure
true
tls.createServer
TLS and STARTTLS​
If you enable TLS (secure: true)orleaveSTARTTLSenabled, ship a proper certificate viakey,cert, and optionallyca. Otherwisesmtp‑serverfalls back to a self‑signed cert forlocalhost, which almost every client rejects.
secure: true
STARTTLS
key
cert
ca
localhost
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
Handling errors​
Attach anerrorlistener to surface server errors:
error
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
Handling authentication (onAuth)​
onAuth
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
Password‑based (PLAIN / LOGIN)​
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
OAuth 2 (XOAUTH2)​
XOAUTH2
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
Validating client connection (onConnect/onClose)​
onConnect
onClose
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
Validating TLS information (onSecure)​
onSecure
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
Validating sender (onMailFrom)​
onMailFrom
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
Validating recipients (onRcptTo)​
onRcptTo
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
Processing incoming messages (onData)​
onData
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
smtp‑serverstreams your messageverbatim— noReceived:header is added. Add one yourself if you need full RFC 5321 compliance.
Received:
Using the SIZE extension​
Set thesizeoption to advertise a limit, then checkstream.sizeExceededinonData:
size
stream.sizeExceeded
onData
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
Using LMTP​
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
Session object​
String
String
String
remoteAddress
disableReverseLookup
"HELO" | "EHLO" | "LHLO"
String
Object
mailFrom
rcptTo
dsn
any
onAuth
Number
"SMTP" | "ESMTP" | "ESMTPA" …
Received:
Envelope object​
Thesession.envelopeobject contains transaction-specific data:
session.envelope
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
Object
Object[]
Object
Address object​
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
MAIL FROM:
RCPT TO:
DSN Object Properties​
String
'FULL'
'HDRS'
String
String[]
String
Enhanced Status Codes (RFC 2034/3463)​
smtp‑serversupportsEnhanced Status Codesas defined in RFC 2034 and RFC 3463. When enabled, all SMTP responses include enhanced status codes in the formatX.Y.Z:
X.Y.Z
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
Enabling Enhanced Status Codes​
To enable enhanced status codes (they are disabled by default):
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
Disabling Enhanced Status Codes​
Enhanced status codes are disabled by default, but you can explicitly disable them:
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
Enhanced Status Code Examples​
250
2.0.0
250
2.1.0
250
2.1.5
250
2.6.0
501
5.5.4
550
5.1.1
552
5.2.2
DSN (Delivery Status Notification) Support​
smtp‑serverfully supportsDSN parametersas defined in RFC 3461, allowing clients to request delivery status notifications.
DSN functionality requiresdelivery status notificationsto be enabled. Since delivery status notifications are disabled by default, you must sethideDSN: falseto use DSN features.
hideDSN: false
DSN Parameters​
RET=FULLorRET=HDRS— Return full message or headers only in DSN
RET=FULL
RET=HDRS
ENVID=<envelope-id>— Envelope identifier for tracking
ENVID=<envelope-id>
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER— When to send DSN
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER
ORCPT=<original-recipient>— Original recipient for tracking
ORCPT=<original-recipient>
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
Accessing DSN Parameters​
DSN parameters are available in your callback handlers:
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
DSN Parameter Validation​
smtp‑serverautomatically validates DSN parameters:
RETmust beFULLorHDRS
RET
FULL
HDRS
NOTIFYmust beSUCCESS,FAILURE,DELAY, orNEVER
NOTIFY
SUCCESS
FAILURE
DELAY
NEVER
NOTIFY=NEVERcannot be combined with other values
NOTIFY=NEVER
Invalid parameters return appropriate error responses with enhanced status codes
Complete DSN Example​
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
Production DSN Implementation Example​
Here's a complete example showing how to implement DSN notifications using nodemailer:
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
This example demonstrates:
Complete DSN workflowfrom parameter parsing to notification sending
RFC-compliant DSN messageswith proper headers and content
Conditional notificationsbased on NOTIFY parameters
Integration with nodemailerfor sending DSN notifications
Production-ready structurewith error handling
Supported commands and extensions​
Commands​
EHLO/HELO
EHLO
HELO
AUTHLOGIN·PLAIN·XOAUTH2† ·CRAM‑MD5†
AUTH
LOGIN
PLAIN
XOAUTH2
CRAM‑MD5
MAIL/RCPT/DATA
MAIL
RCPT
DATA
RSET/NOOP/QUIT/VRFY
RSET
NOOP
QUIT
VRFY
HELP(returns RFC 5321 URL)
HELP
STARTTLS
STARTTLS
†XOAUTH2andCRAM‑MD5must be enabled viaauthMethods.
XOAUTH2
CRAM‑MD5
authMethods
Extensions​
PIPELINING
PIPELINING
8BITMIME
8BITMIME
SMTPUTF8
SMTPUTF8
SIZE
SIZE
DSN(RFC 3461)
DSN
ENHANCEDSTATUSCODES(RFC 2034/3463)
ENHANCEDSTATUSCODES
TheCHUNKINGextension isnotimplemented.
CHUNKING
License​
MIT
Usage1 — Install2 — Require in your script3 — Create a server instance4 — Start listening5 — Shut down
1 — Install
2 — Require in your script
3 — Create a server instance
4 — Start listening
5 — Shut down
Options reference
TLS and STARTTLS
Handling errors
Handling authentication (onAuth)Password‑based (PLAIN / LOGIN)OAuth 2 (XOAUTH2)
onAuth
Password‑based (PLAIN / LOGIN)
OAuth 2 (XOAUTH2)
XOAUTH2
Validating client connection (onConnect/onClose)
onConnect
onClose
Validating TLS information (onSecure)
onSecure
Validating sender (onMailFrom)
onMailFrom
Validating recipients (onRcptTo)
onRcptTo
Processing incoming messages (onData)
onData
Using the SIZE extension
Using LMTP
Session object
Envelope object
Address objectDSN Object Properties
DSN Object Properties
Enhanced Status Codes (RFC 2034/3463)Enabling Enhanced Status CodesDisabling Enhanced Status CodesEnhanced Status Code Examples
Enabling Enhanced Status Codes
Disabling Enhanced Status Codes
Enhanced Status Code Examples
DSN (Delivery Status Notification) SupportDSN ParametersAccessing DSN ParametersDSN Parameter ValidationComplete DSN ExampleProduction DSN Implementation Example
DSN Parameters
Accessing DSN Parameters
DSN Parameter Validation
Complete DSN Example
Production DSN Implementation Example
Supported commands and extensionsCommandsExtensions
Commands
Extensions
License



===== https://nodemailer.com/extras/smtp-server#5shut-down =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
SMTP Server
SMTP Server
Create SMTP and LMTP server instances on the fly.smtp‑serverisnota full‑blown server application likeHarakabut a convenient way to add custom SMTP or LMTP listeners to your app. It is the successor of the server part of the now‑deprecatedsimplesmtpmodule. For a matching SMTP client, seesmtp‑connection.
Usage​
1 — Install​
npm install smtp-server --save
npm install smtp-server --save
2 — Require in your script​
const{SMTPServer}=require("smtp-server");
const{SMTPServer}=require("smtp-server");
3 — Create a server instance​
constserver=newSMTPServer(options);
constserver=newSMTPServer(options);
4 — Start listening​
server.listen(port[,host][,callback]);
server.listen(port[,host][,callback]);
5 — Shut down​
server.close(callback);
server.close(callback);
Options reference​
Boolean
false
STARTTLS
false
String
os.hostname()
String
Number
0
0
Boolean
false
stream.sizeExceeded
String[]
['PLAIN', 'LOGIN']
'XOAUTH2'
'CRAM-MD5'
Boolean
false
String[]
['AUTH']
Boolean
false
Boolean
true
ENHANCEDSTATUSCODES
EHLO
Boolean
true
DSN
EHLO
Boolean
false
Boolean
false
Map | Object
Boolean | Object
false
true
console
Number
Infinity
Boolean
false
Boolean
false
Boolean
false
Number
60_000
Number
30_000
close()
Function
Object
.reverse
dns
dns.reverse
You may also pass anynet.createServeroptions and, whensecureistrue, anytls.createServeroptions.
net.createServer
secure
true
tls.createServer
TLS and STARTTLS​
If you enable TLS (secure: true)orleaveSTARTTLSenabled, ship a proper certificate viakey,cert, and optionallyca. Otherwisesmtp‑serverfalls back to a self‑signed cert forlocalhost, which almost every client rejects.
secure: true
STARTTLS
key
cert
ca
localhost
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
Handling errors​
Attach anerrorlistener to surface server errors:
error
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
Handling authentication (onAuth)​
onAuth
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
Password‑based (PLAIN / LOGIN)​
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
OAuth 2 (XOAUTH2)​
XOAUTH2
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
Validating client connection (onConnect/onClose)​
onConnect
onClose
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
Validating TLS information (onSecure)​
onSecure
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
Validating sender (onMailFrom)​
onMailFrom
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
Validating recipients (onRcptTo)​
onRcptTo
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
Processing incoming messages (onData)​
onData
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
smtp‑serverstreams your messageverbatim— noReceived:header is added. Add one yourself if you need full RFC 5321 compliance.
Received:
Using the SIZE extension​
Set thesizeoption to advertise a limit, then checkstream.sizeExceededinonData:
size
stream.sizeExceeded
onData
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
Using LMTP​
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
Session object​
String
String
String
remoteAddress
disableReverseLookup
"HELO" | "EHLO" | "LHLO"
String
Object
mailFrom
rcptTo
dsn
any
onAuth
Number
"SMTP" | "ESMTP" | "ESMTPA" …
Received:
Envelope object​
Thesession.envelopeobject contains transaction-specific data:
session.envelope
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
Object
Object[]
Object
Address object​
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
MAIL FROM:
RCPT TO:
DSN Object Properties​
String
'FULL'
'HDRS'
String
String[]
String
Enhanced Status Codes (RFC 2034/3463)​
smtp‑serversupportsEnhanced Status Codesas defined in RFC 2034 and RFC 3463. When enabled, all SMTP responses include enhanced status codes in the formatX.Y.Z:
X.Y.Z
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
Enabling Enhanced Status Codes​
To enable enhanced status codes (they are disabled by default):
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
Disabling Enhanced Status Codes​
Enhanced status codes are disabled by default, but you can explicitly disable them:
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
Enhanced Status Code Examples​
250
2.0.0
250
2.1.0
250
2.1.5
250
2.6.0
501
5.5.4
550
5.1.1
552
5.2.2
DSN (Delivery Status Notification) Support​
smtp‑serverfully supportsDSN parametersas defined in RFC 3461, allowing clients to request delivery status notifications.
DSN functionality requiresdelivery status notificationsto be enabled. Since delivery status notifications are disabled by default, you must sethideDSN: falseto use DSN features.
hideDSN: false
DSN Parameters​
RET=FULLorRET=HDRS— Return full message or headers only in DSN
RET=FULL
RET=HDRS
ENVID=<envelope-id>— Envelope identifier for tracking
ENVID=<envelope-id>
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER— When to send DSN
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER
ORCPT=<original-recipient>— Original recipient for tracking
ORCPT=<original-recipient>
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
Accessing DSN Parameters​
DSN parameters are available in your callback handlers:
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
DSN Parameter Validation​
smtp‑serverautomatically validates DSN parameters:
RETmust beFULLorHDRS
RET
FULL
HDRS
NOTIFYmust beSUCCESS,FAILURE,DELAY, orNEVER
NOTIFY
SUCCESS
FAILURE
DELAY
NEVER
NOTIFY=NEVERcannot be combined with other values
NOTIFY=NEVER
Invalid parameters return appropriate error responses with enhanced status codes
Complete DSN Example​
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
Production DSN Implementation Example​
Here's a complete example showing how to implement DSN notifications using nodemailer:
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
This example demonstrates:
Complete DSN workflowfrom parameter parsing to notification sending
RFC-compliant DSN messageswith proper headers and content
Conditional notificationsbased on NOTIFY parameters
Integration with nodemailerfor sending DSN notifications
Production-ready structurewith error handling
Supported commands and extensions​
Commands​
EHLO/HELO
EHLO
HELO
AUTHLOGIN·PLAIN·XOAUTH2† ·CRAM‑MD5†
AUTH
LOGIN
PLAIN
XOAUTH2
CRAM‑MD5
MAIL/RCPT/DATA
MAIL
RCPT
DATA
RSET/NOOP/QUIT/VRFY
RSET
NOOP
QUIT
VRFY
HELP(returns RFC 5321 URL)
HELP
STARTTLS
STARTTLS
†XOAUTH2andCRAM‑MD5must be enabled viaauthMethods.
XOAUTH2
CRAM‑MD5
authMethods
Extensions​
PIPELINING
PIPELINING
8BITMIME
8BITMIME
SMTPUTF8
SMTPUTF8
SIZE
SIZE
DSN(RFC 3461)
DSN
ENHANCEDSTATUSCODES(RFC 2034/3463)
ENHANCEDSTATUSCODES
TheCHUNKINGextension isnotimplemented.
CHUNKING
License​
MIT
Usage1 — Install2 — Require in your script3 — Create a server instance4 — Start listening5 — Shut down
1 — Install
2 — Require in your script
3 — Create a server instance
4 — Start listening
5 — Shut down
Options reference
TLS and STARTTLS
Handling errors
Handling authentication (onAuth)Password‑based (PLAIN / LOGIN)OAuth 2 (XOAUTH2)
onAuth
Password‑based (PLAIN / LOGIN)
OAuth 2 (XOAUTH2)
XOAUTH2
Validating client connection (onConnect/onClose)
onConnect
onClose
Validating TLS information (onSecure)
onSecure
Validating sender (onMailFrom)
onMailFrom
Validating recipients (onRcptTo)
onRcptTo
Processing incoming messages (onData)
onData
Using the SIZE extension
Using LMTP
Session object
Envelope object
Address objectDSN Object Properties
DSN Object Properties
Enhanced Status Codes (RFC 2034/3463)Enabling Enhanced Status CodesDisabling Enhanced Status CodesEnhanced Status Code Examples
Enabling Enhanced Status Codes
Disabling Enhanced Status Codes
Enhanced Status Code Examples
DSN (Delivery Status Notification) SupportDSN ParametersAccessing DSN ParametersDSN Parameter ValidationComplete DSN ExampleProduction DSN Implementation Example
DSN Parameters
Accessing DSN Parameters
DSN Parameter Validation
Complete DSN Example
Production DSN Implementation Example
Supported commands and extensionsCommandsExtensions
Commands
Extensions
License



===== https://nodemailer.com/extras/smtp-server#options-reference =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
SMTP Server
SMTP Server
Create SMTP and LMTP server instances on the fly.smtp‑serverisnota full‑blown server application likeHarakabut a convenient way to add custom SMTP or LMTP listeners to your app. It is the successor of the server part of the now‑deprecatedsimplesmtpmodule. For a matching SMTP client, seesmtp‑connection.
Usage​
1 — Install​
npm install smtp-server --save
npm install smtp-server --save
2 — Require in your script​
const{SMTPServer}=require("smtp-server");
const{SMTPServer}=require("smtp-server");
3 — Create a server instance​
constserver=newSMTPServer(options);
constserver=newSMTPServer(options);
4 — Start listening​
server.listen(port[,host][,callback]);
server.listen(port[,host][,callback]);
5 — Shut down​
server.close(callback);
server.close(callback);
Options reference​
Boolean
false
STARTTLS
false
String
os.hostname()
String
Number
0
0
Boolean
false
stream.sizeExceeded
String[]
['PLAIN', 'LOGIN']
'XOAUTH2'
'CRAM-MD5'
Boolean
false
String[]
['AUTH']
Boolean
false
Boolean
true
ENHANCEDSTATUSCODES
EHLO
Boolean
true
DSN
EHLO
Boolean
false
Boolean
false
Map | Object
Boolean | Object
false
true
console
Number
Infinity
Boolean
false
Boolean
false
Boolean
false
Number
60_000
Number
30_000
close()
Function
Object
.reverse
dns
dns.reverse
You may also pass anynet.createServeroptions and, whensecureistrue, anytls.createServeroptions.
net.createServer
secure
true
tls.createServer
TLS and STARTTLS​
If you enable TLS (secure: true)orleaveSTARTTLSenabled, ship a proper certificate viakey,cert, and optionallyca. Otherwisesmtp‑serverfalls back to a self‑signed cert forlocalhost, which almost every client rejects.
secure: true
STARTTLS
key
cert
ca
localhost
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
Handling errors​
Attach anerrorlistener to surface server errors:
error
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
Handling authentication (onAuth)​
onAuth
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
Password‑based (PLAIN / LOGIN)​
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
OAuth 2 (XOAUTH2)​
XOAUTH2
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
Validating client connection (onConnect/onClose)​
onConnect
onClose
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
Validating TLS information (onSecure)​
onSecure
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
Validating sender (onMailFrom)​
onMailFrom
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
Validating recipients (onRcptTo)​
onRcptTo
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
Processing incoming messages (onData)​
onData
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
smtp‑serverstreams your messageverbatim— noReceived:header is added. Add one yourself if you need full RFC 5321 compliance.
Received:
Using the SIZE extension​
Set thesizeoption to advertise a limit, then checkstream.sizeExceededinonData:
size
stream.sizeExceeded
onData
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
Using LMTP​
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
Session object​
String
String
String
remoteAddress
disableReverseLookup
"HELO" | "EHLO" | "LHLO"
String
Object
mailFrom
rcptTo
dsn
any
onAuth
Number
"SMTP" | "ESMTP" | "ESMTPA" …
Received:
Envelope object​
Thesession.envelopeobject contains transaction-specific data:
session.envelope
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
Object
Object[]
Object
Address object​
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
MAIL FROM:
RCPT TO:
DSN Object Properties​
String
'FULL'
'HDRS'
String
String[]
String
Enhanced Status Codes (RFC 2034/3463)​
smtp‑serversupportsEnhanced Status Codesas defined in RFC 2034 and RFC 3463. When enabled, all SMTP responses include enhanced status codes in the formatX.Y.Z:
X.Y.Z
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
Enabling Enhanced Status Codes​
To enable enhanced status codes (they are disabled by default):
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
Disabling Enhanced Status Codes​
Enhanced status codes are disabled by default, but you can explicitly disable them:
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
Enhanced Status Code Examples​
250
2.0.0
250
2.1.0
250
2.1.5
250
2.6.0
501
5.5.4
550
5.1.1
552
5.2.2
DSN (Delivery Status Notification) Support​
smtp‑serverfully supportsDSN parametersas defined in RFC 3461, allowing clients to request delivery status notifications.
DSN functionality requiresdelivery status notificationsto be enabled. Since delivery status notifications are disabled by default, you must sethideDSN: falseto use DSN features.
hideDSN: false
DSN Parameters​
RET=FULLorRET=HDRS— Return full message or headers only in DSN
RET=FULL
RET=HDRS
ENVID=<envelope-id>— Envelope identifier for tracking
ENVID=<envelope-id>
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER— When to send DSN
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER
ORCPT=<original-recipient>— Original recipient for tracking
ORCPT=<original-recipient>
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
Accessing DSN Parameters​
DSN parameters are available in your callback handlers:
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
DSN Parameter Validation​
smtp‑serverautomatically validates DSN parameters:
RETmust beFULLorHDRS
RET
FULL
HDRS
NOTIFYmust beSUCCESS,FAILURE,DELAY, orNEVER
NOTIFY
SUCCESS
FAILURE
DELAY
NEVER
NOTIFY=NEVERcannot be combined with other values
NOTIFY=NEVER
Invalid parameters return appropriate error responses with enhanced status codes
Complete DSN Example​
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
Production DSN Implementation Example​
Here's a complete example showing how to implement DSN notifications using nodemailer:
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
This example demonstrates:
Complete DSN workflowfrom parameter parsing to notification sending
RFC-compliant DSN messageswith proper headers and content
Conditional notificationsbased on NOTIFY parameters
Integration with nodemailerfor sending DSN notifications
Production-ready structurewith error handling
Supported commands and extensions​
Commands​
EHLO/HELO
EHLO
HELO
AUTHLOGIN·PLAIN·XOAUTH2† ·CRAM‑MD5†
AUTH
LOGIN
PLAIN
XOAUTH2
CRAM‑MD5
MAIL/RCPT/DATA
MAIL
RCPT
DATA
RSET/NOOP/QUIT/VRFY
RSET
NOOP
QUIT
VRFY
HELP(returns RFC 5321 URL)
HELP
STARTTLS
STARTTLS
†XOAUTH2andCRAM‑MD5must be enabled viaauthMethods.
XOAUTH2
CRAM‑MD5
authMethods
Extensions​
PIPELINING
PIPELINING
8BITMIME
8BITMIME
SMTPUTF8
SMTPUTF8
SIZE
SIZE
DSN(RFC 3461)
DSN
ENHANCEDSTATUSCODES(RFC 2034/3463)
ENHANCEDSTATUSCODES
TheCHUNKINGextension isnotimplemented.
CHUNKING
License​
MIT
Usage1 — Install2 — Require in your script3 — Create a server instance4 — Start listening5 — Shut down
1 — Install
2 — Require in your script
3 — Create a server instance
4 — Start listening
5 — Shut down
Options reference
TLS and STARTTLS
Handling errors
Handling authentication (onAuth)Password‑based (PLAIN / LOGIN)OAuth 2 (XOAUTH2)
onAuth
Password‑based (PLAIN / LOGIN)
OAuth 2 (XOAUTH2)
XOAUTH2
Validating client connection (onConnect/onClose)
onConnect
onClose
Validating TLS information (onSecure)
onSecure
Validating sender (onMailFrom)
onMailFrom
Validating recipients (onRcptTo)
onRcptTo
Processing incoming messages (onData)
onData
Using the SIZE extension
Using LMTP
Session object
Envelope object
Address objectDSN Object Properties
DSN Object Properties
Enhanced Status Codes (RFC 2034/3463)Enabling Enhanced Status CodesDisabling Enhanced Status CodesEnhanced Status Code Examples
Enabling Enhanced Status Codes
Disabling Enhanced Status Codes
Enhanced Status Code Examples
DSN (Delivery Status Notification) SupportDSN ParametersAccessing DSN ParametersDSN Parameter ValidationComplete DSN ExampleProduction DSN Implementation Example
DSN Parameters
Accessing DSN Parameters
DSN Parameter Validation
Complete DSN Example
Production DSN Implementation Example
Supported commands and extensionsCommandsExtensions
Commands
Extensions
License



===== https://nodemailer.com/extras/smtp-server#tls-and-starttls =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
SMTP Server
SMTP Server
Create SMTP and LMTP server instances on the fly.smtp‑serverisnota full‑blown server application likeHarakabut a convenient way to add custom SMTP or LMTP listeners to your app. It is the successor of the server part of the now‑deprecatedsimplesmtpmodule. For a matching SMTP client, seesmtp‑connection.
Usage​
1 — Install​
npm install smtp-server --save
npm install smtp-server --save
2 — Require in your script​
const{SMTPServer}=require("smtp-server");
const{SMTPServer}=require("smtp-server");
3 — Create a server instance​
constserver=newSMTPServer(options);
constserver=newSMTPServer(options);
4 — Start listening​
server.listen(port[,host][,callback]);
server.listen(port[,host][,callback]);
5 — Shut down​
server.close(callback);
server.close(callback);
Options reference​
Boolean
false
STARTTLS
false
String
os.hostname()
String
Number
0
0
Boolean
false
stream.sizeExceeded
String[]
['PLAIN', 'LOGIN']
'XOAUTH2'
'CRAM-MD5'
Boolean
false
String[]
['AUTH']
Boolean
false
Boolean
true
ENHANCEDSTATUSCODES
EHLO
Boolean
true
DSN
EHLO
Boolean
false
Boolean
false
Map | Object
Boolean | Object
false
true
console
Number
Infinity
Boolean
false
Boolean
false
Boolean
false
Number
60_000
Number
30_000
close()
Function
Object
.reverse
dns
dns.reverse
You may also pass anynet.createServeroptions and, whensecureistrue, anytls.createServeroptions.
net.createServer
secure
true
tls.createServer
TLS and STARTTLS​
If you enable TLS (secure: true)orleaveSTARTTLSenabled, ship a proper certificate viakey,cert, and optionallyca. Otherwisesmtp‑serverfalls back to a self‑signed cert forlocalhost, which almost every client rejects.
secure: true
STARTTLS
key
cert
ca
localhost
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
Handling errors​
Attach anerrorlistener to surface server errors:
error
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
Handling authentication (onAuth)​
onAuth
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
Password‑based (PLAIN / LOGIN)​
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
OAuth 2 (XOAUTH2)​
XOAUTH2
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
Validating client connection (onConnect/onClose)​
onConnect
onClose
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
Validating TLS information (onSecure)​
onSecure
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
Validating sender (onMailFrom)​
onMailFrom
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
Validating recipients (onRcptTo)​
onRcptTo
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
Processing incoming messages (onData)​
onData
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
smtp‑serverstreams your messageverbatim— noReceived:header is added. Add one yourself if you need full RFC 5321 compliance.
Received:
Using the SIZE extension​
Set thesizeoption to advertise a limit, then checkstream.sizeExceededinonData:
size
stream.sizeExceeded
onData
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
Using LMTP​
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
Session object​
String
String
String
remoteAddress
disableReverseLookup
"HELO" | "EHLO" | "LHLO"
String
Object
mailFrom
rcptTo
dsn
any
onAuth
Number
"SMTP" | "ESMTP" | "ESMTPA" …
Received:
Envelope object​
Thesession.envelopeobject contains transaction-specific data:
session.envelope
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
Object
Object[]
Object
Address object​
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
MAIL FROM:
RCPT TO:
DSN Object Properties​
String
'FULL'
'HDRS'
String
String[]
String
Enhanced Status Codes (RFC 2034/3463)​
smtp‑serversupportsEnhanced Status Codesas defined in RFC 2034 and RFC 3463. When enabled, all SMTP responses include enhanced status codes in the formatX.Y.Z:
X.Y.Z
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
Enabling Enhanced Status Codes​
To enable enhanced status codes (they are disabled by default):
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
Disabling Enhanced Status Codes​
Enhanced status codes are disabled by default, but you can explicitly disable them:
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
Enhanced Status Code Examples​
250
2.0.0
250
2.1.0
250
2.1.5
250
2.6.0
501
5.5.4
550
5.1.1
552
5.2.2
DSN (Delivery Status Notification) Support​
smtp‑serverfully supportsDSN parametersas defined in RFC 3461, allowing clients to request delivery status notifications.
DSN functionality requiresdelivery status notificationsto be enabled. Since delivery status notifications are disabled by default, you must sethideDSN: falseto use DSN features.
hideDSN: false
DSN Parameters​
RET=FULLorRET=HDRS— Return full message or headers only in DSN
RET=FULL
RET=HDRS
ENVID=<envelope-id>— Envelope identifier for tracking
ENVID=<envelope-id>
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER— When to send DSN
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER
ORCPT=<original-recipient>— Original recipient for tracking
ORCPT=<original-recipient>
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
Accessing DSN Parameters​
DSN parameters are available in your callback handlers:
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
DSN Parameter Validation​
smtp‑serverautomatically validates DSN parameters:
RETmust beFULLorHDRS
RET
FULL
HDRS
NOTIFYmust beSUCCESS,FAILURE,DELAY, orNEVER
NOTIFY
SUCCESS
FAILURE
DELAY
NEVER
NOTIFY=NEVERcannot be combined with other values
NOTIFY=NEVER
Invalid parameters return appropriate error responses with enhanced status codes
Complete DSN Example​
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
Production DSN Implementation Example​
Here's a complete example showing how to implement DSN notifications using nodemailer:
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
This example demonstrates:
Complete DSN workflowfrom parameter parsing to notification sending
RFC-compliant DSN messageswith proper headers and content
Conditional notificationsbased on NOTIFY parameters
Integration with nodemailerfor sending DSN notifications
Production-ready structurewith error handling
Supported commands and extensions​
Commands​
EHLO/HELO
EHLO
HELO
AUTHLOGIN·PLAIN·XOAUTH2† ·CRAM‑MD5†
AUTH
LOGIN
PLAIN
XOAUTH2
CRAM‑MD5
MAIL/RCPT/DATA
MAIL
RCPT
DATA
RSET/NOOP/QUIT/VRFY
RSET
NOOP
QUIT
VRFY
HELP(returns RFC 5321 URL)
HELP
STARTTLS
STARTTLS
†XOAUTH2andCRAM‑MD5must be enabled viaauthMethods.
XOAUTH2
CRAM‑MD5
authMethods
Extensions​
PIPELINING
PIPELINING
8BITMIME
8BITMIME
SMTPUTF8
SMTPUTF8
SIZE
SIZE
DSN(RFC 3461)
DSN
ENHANCEDSTATUSCODES(RFC 2034/3463)
ENHANCEDSTATUSCODES
TheCHUNKINGextension isnotimplemented.
CHUNKING
License​
MIT
Usage1 — Install2 — Require in your script3 — Create a server instance4 — Start listening5 — Shut down
1 — Install
2 — Require in your script
3 — Create a server instance
4 — Start listening
5 — Shut down
Options reference
TLS and STARTTLS
Handling errors
Handling authentication (onAuth)Password‑based (PLAIN / LOGIN)OAuth 2 (XOAUTH2)
onAuth
Password‑based (PLAIN / LOGIN)
OAuth 2 (XOAUTH2)
XOAUTH2
Validating client connection (onConnect/onClose)
onConnect
onClose
Validating TLS information (onSecure)
onSecure
Validating sender (onMailFrom)
onMailFrom
Validating recipients (onRcptTo)
onRcptTo
Processing incoming messages (onData)
onData
Using the SIZE extension
Using LMTP
Session object
Envelope object
Address objectDSN Object Properties
DSN Object Properties
Enhanced Status Codes (RFC 2034/3463)Enabling Enhanced Status CodesDisabling Enhanced Status CodesEnhanced Status Code Examples
Enabling Enhanced Status Codes
Disabling Enhanced Status Codes
Enhanced Status Code Examples
DSN (Delivery Status Notification) SupportDSN ParametersAccessing DSN ParametersDSN Parameter ValidationComplete DSN ExampleProduction DSN Implementation Example
DSN Parameters
Accessing DSN Parameters
DSN Parameter Validation
Complete DSN Example
Production DSN Implementation Example
Supported commands and extensionsCommandsExtensions
Commands
Extensions
License



===== https://nodemailer.com/extras/smtp-server#handling-errors =====

Nodemailer
Usage
Message configuration
SMTP transport
Other transports
Plugins
DKIM
Extra modulesSMTP ServerMailParserMailcomposerTesting SMTP
SMTP Server
MailParser
Mailcomposer
Testing SMTP
License
Send and receive emails easily with Outlook and Gmail using OAuth2.
Extra modules
SMTP Server
SMTP Server
Create SMTP and LMTP server instances on the fly.smtp‑serverisnota full‑blown server application likeHarakabut a convenient way to add custom SMTP or LMTP listeners to your app. It is the successor of the server part of the now‑deprecatedsimplesmtpmodule. For a matching SMTP client, seesmtp‑connection.
Usage​
1 — Install​
npm install smtp-server --save
npm install smtp-server --save
2 — Require in your script​
const{SMTPServer}=require("smtp-server");
const{SMTPServer}=require("smtp-server");
3 — Create a server instance​
constserver=newSMTPServer(options);
constserver=newSMTPServer(options);
4 — Start listening​
server.listen(port[,host][,callback]);
server.listen(port[,host][,callback]);
5 — Shut down​
server.close(callback);
server.close(callback);
Options reference​
Boolean
false
STARTTLS
false
String
os.hostname()
String
Number
0
0
Boolean
false
stream.sizeExceeded
String[]
['PLAIN', 'LOGIN']
'XOAUTH2'
'CRAM-MD5'
Boolean
false
String[]
['AUTH']
Boolean
false
Boolean
true
ENHANCEDSTATUSCODES
EHLO
Boolean
true
DSN
EHLO
Boolean
false
Boolean
false
Map | Object
Boolean | Object
false
true
console
Number
Infinity
Boolean
false
Boolean
false
Boolean
false
Number
60_000
Number
30_000
close()
Function
Object
.reverse
dns
dns.reverse
You may also pass anynet.createServeroptions and, whensecureistrue, anytls.createServeroptions.
net.createServer
secure
true
tls.createServer
TLS and STARTTLS​
If you enable TLS (secure: true)orleaveSTARTTLSenabled, ship a proper certificate viakey,cert, and optionallyca. Otherwisesmtp‑serverfalls back to a self‑signed cert forlocalhost, which almost every client rejects.
secure: true
STARTTLS
key
cert
ca
localhost
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
constfs=require("fs");constserver=newSMTPServer({secure:true,key:fs.readFileSync("private.key"),cert:fs.readFileSync("server.crt"),});server.listen(465);
Handling errors​
Attach anerrorlistener to surface server errors:
error
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
server.on("error",(err)=>{console.error("SMTP Server error:",err.message);});
Handling authentication (onAuth)​
onAuth
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
constserver=newSMTPServer({onAuth(auth,session,callback){// auth.method → 'PLAIN', 'LOGIN', 'XOAUTH2', or 'CRAM-MD5'// Return `callback(err)` to reject, `callback(null, response)` to accept},});
Password‑based (PLAIN / LOGIN)​
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
onAuth(auth,session,cb){if(auth.username!=="alice"||auth.password!=="s3cr3t"){returncb(newError("Invalid username or password"));}cb(null,{user:auth.username});}
OAuth 2 (XOAUTH2)​
XOAUTH2
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
constserver=newSMTPServer({authMethods:["XOAUTH2"],onAuth(auth,session,cb){if(auth.accessToken!=="ya29.a0Af…"){returncb(null,{data:{status:"401",schemes:"bearer"},});// see RFC 6750 Sec. 3}cb(null,{user:auth.username});},});
Validating client connection (onConnect/onClose)​
onConnect
onClose
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
constserver=newSMTPServer({onConnect(session,cb){if(session.remoteAddress==="127.0.0.1"){returncb(newError("Connections from localhost are not allowed"));}cb();// accept},onClose(session){console.log(`Connection from${session.remoteAddress}closed`);},});
Validating TLS information (onSecure)​
onSecure
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
onSecure(socket,session,cb){if(session.servername!=="mail.example.com"){returncb(newError("SNI mismatch"));}cb();}
Validating sender (onMailFrom)​
onMailFrom
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
onMailFrom(address,session,cb){if(!address.address.endsWith("@example.com")){returncb(Object.assign(newError("Relay denied"),{responseCode:553}));}cb();}
Validating recipients (onRcptTo)​
onRcptTo
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
onRcptTo(address,session,cb){if(address.address==="blackhole@example.com"){returncb(newError("User unknown"));}cb();}
Processing incoming messages (onData)​
onData
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
onData(stream,session,cb){constwrite=require("fs").createWriteStream("/tmp/message.eml");stream.pipe(write);stream.on("end",()=>cb(null,"Queued"));}
smtp‑serverstreams your messageverbatim— noReceived:header is added. Add one yourself if you need full RFC 5321 compliance.
Received:
Using the SIZE extension​
Set thesizeoption to advertise a limit, then checkstream.sizeExceededinonData:
size
stream.sizeExceeded
onData
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
constserver=newSMTPServer({size:1024*1024,// 1 MiBonData(s,sess,cb){s.on("end",()=>{if(s.sizeExceeded){consterr=Object.assign(newError("Message too large"),{responseCode:552});returncb(err);}cb(null,"OK");});},});
Using LMTP​
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
constserver=newSMTPServer({lmtp:true,onData(stream,session,cb){stream.on("end",()=>{// Return one reply **per** recipientconstreplies=session.envelope.rcptTo.map((rcpt,i)=>(i%2?newError(`<${rcpt.address}> rejected`):`<${rcpt.address}> accepted`));cb(null,replies);});},});
Session object​
String
String
String
remoteAddress
disableReverseLookup
"HELO" | "EHLO" | "LHLO"
String
Object
mailFrom
rcptTo
dsn
any
onAuth
Number
"SMTP" | "ESMTP" | "ESMTPA" …
Received:
Envelope object​
Thesession.envelopeobject contains transaction-specific data:
session.envelope
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
{"mailFrom": {"address": "sender@example.com","args": { "SIZE": "12345", "RET": "HDRS" },"dsn": { "ret": "HDRS", "envid": "abc123" }},"rcptTo": [{"address": "user1@example.com","args": { "NOTIFY": "SUCCESS,FAILURE" },"dsn": { "notify": ["SUCCESS", "FAILURE"], "orcpt": "rfc822;user1@example.com" }}],"dsn": {"ret": "HDRS","envid": "abc123"}}
Object
Object[]
Object
Address object​
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
{"address": "sender@example.com","args": {"SIZE": "12345","RET": "HDRS"},"dsn": {"ret": "HDRS","envid": "abc123","notify": ["SUCCESS", "FAILURE"],"orcpt": "rfc822;original@example.com"}}
MAIL FROM:
RCPT TO:
DSN Object Properties​
String
'FULL'
'HDRS'
String
String[]
String
Enhanced Status Codes (RFC 2034/3463)​
smtp‑serversupportsEnhanced Status Codesas defined in RFC 2034 and RFC 3463. When enabled, all SMTP responses include enhanced status codes in the formatX.Y.Z:
X.Y.Z
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
250 2.1.0 Accepted        ← Enhanced status code: 2.1.0550 5.1.1 Mailbox unavailable ← Enhanced status code: 5.1.1
Enabling Enhanced Status Codes​
To enable enhanced status codes (they are disabled by default):
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:false,// Enable enhanced status codesonMailFrom(address,session,callback){callback();// Response: "250 2.1.0 Accepted" (with enhanced code)},});
Disabling Enhanced Status Codes​
Enhanced status codes are disabled by default, but you can explicitly disable them:
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
constserver=newSMTPServer({hideENHANCEDSTATUSCODES:true,// Explicitly disable enhanced status codes (default behavior)onMailFrom(address,session,callback){callback();// Response: "250 Accepted" (no enhanced code)},});
Enhanced Status Code Examples​
250
2.0.0
250
2.1.0
250
2.1.5
250
2.6.0
501
5.5.4
550
5.1.1
552
5.2.2
DSN (Delivery Status Notification) Support​
smtp‑serverfully supportsDSN parametersas defined in RFC 3461, allowing clients to request delivery status notifications.
DSN functionality requiresdelivery status notificationsto be enabled. Since delivery status notifications are disabled by default, you must sethideDSN: falseto use DSN features.
hideDSN: false
DSN Parameters​
RET=FULLorRET=HDRS— Return full message or headers only in DSN
RET=FULL
RET=HDRS
ENVID=<envelope-id>— Envelope identifier for tracking
ENVID=<envelope-id>
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
// Client sends: MAIL FROM:<sender@example.com> RET=FULL ENVID=abc123
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER— When to send DSN
NOTIFY=SUCCESS,FAILURE,DELAY,NEVER
ORCPT=<original-recipient>— Original recipient for tracking
ORCPT=<original-recipient>
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
// Client sends: RCPT TO:<user@example.com> NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.com
Accessing DSN Parameters​
DSN parameters are available in your callback handlers:
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){// Access DSN parameters from MAIL FROMconstret=session.envelope.dsn.ret;// 'FULL' or 'HDRS'constenvid=session.envelope.dsn.envid;// Envelope IDconsole.log(`RET:${ret}, ENVID:${envid}`);callback();},onRcptTo(address,session,callback){// Access DSN parameters from RCPT TOconstnotify=address.dsn.notify;// ['SUCCESS', 'FAILURE', 'DELAY']constorcpt=address.dsn.orcpt;// Original recipientconsole.log(`NOTIFY:${notify.join(",")}, ORCPT:${orcpt}`);callback();},});
DSN Parameter Validation​
smtp‑serverautomatically validates DSN parameters:
RETmust beFULLorHDRS
RET
FULL
HDRS
NOTIFYmust beSUCCESS,FAILURE,DELAY, orNEVER
NOTIFY
SUCCESS
FAILURE
DELAY
NEVER
NOTIFY=NEVERcannot be combined with other values
NOTIFY=NEVER
Invalid parameters return appropriate error responses with enhanced status codes
Complete DSN Example​
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
constserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityonMailFrom(address,session,callback){const{ret,envid}=session.envelope.dsn;console.log(`Mail from${address.address}, RET=${ret}, ENVID=${envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`Rcpt to${address.address}, NOTIFY=${notify.join(",")}, ORCPT=${orcpt}`);callback();},onData(stream,session,callback){// Process message with DSN contextconst{dsn}=session.envelope;console.log(`Processing message with DSN:${JSON.stringify(dsn)}`);stream.on("end",()=>{callback(null,"Message accepted for delivery");});stream.resume();},});
Production DSN Implementation Example​
Here's a complete example showing how to implement DSN notifications using nodemailer:
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
const{SMTPServer}=require("smtp-server");constnodemailer=require("nodemailer");// Create a nodemailer transporter for sending DSN notificationsconstdsnTransporter=nodemailer.createTransporter({host:"smtp.example.com",port:587,secure:false,auth:{user:"dsn-sender@example.com",pass:"your-password",},});// DSN notification generatorclassDSNNotifier{constructor(transporter){this.transporter=transporter;}asyncsendSuccessNotification(envelope,messageId,deliveryTime){// Only send if SUCCESS notification was requestedconstneedsSuccessNotification=envelope.rcptTo.some((rcpt)=>rcpt.dsn.notify&&rcpt.dsn.notify.includes("SUCCESS"));if(!needsSuccessNotification||!envelope.mailFrom.address){return;}constdsnMessage=this.generateDSNMessage({action:"delivered",status:"2.0.0",envelope,messageId,deliveryTime,diagnosticCode:"smtp; 250 2.0.0 Message accepted for delivery",});awaitthis.transporter.sendMail({from:"postmaster@example.com",to:envelope.mailFrom.address,subject:"Delivery Status Notification (Success)",text:dsnMessage.text,headers:{"Auto-Submitted":"auto-replied","Content-Type":"multipart/report; report-type=delivery-status",},});}generateDSNMessage({action,status,envelope,messageId,deliveryTime,diagnosticCode}){const{dsn}=envelope;consttimestamp=deliveryTime||newDate().toISOString();// Generate RFC 3464 compliant delivery status notificationconsttext=`This is an automatically generated Delivery Status Notification.Original Message Details:- Message ID:${messageId}- Envelope ID:${dsn.envid||"Not provided"}- Sender:${envelope.mailFrom.address}- Recipients:${envelope.rcptTo.map((r)=>r.address).join(", ")}- Action:${action}- Status:${status}- Time:${timestamp}${action==="delivered"?"Your message has been successfully delivered to all recipients.":"Delivery failed for one or more recipients."}`;return{text};}}// Create DSN notifier instanceconstdsnNotifier=newDSNNotifier(dsnTransporter);// SMTP Server with DSN supportconstserver=newSMTPServer({hideDSN:false,// Required for DSN functionalityname:"mail.example.com",onMailFrom(address,session,callback){const{dsn}=session.envelope;console.log(`MAIL FROM:${address.address}, RET=${dsn.ret}, ENVID=${dsn.envid}`);callback();},onRcptTo(address,session,callback){const{notify,orcpt}=address.dsn;console.log(`RCPT TO:${address.address}, NOTIFY=${notify?.join(",")}, ORCPT=${orcpt}`);callback();},asynconData(stream,session,callback){constmessageId=`msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;stream.on("end",async()=>{try{// Simulate message deliveryconstdeliveryTime=newDate();// Send DSN success notification if requestedawaitdsnNotifier.sendSuccessNotification(session.envelope,messageId,deliveryTime);callback(null,`Message${messageId}accepted for delivery`);}catch(error){callback(error);}});stream.resume();},});server.listen(2525,()=>{console.log("DSN-enabled SMTP server listening on port 2525");});
This example demonstrates:
Complete DSN workflowfrom parameter parsing to notification sending
RFC-compliant DSN messageswith proper headers and content
Conditional notificationsbased on NOTIFY parameters
Integration with nodemailerfor sending DSN notifications
Production-ready structurewith error handling
Supported commands and extensions​
Commands​
EHLO/HELO
EHLO
HELO
AUTHLOGIN·PLAIN·XOAUTH2† ·CRAM‑MD5†
AUTH
LOGIN
PLAIN
XOAUTH2
CRAM‑MD5
MAIL/RCPT/DATA
MAIL
RCPT
DATA
RSET/NOOP/QUIT/VRFY
RSET
NOOP
QUIT
VRFY
HELP(returns RFC 5321 URL)
HELP
STARTTLS
STARTTLS
†XOAUTH2andCRAM‑MD5must be enabled viaauthMethods.
XOAUTH2
CRAM‑MD5
authMethods
Extensions​
PIPELINING
PIPELINING
8BITMIME
8BITMIME
SMTPUTF8
SMTPUTF8
SIZE
SIZE
DSN(RFC 3461)
DSN
ENHANCEDSTATUSCODES(RFC 2034/3463)
ENHANCEDSTATUSCODES
TheCHUNKINGextension isnotimplemented.
CHUNKING
License​
MIT
Usage1 — Install2 — Require in your script3 — Create a server instance4 — Start listening5 — Shut down
1 — Install
2 — Require in your script
3 — Create a server instance
4 — Start listening
5 — Shut down
Options reference
TLS and STARTTLS
Handling errors
Handling authentication (onAuth)Password‑based (PLAIN / LOGIN)OAuth 2 (XOAUTH2)
onAuth
Password‑based (PLAIN / LOGIN)
OAuth 2 (XOAUTH2)
XOAUTH2
Validating client connection (onConnect/onClose)
onConnect
onClose
Validating TLS information (onSecure)
onSecure
Validating sender (onMailFrom)
onMailFrom
Validating recipients (onRcptTo)
onRcptTo
Processing incoming messages (onData)
onData
Using the SIZE extension
Using LMTP
Session object
Envelope object
Address objectDSN Object Properties
DSN Object Properties
Enhanced Status Codes (RFC 2034/3463)Enabling Enhanced Status CodesDisabling Enhanced Status CodesEnhanced Status Code Examples
Enabling Enhanced Status Codes
Disabling Enhanced Status Codes
Enhanced Status Code Examples
DSN (Delivery Status Notification) SupportDSN ParametersAccessing DSN ParametersDSN Parameter ValidationComplete DSN ExampleProduction DSN Implementation Example
DSN Parameters
Accessing DSN Parameters
DSN Parameter Validation
Complete DSN Example
Production DSN Implementation Example
Supported commands and extensionsCommandsExtensions
Commands
Extensions
License

